aws/aws-sdk-java
Starting project aws-sdk-java
Setupping...
----------------------
starting to query the gremlin database and download merge revision
eb99084363ce4d2cf24ed84dc8f311a0866178a0
b1ac7b30d77f8bfae0da6438c79e2cb9ea5d7710
14ca3e6c348d716199f8dbba10c9c8d98415ca49
dc46d2e4d6f84d33a21aa610474641419b725ab2
c50e0c21bce6e6f37ce000ddfa56d04204a88ba9
209b8526e151d5a679ac5a3145be19b9069ffbc9
49778f31d1667d7e7704d1ec693dbc34aebafce0
96e7e6942200f049ad8fb1ca2c95b5e21432399e
a510a1c56b9f1149c4dffbd05ea32dfec39a9f1f
e633d8aefea02ccbe655eb366ab21ddc2caacf50
b83eb48a3749001f529a5898bdad4d9c72d4fe28
28d3fc4ea11095dae4cf018ec713c69db558f825
a1f59d070eacff34994cf7188d869bf021e01a0f
2d0c9140fef09eea4f99a43b367ab86bd523673e
b7c8ac2c72142153772ab245d09745663756d728
65f667513d1f6e102468506471858ee1cd98d447
b4992d1b3bea34653dedc77c8077f5088efdb880
1a6be5cd4ee16d83726273262117037184c2ef7f
d1821e976a9073cfc15880dc92fbe5a672446f3b
ef31f4906e32c7ce076d8c5765921b66050b09b9
a401dbf04c4fee68c634439dd70accea1beee585
f9ea4c3cf74f686dd496ede3dfda8c27f10a05f9
18e99a12cbbf437d6c0be0d84486cfb937bf7abb
54857e8ac2805e93f391ac7555959237a6048ac0
cf49d27c323981b3868949a8f2061a7a51ed0b06
26bd0f3ecea9bce00f1870474130c625e2704141
6d56fea6102d05d109c3b24f1936b55cf31f8dce
172c614e8047d921a25d136574047131ea2e7c8e
76aa01d49e9f53dfa3cd6e21d83576703d37d706
a48ec097c98abe77ba1d289d29ae8bcd29737c58
ef7a63b07dfec9e9cc051e24b56a72e207daa30e
2dd166f640dc18e124b848431d96e669881ba859
3c7b62e95a1d742fab7a3593f9c9f9fa324ce739
ac6013502e68cf6eb39fc460556efb78a145b9e9
179d8b9a40a54aa1fb2abf670dd63171b43ae654
6ae2c7ef335ade36bf804c0f494044121673b3ce
0eefc63fb9f2d5769b346645c71d78fa896bdf1e
7b93e463c9965c9a4bbef89eb4e1108aa4440006
cc4a6635baf6fe13ae470b987522274e928bda8d
f04beb908018dcb0ca58ac6e00f2bd66953efe45
24d1a18a0a3f0842c5331acd46fd76f5cd102116
e5b02d4324b9b6893eddb767a95ab4ab23ce1bf7
7ab10af25bc8a019651a33f6d19579558350c761
a405a2e73611841a910615f4204fa587605fec1b
bafacbbcaa3213ba5ca510a3b2346fbe755eba1e
1868f99cdc4d5b47e2ae821254d24f14b0341ca4
a8e776f277fa1f051033f3208c94dbbd5b0fca24
533d81dca1c58776a1c07cce6da299707dc70f5e
0d8d25492e274cebd21838db6fac5646650e8c06
4c10a9c68516d8d00d8cf871e2de771a97f27777
5569edc5940f218539bfb1588b4a481f7ac61bea
273f01cee851cbaa6e6e4cd70908173865198d20
31549c7f509aa99bb966a11d8c70067c7f482998
021b8ed7ac47b5c74013a63e90056b151124dc49
d6cc9981a35882dc3d73618f54082a0e28384d2f
28375541f8a4ae27417419772190a8de2b68fc32
e30e97622147ef5121f4fa986ee0044f8bf13bf8
22474af252f3401cb8566966c53015db297280ee
95be4fede3e4d63a9604c403f50e35bb3083948e
59afde622eec7d3192319b3af2ba4e06398d6c5f
6066e6cb57bf88291373fd431c7a79bd62a9902f
fee2e26ee1b464a344bb27140edb0f3b4e5e848c
2649845bcfd45ea8b04bcd82c4d2586bcac705f2
43ef7062de656941173f0bd889aa8e3e05ed3288
07f51ec8cfe1600e7dc7f6b4a08b9311f32f9cec
0adb8ab9a4e73350622ff4938820b8dd2c26dc07
ca8d19654f32c3823956c0096a5af8c7c4c1949c
01d5872e52db13e14a8c57e8a15c5aa022411de9
58ac2224a78c85d2cce6097268a8adaa46171a44
c8851c2723ad654a6e46ba09aba0435b8255b84e
482034cb6d3472df80039671a4c01615ffbf4bfd
99bde08e241b505c83841a7c6cbdb34e15f0d01f
9ba23d813b65c952e285eca4e79e73011df48a99
42d77653be0a2387631470d3856de3e70ca89429
0d1c473a28f5cb15a68191ce26b5c5650e237d2b
9ec53d260ac57f479fc74d883e3a477322a325e8
09b3b844fd299ffe260e5ad47526ca9c56498e74
d3f9d13904b88d3ef56ab92d3d2d0c583514e4c9
acc11a228f2bb8979b7a7e160d621af309f4a0ce
e898419d0f29f7260aca3623b3b11bead767fc63
00837d5c4b101fedaff22da6b56062921b7addd0
238f6a0e6278f86e9347774d5ff164babb7800bf
d13567d3d2a2bf672af00337fbadf3f4aed3f879
a190ac3a97a0b2cbdc0a9fab9a4c9a5ad97670de
5289280d8c8e7000d450c4f1ae3e3193dfb0d14f
e84962e58f052ac1e8e46424c85431583dbe4d3b
55540f8697e401c52baf287fa7c2b9d9193e4e50
3c42afd5a1677259ce77ee4e49ecae0657cec63a
0475b7ad99400acec4d9123962200b68002b8a29
d0a83ded38a3b9f13385f8e243194e1908453cb6
5fe96e6d0072990c8c9c33cf28251be4f73d1628
e210112824d698402f14f52c6939793a9e204911
432000747ed90ed0a644ed1c24cfc3b04a0562c6
a0e906122cef23c3620ef2f9f3fb777c4c17bf69
cc755dd39df8bc8406bcd8c0203220ed63e0b0b1
d80cb559303168894f14b1455715831dce884026
65a29c83a4f2d336cefaa2b3615f9d425565369b
b433c97d1bc2e4c1db68384cd5c9ff5ad89fc09a
a0294bdcd74eedf021e7cdb70addf46ae6056d9d
ead5459648b237a60a67ef87d7e11f2e77d288af
747c50c1312fde969a8434465f5afb0ed135b282
42d2587360a3ccefc0f082c9d7ef3b4b9ead793c
3cb271c1e9849365329f9812310890d2070a3436
f7ce7e9221b5ad04e5eb648c872e50977eeeb650
110c968c34e65bc904b487d95d990beb352fb549
fdbff1d42a73081035fa7b0f172b9b5c30edf41f
a46c59e724460c354bfb26dc8485ccfce5faf106
c422977d8cfa2e6f650b26182faa8592e6c287dd
5b46c45e6f3701853e65c4dfb5c3dca9ef90f30f
a70fadbad47a1fa4e6c836a23f4b2be94d2f09d0
6638de12881c0d553d9b47b6ad33c1c16f552ab4
9403ad7ec27a075fbdffbaf2d30d3dce29a15d82
5d52b926f69a7488b64d77651ad850da17ef02ac
3facb6416a9892b6dcb9e39d7a480e22c7f4ab48
3a7c4cc660b80ee75046bb98c1edb90b26ad5138
909d2a2cd8816dd48b15a2e79a8f0dfb65cd2356
d2b52eb2c7906d1e784a484dcd71688e0cfe1543
f982142a5d61fedee30e788bcf921d6e246576b5
a52f46f3a86fea176d6d6845261414a483df9db3
d88852a9444307a605c95af606c376480ebfa35b
a2567c698a92abf1347885c82634e3b14e436b01
2df03d91c571cbf88dfc8a846970ff32244ccc55
f5154b157568ddf33e71c2b2b68580646a073b58
5d1ba89bffef2112aee336866c69df3b4e90f884
f667668148d05770b74f1d7a12e05ddfcec50921
5f5810a25d49e28bd202fe8e97209356f77171ba
ce1de00b97ada9f9e878baeb4119f87967f119a4
cca1ccdb3354a22dbb230bd3aa180e678ae48c9c
77f6cd3293fdeff945982ba82f4ed77d0e5c0827
4a9fe1431178d256c712c081770c35904e46bd52
7f818412c8d3a64582d37f18faca8865cf3ff59e
ebdfabf87208d5cbc733b7b020b82dedbf0b8c7a
c0bbbf7e6a6c0953e67b925c0b0732b264e87c33
570c895c46d1c45e97f006df4f8d3f9e9ac003f1
2f20f911160c649bf08fa14a7a74fca82b6575f9
6197837200734b5feacad512905174c5185388fd
cb4c4fb32bba8170d9852e517a10d17e5cc7e59c
9fe20ee1622f70f31c0932ab3a1970094fc19f02
4d3f604717b53619e791d9120a238e0b1af63856
e621352e8ab63dabeeec2bfcbade55833935bee7
82b5bbdaa62f09326d8e9bbc56ee0e0329519a78
dc46d2e4d6f84d33a21aa610474641419b725ab2
2cda7e0ec79b726c7e8da9c72bbf6d2a9d5bfffa
0f625f5fdcdef7e8a10444281a19a6abb1a01672
5384786c78ffe1b46ee014cad4070ab53fdee997
fd2b368ff2374e886de4d742815cb3c278c9cbac
02003ef0742bc3e0e39f9fe41cbedcf711a865e1
0a183e02b29b06e9324b740af40daff9193c9290
7e8743e346ed20d6cf92d3b20db27082fe596e12
96e7e6942200f049ad8fb1ca2c95b5e21432399e
51bb741003f9a0e5a83022489729cb759bc6f833
8dc114d1c8d23ee1f4632da7b08e5df2405d93d7
6bc5001ba7d95404f42fe0d5fa2d19d85e247a5f
764b280988d7a303f7f2edcb59f5785e103afa97
a875cf04b10599d402e813d756a08970724af512
a3a2c56f27770e241f777a63034743d95d6a7486
8cee0c9f09d92bf02be0cd112a5664d4b7fd7833
50eeb4599734803207a43116cf9a065c35cf3327
7fbb5ff46f74f5ea421a76eadf49513d82cf9be9
13f431c2d2e82f8903aa362b9b1a271f8a664557
df47d15ef998c9dc8d552d86404b5be3a7c36a6e
8ab73f5ce664b66f1f5b8d3ffb4a6b21859740b3
958255b20c0ac737a9a7b7b0ff0ae5021b4e643c
b7c8ac2c72142153772ab245d09745663756d728
c8b8e60826519a12ed28a6f0feb7f5cadcbd5b17
65f667513d1f6e102468506471858ee1cd98d447
252778cd085482f339f31a2dd22fea7bc46a1008
a9a7e48aa7751e7f12418ea3e650a27fd28489cd
041722b5a1b262487105bc8864146364fbac9c6e
045c79bce0e15634f27019185bfc09f876076629
b9ca95db8a03f7443555fd1039120d0c7816fdfb
2491dbbf31ac0b2a9920a90c719c8c322b1af3a2
ef31f4906e32c7ce076d8c5765921b66050b09b9
5d590178638297ccd3a1870c021683b92c741e6e
30eb6d04cf498b68094db0952298c8806df2c4a4
c94e9c0dad80f6439db96b05030ea30876ccab99
0d067a13c1cede7e036973b3bb319c0444c7c3e8
f9ea4c3cf74f686dd496ede3dfda8c27f10a05f9
0c799e6d62aa0936ff7b74ee2b3cfa00a8209dbd
18e99a12cbbf437d6c0be0d84486cfb937bf7abb
bd32544fa3674de4ce3d3e5a0c7a037780ab83c5
495ff100e125c8eb4eb6913bc684540bf9921338
97e1d1f0ce73599003995cca16435055ebee884a
cd9cac6ab75b23d446d7aca2bbaeb6bf6e428fa8
b15a82ce71f57da7a02c989b207b5f02be9cd8b3
26bd0f3ecea9bce00f1870474130c625e2704141
2c0b2b7c01492d8bce5c6bce37122e2e8d672490
5577ce3219373903e1c0cf12bc8ff341901fcdd3
40ed493a630b7a39212efc91d07a1ab20d5e2dab
172c614e8047d921a25d136574047131ea2e7c8e
96a4c021c3c8d4df87106557574dd1711d6d3a57
76aa01d49e9f53dfa3cd6e21d83576703d37d706
6ec3d648a918e5f07f451201db1b4bba8677b22a
a48ec097c98abe77ba1d289d29ae8bcd29737c58
c8f9fcab8fad592a4af66189b0a07a581bc1b454
68aa8700908e41c43eb9157fda13f03075679101
e74b8096a4a9c85373265d880ed1c01344a58efc
653574ec94cdf70df26d4d1755f4bd7dd48cb90c
efcef0cf0dbaa39603067f51dee89e11d04aa0ef
e00eb7ca9445719e20bd591f52b27526539e0e6a
346f05e0af4e661b8bbb3a15122b8b920fc2767a
f07abdc0d3993e14d378619b8ac23ec98c07c69a
8888487157bf3485aa0862cd95d29bd53d9bd417
179d8b9a40a54aa1fb2abf670dd63171b43ae654
7ee02543f9fdbae474d4cb8f0cfdde3eaf8b7e60
c87d36dfb65c2030090017066dbe6f0ba2d7a818
d5edc1cb96a82743937f169b099e212dfede5222
0eefc63fb9f2d5769b346645c71d78fa896bdf1e
45d053fb5b3777ab54fee8e8b786428604bdae78
6837d3ba3faa00c79be5e83dfd0eab8f513216d1
8736d216089151ebae73353ed629757ef349ecdb
8deb49c600ca05a6098f42e887bf49620a31c058
228a367617dcef1eb0a14946defc7fb32b3555dc
ee9d2025f2c0801c53a1c21a03ef01a43254fdf9
4a19070e3af40b344b224b87beae0e7c9cef2a32
24d1a18a0a3f0842c5331acd46fd76f5cd102116
f9d6352a4c3f376202b8951e30b319794ad3e2be
c76e56aa333a8a356528aa2afe4e5ea6680e91e6
7ab10af25bc8a019651a33f6d19579558350c761
257dd4908cf99ec1982feed247fd2253589c222a
03864b7fe3bc7b544e68bee2ed2221acf264ed3f
a405a2e73611841a910615f4204fa587605fec1b
a86dd359ddd3b460f844d73dc7d417b844b8c155
bafacbbcaa3213ba5ca510a3b2346fbe755eba1e
d9613957eef26df5b7fc5b965127220fee8a20c5
69c991e5fbfa4e92f2d182acf8a7d74829ffefd3
1d8722f0003075abc34278ae13f619f4f466e491
9fb660f70476ed2b3cd6e6d90af8b97e224346cb
badd198259937bab3cf0fd70d30fab1ec6d1dfc5
7e7e5014bcdb45d6c9e56c410206115a491f0ad9
3d0edcd5fa9305e692a93c94fe14a31c4863dc95
4a67bca8f1c6d5cf80a112f82d5d3a3967ebcdaf
642ed3a749b89d2b1d1e6db255e223bf49ba6361
4c10a9c68516d8d00d8cf871e2de771a97f27777
6b3ec3442ac6caa5649e3b3f52ddfb7194668e9c
0c9ceaec0bb30fd4c144a1bc9d87c7566f440c47
273f01cee851cbaa6e6e4cd70908173865198d20
0c9ceaec0bb30fd4c144a1bc9d87c7566f440c47
eb645b42c551c2f99faee7a67d4e5b51303d11db
1c30eebd13a609a094e48a78e049cfa5f1a7a6e2
8d5efee91d0161af7e2e424a012a42bf7e994b3b
a3c759a7c5e975300c68dfe42a4e899e031a7a45
215a7f1a5eb0ceada91b3ee0449a22348dfc1c50
066ac950626371ff08a0928fe7628cf7cc0009c2
ca2148b53e28f8415cc4682868e25e63aeade2b9
7a99f7738d7b4e811e7acfd39b8be7b051941a41
14d65d22dec239a564691d254ff86fe70c33ce35
e27bc65cf33239e0508cae040248800b9106b82d
071bc7ce660f2fc34618831a5555c104b459503c
cf8343ff5b12dac8cbf17afce76b2e663d12f121
1b4ed738a6b9b17aeb4523101e3e7669e1367ca6
cf21041bc0129512cd30431fc4a960f9e73e6cbc
e90090ecec0e173747c9b847ada700f17c0a2b66
59afde622eec7d3192319b3af2ba4e06398d6c5f
8e3776e3ec1986a9a3a5ad7d77b135cd24b8484f
2491f516bf571b3b7c0c63e99bf7b48b3f894696
3f661541037eae1ba6adda84e9f44309f2502d33
fee2e26ee1b464a344bb27140edb0f3b4e5e848c
0f6feb080439b5267683c632dace81a17ffeb9f1
2649845bcfd45ea8b04bcd82c4d2586bcac705f2
96051f32793829c174272dc6fb594a4e9e555d63
c4d15d5c1642340bf5c3299bbbb7d9087de68be7
acf4200beb2cdf1fd5bd91c5c0aa7c63b19871c5
07f51ec8cfe1600e7dc7f6b4a08b9311f32f9cec
6b7496721f40da659358ca4d287524416d84c2e7
e925ba8defbb04a1c5f8af7860d4501186bbfeb7
c1798e2d2906064b3befe0cbaf7a3a05a4bea222
ca8d19654f32c3823956c0096a5af8c7c4c1949c
8ce7f2b625af487073231b9982589bf23ecc1d73
01d5872e52db13e14a8c57e8a15c5aa022411de9
43e0e102a5901f5c3d3739ed8d3d1e6c52b3f781
248efeeff0842991b74e1a96367c7ad6c8fd1e2a
a0f1e318acec21f0766af75064b6a261fbbe0d0b
8f0ce23d82184449a67d60eb5d3a97447c2acddf
2e36995337b35b9f25fe95697d25b8479a1655b6
c7cd9cb3d2df52c07755a3b8e2e4e533ec542989
6b3f46a4276d73e4459d59d30b60f47b6889a419
99bde08e241b505c83841a7c6cbdb34e15f0d01f
75a34d164e4e9eba496087f5134bcb96accd4b48
9ba23d813b65c952e285eca4e79e73011df48a99
940f53077f756af5c232a04076fc9cad59046c9d
42d77653be0a2387631470d3856de3e70ca89429
30b3d163e054b35797fb12f8d24231b4264742b5
04ea743936d1fd1a4e0555295418b3148c834a74
72096c99b3fcbb4f659a34f47d869091f4538b72
ca64992cf428932800e086a627e42a32b76095a1
36418de8746637660fcb587691bcea07254bd200
7ebd55fa100ebb7f6023c9b7f60f069106b01d45
5b6d82f9adcbb25e3ee4c3392936ab53929693a4
d3f9d13904b88d3ef56ab92d3d2d0c583514e4c9
04ad420f594bedd8cd5c40160d67585f70686a9c
b4fc081aee9ceb9ba94060efbe41b6de4161b4d6
9ad205588102d65c1c139dea244f4b4137f739dc
e898419d0f29f7260aca3623b3b11bead767fc63
05f009f7a3b28f74c66a4ddc6055aaf570e54a1a
70c81c62c6f4238ca3105002151dff5d78652786
59b06ae9b15e013153d53c1d9047c564455e9144
6f22effec4337edab75fdbe5cde0ed81d2e6d5fd
14a06c52474999e4ef1775d803cf6c3e8eb5410d
d13567d3d2a2bf672af00337fbadf3f4aed3f879
fcbae65716a5006d4adee83eeafe35ed48ef1278
a190ac3a97a0b2cbdc0a9fab9a4c9a5ad97670de
cafd19255d2b1540347207136ce4a8040af08246
6e0d6e1a00d573040af6ced97cf22543968524ee
68791fb923662d798b2a9370c3d3796135b94114
cafd19255d2b1540347207136ce4a8040af08246
1c1f8020b6c17631d05ffa40a3009cec276f1196
38ffbdb2fc8cc9ae0b9ab50f03eba7d27a9fac89
b50e223fb634e0f685fe32e4659c4742caac3f6b
3c42afd5a1677259ce77ee4e49ecae0657cec63a
d300a0a89988c86686d4c28ff3b63aacc25a2124
4ee6a6518887fb7adb0388e6cc3d9f79a7768a69
8e8608976fb05adf5d97c1b0a6450041737a5081
bb9e0be441afb5658f0edbbd19bcf27e2fac4105
973eb4b6dbcc4680fa0e2d667d873777e4959d93
dd74a38c414c63306679e5d67152932be4c8f145
dc26048f87ec9db72c8aa7af44dacf63ee543b60
83b94cf5bff779fa979a9809e577e7a15635fe55
df98496a9afb95e0a8526cf9ba476ad01d20524f
028dabab3bb44557e0e9509521a72fd451b6cc28
bec61e4539d0bd6660a0b43823221b7fc340b0b4
a0e906122cef23c3620ef2f9f3fb777c4c17bf69
e81820d56dc7ad2e178cad75b85334cc7fdcf00a
8e89db00da117b0114e7fa56fd10da6b97e6c8ba
fb8920de1e501f4eebeafd3ad04e2600747a4f74
15d2fdcc200885cf2d7e0fee368c757e6039bafa
391245d3d31737e6bcc1e6ac1e7e486c78561014
65a29c83a4f2d336cefaa2b3615f9d425565369b
3464dc59de50b17fcdf883dcfc9ef30cfa6c8877
b433c97d1bc2e4c1db68384cd5c9ff5ad89fc09a
c99559b7c92422aca8a5e718ee57e46fb6433c2c
0d08bc14a249c071fb30b93b3294ee6d2772774f
4f391bccd4fabc8478c39866c5583716a7dc8ef4
ead5459648b237a60a67ef87d7e11f2e77d288af
f4c90ece32e3a6d15b1e6e028188f9701bf90494
fa4d0f73cd2bee11117c6baec9d492a0ac51207d
1613bc438d87e914c5e396b8b23a97bceb1eaca0
42d2587360a3ccefc0f082c9d7ef3b4b9ead793c
7d2492758cffde2f790746ca2976f61e1f28d9fc
3cb271c1e9849365329f9812310890d2070a3436
aad7d48694a0fab5bc68098717c293eb5714ff67
f7ce7e9221b5ad04e5eb648c872e50977eeeb650
b115a8058364a5ba33e063b2fee64a9a0a9239cd
110c968c34e65bc904b487d95d990beb352fb549
1d39b273049db7612293013c6fe9152f780b90c1
42d2587360a3ccefc0f082c9d7ef3b4b9ead793c
69864852f6868eb0ee71d17a49379e9448412036
8401b94d964eeac11f4d3fea06128cbf6caf59d0
6a037afb1797659b06bffa4db6e658d98b289f77
c422977d8cfa2e6f650b26182faa8592e6c287dd
1069d4f0b8d30ff3a07ed505321ee0d2ded3a569
dcbec074f4f5bc6bb2928b066a296e8227f52368
6a6fcb3cbbca072e69b99bb3e17e31739cce964f
a70fadbad47a1fa4e6c836a23f4b2be94d2f09d0
e60f737cd180b09febed315ad6c2e72c31a5bc49
6638de12881c0d553d9b47b6ad33c1c16f552ab4
9403ad7ec27a075fbdffbaf2d30d3dce29a15d82
3f60b0a2a04174a9b580fab1cd757fbcd1fba85d
5d52b926f69a7488b64d77651ad850da17ef02ac
74c1e9bd4a847ac2559e0de7a846468c2e0fcbb9
8612a002d3b9fa5b76ab7554e174f506bc9736f0
3facb6416a9892b6dcb9e39d7a480e22c7f4ab48
21c604f77ab337615d4da9a4e38733b7df98bd75
3a7c4cc660b80ee75046bb98c1edb90b26ad5138
f9155587db3d13865d03857341832b78e0c9b226
1b312f8bcf1a232682855b355dd57fb8fab5db3d
7aeb8cca985652ae980367b4ce59bd5d6db327e9
e17e60c2e12440fa871834ff3d9695d56bb02e86
d4a70bb4729aad5478def47067cff3de1f428f85
f12f53e38b09cbbb0c3fe58defa1f79ca747d8eb
4b6104fa5f3160d96583cdbbee60c89cd027d7ac
3bc237cda33f0041d93e25052ef8cef084451abd
ebe7ee53ea8a4751cb91fc4b05e484e78aa3ab87
d88852a9444307a605c95af606c376480ebfa35b
71c8a126e4b13f7037c788fb2d40f56c3feb0142
2b221c543eb304860474ee007816e8390b54e5fd
61f4a3415524ad567b486aba283ee80a03d2f298
9e3bc0c2fefcd713ecf099f3233dc20d3c6914ba
fbfd5fd9bb171b1ab5533822c1a201f6d12c6523
7660f6ad511ecf72388bf2834b967a74e2822a2a
1c3bc7d2c3e4e95de1f85b283b0d7e12c70b54fc
c1d69bf9e004bb8a84112ace3c88d36479e24c5e
9efece1adf60deb6c88cbbff6d2a142714505e6e
46f1ad69aaed7d9001134dcb7a5ac7735c894593
a4bf215f5e7f9a70b5451ab393eea0796965d40f
78f478ef8320ec48bac79128c4d23ae1292335a8
cd922314691eaf34557e7724c3ae3bc61e65e288
a49147fdd69043f41e3b35e473bdddd3b19e22e9
4530b55b4f83b20f67803e2e40921dc5fd2e3368
cca1ccdb3354a22dbb230bd3aa180e678ae48c9c
990c19dce2485ae54883d54cdd0ffd636cf1798f
d694351979591ed76c8cb0bc7d2d782b8c9881e9
4047754cadfeb091f73672117f54b8d0279020ac
4a9fe1431178d256c712c081770c35904e46bd52
6bf46018460057762f6ad3bf2590e9958d56b66e
8cf9792052dd2ab44b106218347f20f8b0fc3aad
eb99084363ce4d2cf24ed84dc8f311a0866178a0, c0bbbf7e6a6c0953e67b925c0b0732b264e87c33, 570c895c46d1c45e97f006df4f8d3f9e9ac003f1, Thu Sep 08 15:35:41 BRT 2011
b1ac7b30d77f8bfae0da6438c79e2cb9ea5d7710, 2f20f911160c649bf08fa14a7a74fca82b6575f9, 6197837200734b5feacad512905174c5185388fd, Tue Oct 18 17:46:58 BRT 2011
14ca3e6c348d716199f8dbba10c9c8d98415ca49, cb4c4fb32bba8170d9852e517a10d17e5cc7e59c, 9fe20ee1622f70f31c0932ab3a1970094fc19f02, Mon Dec 05 19:40:15 BRT 2011
dc46d2e4d6f84d33a21aa610474641419b725ab2, 4d3f604717b53619e791d9120a238e0b1af63856, e621352e8ab63dabeeec2bfcbade55833935bee7, Mon Jan 23 17:47:10 BRT 2012
c50e0c21bce6e6f37ce000ddfa56d04204a88ba9, 82b5bbdaa62f09326d8e9bbc56ee0e0329519a78, dc46d2e4d6f84d33a21aa610474641419b725ab2, Wed Jan 25 16:12:03 BRT 2012
209b8526e151d5a679ac5a3145be19b9069ffbc9, 2cda7e0ec79b726c7e8da9c72bbf6d2a9d5bfffa, 0f625f5fdcdef7e8a10444281a19a6abb1a01672, Mon Feb 06 23:04:41 BRT 2012
49778f31d1667d7e7704d1ec693dbc34aebafce0, 5384786c78ffe1b46ee014cad4070ab53fdee997, fd2b368ff2374e886de4d742815cb3c278c9cbac, Mon Feb 20 16:43:21 BRT 2012
96e7e6942200f049ad8fb1ca2c95b5e21432399e, 02003ef0742bc3e0e39f9fe41cbedcf711a865e1, 0a183e02b29b06e9324b740af40daff9193c9290, Fri Feb 24 15:41:24 BRT 2012
a510a1c56b9f1149c4dffbd05ea32dfec39a9f1f, 7e8743e346ed20d6cf92d3b20db27082fe596e12, 96e7e6942200f049ad8fb1ca2c95b5e21432399e, Fri Mar 02 18:22:45 BRT 2012
e633d8aefea02ccbe655eb366ab21ddc2caacf50, 51bb741003f9a0e5a83022489729cb759bc6f833, 8dc114d1c8d23ee1f4632da7b08e5df2405d93d7, Wed May 02 21:57:24 BRT 2012
b83eb48a3749001f529a5898bdad4d9c72d4fe28, 6bc5001ba7d95404f42fe0d5fa2d19d85e247a5f, 764b280988d7a303f7f2edcb59f5785e103afa97, Tue May 29 15:53:35 BRT 2012
28d3fc4ea11095dae4cf018ec713c69db558f825, a875cf04b10599d402e813d756a08970724af512, a3a2c56f27770e241f777a63034743d95d6a7486, Tue Sep 18 14:14:18 BRT 2012
a1f59d070eacff34994cf7188d869bf021e01a0f, 8cee0c9f09d92bf02be0cd112a5664d4b7fd7833, 50eeb4599734803207a43116cf9a065c35cf3327, Thu Nov 08 21:51:16 BRT 2012
2d0c9140fef09eea4f99a43b367ab86bd523673e, 7fbb5ff46f74f5ea421a76eadf49513d82cf9be9, 13f431c2d2e82f8903aa362b9b1a271f8a664557, Fri Jan 25 21:25:04 BRT 2013
b7c8ac2c72142153772ab245d09745663756d728, df47d15ef998c9dc8d552d86404b5be3a7c36a6e, 8ab73f5ce664b66f1f5b8d3ffb4a6b21859740b3, Tue Feb 05 19:15:47 BRT 2013
65f667513d1f6e102468506471858ee1cd98d447, 958255b20c0ac737a9a7b7b0ff0ae5021b4e643c, b7c8ac2c72142153772ab245d09745663756d728, Wed Feb 06 18:00:34 BRT 2013
b4992d1b3bea34653dedc77c8077f5088efdb880, c8b8e60826519a12ed28a6f0feb7f5cadcbd5b17, 65f667513d1f6e102468506471858ee1cd98d447, Thu Feb 07 17:08:52 BRT 2013
1a6be5cd4ee16d83726273262117037184c2ef7f, 252778cd085482f339f31a2dd22fea7bc46a1008, a9a7e48aa7751e7f12418ea3e650a27fd28489cd, Fri Feb 22 15:04:39 BRT 2013
d1821e976a9073cfc15880dc92fbe5a672446f3b, 041722b5a1b262487105bc8864146364fbac9c6e, 045c79bce0e15634f27019185bfc09f876076629, Fri Mar 08 22:28:02 BRT 2013
ef31f4906e32c7ce076d8c5765921b66050b09b9, b9ca95db8a03f7443555fd1039120d0c7816fdfb, 2491dbbf31ac0b2a9920a90c719c8c322b1af3a2, Fri Apr 19 17:12:15 BRT 2013
a401dbf04c4fee68c634439dd70accea1beee585, ef31f4906e32c7ce076d8c5765921b66050b09b9, 5d590178638297ccd3a1870c021683b92c741e6e, Fri Apr 19 19:11:12 BRT 2013
f9ea4c3cf74f686dd496ede3dfda8c27f10a05f9, 30eb6d04cf498b68094db0952298c8806df2c4a4, c94e9c0dad80f6439db96b05030ea30876ccab99, Wed Apr 24 01:18:05 BRT 2013
18e99a12cbbf437d6c0be0d84486cfb937bf7abb, 0d067a13c1cede7e036973b3bb319c0444c7c3e8, f9ea4c3cf74f686dd496ede3dfda8c27f10a05f9, Wed Apr 24 01:22:26 BRT 2013
54857e8ac2805e93f391ac7555959237a6048ac0, 0c799e6d62aa0936ff7b74ee2b3cfa00a8209dbd, 18e99a12cbbf437d6c0be0d84486cfb937bf7abb, Fri Apr 26 14:46:07 BRT 2013
cf49d27c323981b3868949a8f2061a7a51ed0b06, bd32544fa3674de4ce3d3e5a0c7a037780ab83c5, 495ff100e125c8eb4eb6913bc684540bf9921338, Fri Aug 02 15:20:31 BRT 2013
26bd0f3ecea9bce00f1870474130c625e2704141, 97e1d1f0ce73599003995cca16435055ebee884a, cd9cac6ab75b23d446d7aca2bbaeb6bf6e428fa8, Fri Aug 16 15:26:04 BRT 2013
6d56fea6102d05d109c3b24f1936b55cf31f8dce, b15a82ce71f57da7a02c989b207b5f02be9cd8b3, 26bd0f3ecea9bce00f1870474130c625e2704141, Fri Aug 16 16:10:36 BRT 2013
172c614e8047d921a25d136574047131ea2e7c8e, 2c0b2b7c01492d8bce5c6bce37122e2e8d672490, 5577ce3219373903e1c0cf12bc8ff341901fcdd3, Thu Sep 05 16:19:18 BRT 2013
76aa01d49e9f53dfa3cd6e21d83576703d37d706, 40ed493a630b7a39212efc91d07a1ab20d5e2dab, 172c614e8047d921a25d136574047131ea2e7c8e, Thu Sep 05 16:32:59 BRT 2013
a48ec097c98abe77ba1d289d29ae8bcd29737c58, 96a4c021c3c8d4df87106557574dd1711d6d3a57, 76aa01d49e9f53dfa3cd6e21d83576703d37d706, Thu Sep 05 16:47:56 BRT 2013
ef7a63b07dfec9e9cc051e24b56a72e207daa30e, 6ec3d648a918e5f07f451201db1b4bba8677b22a, a48ec097c98abe77ba1d289d29ae8bcd29737c58, Fri Sep 06 14:34:57 BRT 2013
2dd166f640dc18e124b848431d96e669881ba859, c8f9fcab8fad592a4af66189b0a07a581bc1b454, 68aa8700908e41c43eb9157fda13f03075679101, Tue Oct 08 17:13:54 BRT 2013
3c7b62e95a1d742fab7a3593f9c9f9fa324ce739, e74b8096a4a9c85373265d880ed1c01344a58efc, 653574ec94cdf70df26d4d1755f4bd7dd48cb90c, Tue Oct 22 20:08:26 BRT 2013
ac6013502e68cf6eb39fc460556efb78a145b9e9, efcef0cf0dbaa39603067f51dee89e11d04aa0ef, e00eb7ca9445719e20bd591f52b27526539e0e6a, Thu Oct 31 16:25:07 BRT 2013
179d8b9a40a54aa1fb2abf670dd63171b43ae654, 346f05e0af4e661b8bbb3a15122b8b920fc2767a, f07abdc0d3993e14d378619b8ac23ec98c07c69a, Mon Nov 04 14:45:01 BRT 2013
6ae2c7ef335ade36bf804c0f494044121673b3ce, 8888487157bf3485aa0862cd95d29bd53d9bd417, 179d8b9a40a54aa1fb2abf670dd63171b43ae654, Mon Nov 04 17:04:06 BRT 2013
0eefc63fb9f2d5769b346645c71d78fa896bdf1e, 7ee02543f9fdbae474d4cb8f0cfdde3eaf8b7e60, c87d36dfb65c2030090017066dbe6f0ba2d7a818, Wed Jan 15 12:14:30 BRT 2014
7b93e463c9965c9a4bbef89eb4e1108aa4440006, d5edc1cb96a82743937f169b099e212dfede5222, 0eefc63fb9f2d5769b346645c71d78fa896bdf1e, Wed Jan 22 16:07:25 BRT 2014
cc4a6635baf6fe13ae470b987522274e928bda8d, 45d053fb5b3777ab54fee8e8b786428604bdae78, 6837d3ba3faa00c79be5e83dfd0eab8f513216d1, Thu Feb 06 17:05:01 BRT 2014
f04beb908018dcb0ca58ac6e00f2bd66953efe45, 8736d216089151ebae73353ed629757ef349ecdb, 8deb49c600ca05a6098f42e887bf49620a31c058, Thu Mar 27 18:53:44 BRT 2014
24d1a18a0a3f0842c5331acd46fd76f5cd102116, 228a367617dcef1eb0a14946defc7fb32b3555dc, ee9d2025f2c0801c53a1c21a03ef01a43254fdf9, Thu Apr 24 19:54:25 BRT 2014
e5b02d4324b9b6893eddb767a95ab4ab23ce1bf7, 4a19070e3af40b344b224b87beae0e7c9cef2a32, 24d1a18a0a3f0842c5331acd46fd76f5cd102116, Thu Apr 24 20:22:21 BRT 2014
7ab10af25bc8a019651a33f6d19579558350c761, f9d6352a4c3f376202b8951e30b319794ad3e2be, c76e56aa333a8a356528aa2afe4e5ea6680e91e6, Thu Jun 19 10:53:45 BRT 2014
a405a2e73611841a910615f4204fa587605fec1b, 7ab10af25bc8a019651a33f6d19579558350c761, 257dd4908cf99ec1982feed247fd2253589c222a, Tue Jun 24 13:46:43 BRT 2014
bafacbbcaa3213ba5ca510a3b2346fbe755eba1e, 03864b7fe3bc7b544e68bee2ed2221acf264ed3f, a405a2e73611841a910615f4204fa587605fec1b, Tue Jun 24 13:47:15 BRT 2014
1868f99cdc4d5b47e2ae821254d24f14b0341ca4, a86dd359ddd3b460f844d73dc7d417b844b8c155, bafacbbcaa3213ba5ca510a3b2346fbe755eba1e, Tue Jun 24 18:25:10 BRT 2014
a8e776f277fa1f051033f3208c94dbbd5b0fca24, d9613957eef26df5b7fc5b965127220fee8a20c5, 69c991e5fbfa4e92f2d182acf8a7d74829ffefd3, Thu Jun 26 18:34:40 BRT 2014
533d81dca1c58776a1c07cce6da299707dc70f5e, 1d8722f0003075abc34278ae13f619f4f466e491, 9fb660f70476ed2b3cd6e6d90af8b97e224346cb, Fri Aug 01 19:00:50 BRT 2014
0d8d25492e274cebd21838db6fac5646650e8c06, badd198259937bab3cf0fd70d30fab1ec6d1dfc5, 7e7e5014bcdb45d6c9e56c410206115a491f0ad9, Wed Aug 13 15:54:32 BRT 2014
4c10a9c68516d8d00d8cf871e2de771a97f27777, 3d0edcd5fa9305e692a93c94fe14a31c4863dc95, 4a67bca8f1c6d5cf80a112f82d5d3a3967ebcdaf, Fri Aug 22 20:44:32 BRT 2014
5569edc5940f218539bfb1588b4a481f7ac61bea, 642ed3a749b89d2b1d1e6db255e223bf49ba6361, 4c10a9c68516d8d00d8cf871e2de771a97f27777, Thu Sep 11 14:00:17 BRT 2014
273f01cee851cbaa6e6e4cd70908173865198d20, 6b3ec3442ac6caa5649e3b3f52ddfb7194668e9c, 0c9ceaec0bb30fd4c144a1bc9d87c7566f440c47, Thu Sep 25 14:10:48 BRT 2014
31549c7f509aa99bb966a11d8c70067c7f482998, 273f01cee851cbaa6e6e4cd70908173865198d20, 0c9ceaec0bb30fd4c144a1bc9d87c7566f440c47, Thu Sep 25 14:11:14 BRT 2014
021b8ed7ac47b5c74013a63e90056b151124dc49, eb645b42c551c2f99faee7a67d4e5b51303d11db, 1c30eebd13a609a094e48a78e049cfa5f1a7a6e2, Tue Nov 04 17:48:07 BRT 2014
d6cc9981a35882dc3d73618f54082a0e28384d2f, 8d5efee91d0161af7e2e424a012a42bf7e994b3b, a3c759a7c5e975300c68dfe42a4e899e031a7a45, Tue Dec 02 15:27:22 BRT 2014
28375541f8a4ae27417419772190a8de2b68fc32, 215a7f1a5eb0ceada91b3ee0449a22348dfc1c50, 066ac950626371ff08a0928fe7628cf7cc0009c2, Thu Dec 18 21:38:57 BRT 2014
e30e97622147ef5121f4fa986ee0044f8bf13bf8, ca2148b53e28f8415cc4682868e25e63aeade2b9, 7a99f7738d7b4e811e7acfd39b8be7b051941a41, Wed Feb 04 16:01:21 BRT 2015
22474af252f3401cb8566966c53015db297280ee, 14d65d22dec239a564691d254ff86fe70c33ce35, e27bc65cf33239e0508cae040248800b9106b82d, Tue Feb 10 21:43:30 BRT 2015
95be4fede3e4d63a9604c403f50e35bb3083948e, 071bc7ce660f2fc34618831a5555c104b459503c, cf8343ff5b12dac8cbf17afce76b2e663d12f121, Mon Feb 16 17:49:57 BRT 2015
59afde622eec7d3192319b3af2ba4e06398d6c5f, 1b4ed738a6b9b17aeb4523101e3e7669e1367ca6, cf21041bc0129512cd30431fc4a960f9e73e6cbc, Mon Mar 02 15:26:32 BRT 2015
6066e6cb57bf88291373fd431c7a79bd62a9902f, e90090ecec0e173747c9b847ada700f17c0a2b66, 59afde622eec7d3192319b3af2ba4e06398d6c5f, Tue Mar 03 01:07:15 BRT 2015
fee2e26ee1b464a344bb27140edb0f3b4e5e848c, 8e3776e3ec1986a9a3a5ad7d77b135cd24b8484f, 2491f516bf571b3b7c0c63e99bf7b48b3f894696, Tue Mar 17 19:31:18 BRT 2015
2649845bcfd45ea8b04bcd82c4d2586bcac705f2, 3f661541037eae1ba6adda84e9f44309f2502d33, fee2e26ee1b464a344bb27140edb0f3b4e5e848c, Tue Mar 17 19:33:09 BRT 2015
43ef7062de656941173f0bd889aa8e3e05ed3288, 0f6feb080439b5267683c632dace81a17ffeb9f1, 2649845bcfd45ea8b04bcd82c4d2586bcac705f2, Thu Mar 19 13:39:40 BRT 2015
07f51ec8cfe1600e7dc7f6b4a08b9311f32f9cec, 96051f32793829c174272dc6fb594a4e9e555d63, c4d15d5c1642340bf5c3299bbbb7d9087de68be7, Thu Apr 09 19:32:54 BRT 2015
0adb8ab9a4e73350622ff4938820b8dd2c26dc07, acf4200beb2cdf1fd5bd91c5c0aa7c63b19871c5, 07f51ec8cfe1600e7dc7f6b4a08b9311f32f9cec, Mon Apr 13 18:30:23 BRT 2015
ca8d19654f32c3823956c0096a5af8c7c4c1949c, 6b7496721f40da659358ca4d287524416d84c2e7, e925ba8defbb04a1c5f8af7860d4501186bbfeb7, Fri Apr 17 20:28:41 BRT 2015
01d5872e52db13e14a8c57e8a15c5aa022411de9, c1798e2d2906064b3befe0cbaf7a3a05a4bea222, ca8d19654f32c3823956c0096a5af8c7c4c1949c, Fri Apr 17 22:44:50 BRT 2015
58ac2224a78c85d2cce6097268a8adaa46171a44, 8ce7f2b625af487073231b9982589bf23ecc1d73, 01d5872e52db13e14a8c57e8a15c5aa022411de9, Mon Apr 20 16:38:34 BRT 2015
c8851c2723ad654a6e46ba09aba0435b8255b84e, 43e0e102a5901f5c3d3739ed8d3d1e6c52b3f781, 248efeeff0842991b74e1a96367c7ad6c8fd1e2a, Tue Apr 28 22:08:50 BRT 2015
482034cb6d3472df80039671a4c01615ffbf4bfd, a0f1e318acec21f0766af75064b6a261fbbe0d0b, 8f0ce23d82184449a67d60eb5d3a97447c2acddf, Mon May 11 14:40:45 BRT 2015
99bde08e241b505c83841a7c6cbdb34e15f0d01f, 2e36995337b35b9f25fe95697d25b8479a1655b6, c7cd9cb3d2df52c07755a3b8e2e4e533ec542989, Tue Jun 02 15:55:27 BRT 2015
9ba23d813b65c952e285eca4e79e73011df48a99, 6b3f46a4276d73e4459d59d30b60f47b6889a419, 99bde08e241b505c83841a7c6cbdb34e15f0d01f, Tue Jun 02 16:00:13 BRT 2015
42d77653be0a2387631470d3856de3e70ca89429, 75a34d164e4e9eba496087f5134bcb96accd4b48, 9ba23d813b65c952e285eca4e79e73011df48a99, Tue Jun 02 18:49:36 BRT 2015
0d1c473a28f5cb15a68191ce26b5c5650e237d2b, 940f53077f756af5c232a04076fc9cad59046c9d, 42d77653be0a2387631470d3856de3e70ca89429, Wed Jun 03 18:15:11 BRT 2015
9ec53d260ac57f479fc74d883e3a477322a325e8, 30b3d163e054b35797fb12f8d24231b4264742b5, 04ea743936d1fd1a4e0555295418b3148c834a74, Wed Jun 17 13:30:39 BRT 2015
09b3b844fd299ffe260e5ad47526ca9c56498e74, 72096c99b3fcbb4f659a34f47d869091f4538b72, ca64992cf428932800e086a627e42a32b76095a1, Mon Jul 13 15:28:43 BRT 2015
d3f9d13904b88d3ef56ab92d3d2d0c583514e4c9, 36418de8746637660fcb587691bcea07254bd200, 7ebd55fa100ebb7f6023c9b7f60f069106b01d45, Wed Jul 29 21:38:38 BRT 2015
acc11a228f2bb8979b7a7e160d621af309f4a0ce, 5b6d82f9adcbb25e3ee4c3392936ab53929693a4, d3f9d13904b88d3ef56ab92d3d2d0c583514e4c9, Thu Jul 30 13:19:10 BRT 2015
e898419d0f29f7260aca3623b3b11bead767fc63, 04ad420f594bedd8cd5c40160d67585f70686a9c, b4fc081aee9ceb9ba94060efbe41b6de4161b4d6, Fri Jul 31 17:47:42 BRT 2015
00837d5c4b101fedaff22da6b56062921b7addd0, 9ad205588102d65c1c139dea244f4b4137f739dc, e898419d0f29f7260aca3623b3b11bead767fc63, Fri Jul 31 21:42:35 BRT 2015
238f6a0e6278f86e9347774d5ff164babb7800bf, 05f009f7a3b28f74c66a4ddc6055aaf570e54a1a, 70c81c62c6f4238ca3105002151dff5d78652786, Wed Aug 05 19:07:24 BRT 2015
d13567d3d2a2bf672af00337fbadf3f4aed3f879, 59b06ae9b15e013153d53c1d9047c564455e9144, 6f22effec4337edab75fdbe5cde0ed81d2e6d5fd, Mon Aug 10 16:51:03 BRT 2015
a190ac3a97a0b2cbdc0a9fab9a4c9a5ad97670de, 14a06c52474999e4ef1775d803cf6c3e8eb5410d, d13567d3d2a2bf672af00337fbadf3f4aed3f879, Tue Aug 11 16:10:49 BRT 2015
5289280d8c8e7000d450c4f1ae3e3193dfb0d14f, fcbae65716a5006d4adee83eeafe35ed48ef1278, a190ac3a97a0b2cbdc0a9fab9a4c9a5ad97670de, Wed Aug 12 14:11:43 BRT 2015
e84962e58f052ac1e8e46424c85431583dbe4d3b, cafd19255d2b1540347207136ce4a8040af08246, 6e0d6e1a00d573040af6ced97cf22543968524ee, Sat Aug 29 10:33:48 BRT 2015
55540f8697e401c52baf287fa7c2b9d9193e4e50, 68791fb923662d798b2a9370c3d3796135b94114, cafd19255d2b1540347207136ce4a8040af08246, Mon Aug 31 15:41:45 BRT 2015
3c42afd5a1677259ce77ee4e49ecae0657cec63a, 1c1f8020b6c17631d05ffa40a3009cec276f1196, 38ffbdb2fc8cc9ae0b9ab50f03eba7d27a9fac89, Tue Sep 01 14:50:11 BRT 2015
0475b7ad99400acec4d9123962200b68002b8a29, b50e223fb634e0f685fe32e4659c4742caac3f6b, 3c42afd5a1677259ce77ee4e49ecae0657cec63a, Thu Sep 03 20:20:42 BRT 2015
d0a83ded38a3b9f13385f8e243194e1908453cb6, d300a0a89988c86686d4c28ff3b63aacc25a2124, 4ee6a6518887fb7adb0388e6cc3d9f79a7768a69, Wed Oct 07 13:30:36 BRT 2015
5fe96e6d0072990c8c9c33cf28251be4f73d1628, 8e8608976fb05adf5d97c1b0a6450041737a5081, bb9e0be441afb5658f0edbbd19bcf27e2fac4105, Wed Oct 14 15:08:39 BRT 2015
e210112824d698402f14f52c6939793a9e204911, 973eb4b6dbcc4680fa0e2d667d873777e4959d93, dd74a38c414c63306679e5d67152932be4c8f145, Tue Oct 20 14:52:05 BRT 2015
432000747ed90ed0a644ed1c24cfc3b04a0562c6, dc26048f87ec9db72c8aa7af44dacf63ee543b60, 83b94cf5bff779fa979a9809e577e7a15635fe55, Thu Nov 19 17:08:52 BRT 2015
a0e906122cef23c3620ef2f9f3fb777c4c17bf69, df98496a9afb95e0a8526cf9ba476ad01d20524f, 028dabab3bb44557e0e9509521a72fd451b6cc28, Mon Nov 30 20:12:16 BRT 2015
cc755dd39df8bc8406bcd8c0203220ed63e0b0b1, bec61e4539d0bd6660a0b43823221b7fc340b0b4, a0e906122cef23c3620ef2f9f3fb777c4c17bf69, Mon Nov 30 20:12:44 BRT 2015
d80cb559303168894f14b1455715831dce884026, e81820d56dc7ad2e178cad75b85334cc7fdcf00a, 8e89db00da117b0114e7fa56fd10da6b97e6c8ba, Tue Dec 08 19:13:49 BRT 2015
65a29c83a4f2d336cefaa2b3615f9d425565369b, fb8920de1e501f4eebeafd3ad04e2600747a4f74, 15d2fdcc200885cf2d7e0fee368c757e6039bafa, Fri Dec 11 15:28:45 BRT 2015
b433c97d1bc2e4c1db68384cd5c9ff5ad89fc09a, 391245d3d31737e6bcc1e6ac1e7e486c78561014, 65a29c83a4f2d336cefaa2b3615f9d425565369b, Fri Dec 11 15:32:06 BRT 2015
a0294bdcd74eedf021e7cdb70addf46ae6056d9d, 3464dc59de50b17fcdf883dcfc9ef30cfa6c8877, b433c97d1bc2e4c1db68384cd5c9ff5ad89fc09a, Mon Dec 14 17:01:46 BRT 2015
ead5459648b237a60a67ef87d7e11f2e77d288af, c99559b7c92422aca8a5e718ee57e46fb6433c2c, 0d08bc14a249c071fb30b93b3294ee6d2772774f, Thu Dec 31 18:14:05 BRT 2015
747c50c1312fde969a8434465f5afb0ed135b282, 4f391bccd4fabc8478c39866c5583716a7dc8ef4, ead5459648b237a60a67ef87d7e11f2e77d288af, Sun Jan 03 18:35:42 BRT 2016
42d2587360a3ccefc0f082c9d7ef3b4b9ead793c, f4c90ece32e3a6d15b1e6e028188f9701bf90494, fa4d0f73cd2bee11117c6baec9d492a0ac51207d, Thu Jan 07 15:12:09 BRT 2016
3cb271c1e9849365329f9812310890d2070a3436, 1613bc438d87e914c5e396b8b23a97bceb1eaca0, 42d2587360a3ccefc0f082c9d7ef3b4b9ead793c, Mon Jan 11 16:15:50 BRT 2016
f7ce7e9221b5ad04e5eb648c872e50977eeeb650, 7d2492758cffde2f790746ca2976f61e1f28d9fc, 3cb271c1e9849365329f9812310890d2070a3436, Mon Jan 11 16:48:52 BRT 2016
110c968c34e65bc904b487d95d990beb352fb549, aad7d48694a0fab5bc68098717c293eb5714ff67, f7ce7e9221b5ad04e5eb648c872e50977eeeb650, Mon Jan 11 19:16:42 BRT 2016
fdbff1d42a73081035fa7b0f172b9b5c30edf41f, b115a8058364a5ba33e063b2fee64a9a0a9239cd, 110c968c34e65bc904b487d95d990beb352fb549, Mon Jan 11 19:55:28 BRT 2016
a46c59e724460c354bfb26dc8485ccfce5faf106, 1d39b273049db7612293013c6fe9152f780b90c1, 42d2587360a3ccefc0f082c9d7ef3b4b9ead793c, Wed Jan 13 11:22:55 BRT 2016
c422977d8cfa2e6f650b26182faa8592e6c287dd, 69864852f6868eb0ee71d17a49379e9448412036, 8401b94d964eeac11f4d3fea06128cbf6caf59d0, Wed Jan 20 18:54:43 BRT 2016
5b46c45e6f3701853e65c4dfb5c3dca9ef90f30f, 6a037afb1797659b06bffa4db6e658d98b289f77, c422977d8cfa2e6f650b26182faa8592e6c287dd, Thu Jan 21 14:42:01 BRT 2016
a70fadbad47a1fa4e6c836a23f4b2be94d2f09d0, 1069d4f0b8d30ff3a07ed505321ee0d2ded3a569, dcbec074f4f5bc6bb2928b066a296e8227f52368, Fri Jan 22 14:33:43 BRT 2016
6638de12881c0d553d9b47b6ad33c1c16f552ab4, 6a6fcb3cbbca072e69b99bb3e17e31739cce964f, a70fadbad47a1fa4e6c836a23f4b2be94d2f09d0, Fri Jan 22 14:34:36 BRT 2016
9403ad7ec27a075fbdffbaf2d30d3dce29a15d82, e60f737cd180b09febed315ad6c2e72c31a5bc49, 6638de12881c0d553d9b47b6ad33c1c16f552ab4, Fri Jan 22 15:09:54 BRT 2016
5d52b926f69a7488b64d77651ad850da17ef02ac, 9403ad7ec27a075fbdffbaf2d30d3dce29a15d82, 3f60b0a2a04174a9b580fab1cd757fbcd1fba85d, Wed Jan 27 19:41:24 BRT 2016
3facb6416a9892b6dcb9e39d7a480e22c7f4ab48, 5d52b926f69a7488b64d77651ad850da17ef02ac, 74c1e9bd4a847ac2559e0de7a846468c2e0fcbb9, Fri Jan 29 15:45:53 BRT 2016
3a7c4cc660b80ee75046bb98c1edb90b26ad5138, 8612a002d3b9fa5b76ab7554e174f506bc9736f0, 3facb6416a9892b6dcb9e39d7a480e22c7f4ab48, Mon Feb 01 15:17:23 BRT 2016
909d2a2cd8816dd48b15a2e79a8f0dfb65cd2356, 21c604f77ab337615d4da9a4e38733b7df98bd75, 3a7c4cc660b80ee75046bb98c1edb90b26ad5138, Fri Feb 05 18:16:08 BRT 2016
d2b52eb2c7906d1e784a484dcd71688e0cfe1543, f9155587db3d13865d03857341832b78e0c9b226, 1b312f8bcf1a232682855b355dd57fb8fab5db3d, Wed Feb 24 14:39:41 BRT 2016
f982142a5d61fedee30e788bcf921d6e246576b5, 7aeb8cca985652ae980367b4ce59bd5d6db327e9, e17e60c2e12440fa871834ff3d9695d56bb02e86, Tue Mar 08 14:12:15 BRT 2016
a52f46f3a86fea176d6d6845261414a483df9db3, d4a70bb4729aad5478def47067cff3de1f428f85, f12f53e38b09cbbb0c3fe58defa1f79ca747d8eb, Wed Mar 09 15:14:59 BRT 2016
d88852a9444307a605c95af606c376480ebfa35b, 4b6104fa5f3160d96583cdbbee60c89cd027d7ac, 3bc237cda33f0041d93e25052ef8cef084451abd, Tue Mar 22 13:00:14 BRT 2016
a2567c698a92abf1347885c82634e3b14e436b01, ebe7ee53ea8a4751cb91fc4b05e484e78aa3ab87, d88852a9444307a605c95af606c376480ebfa35b, Tue Mar 22 18:54:19 BRT 2016
2df03d91c571cbf88dfc8a846970ff32244ccc55, 71c8a126e4b13f7037c788fb2d40f56c3feb0142, 2b221c543eb304860474ee007816e8390b54e5fd, Thu Mar 31 17:16:43 BRT 2016
f5154b157568ddf33e71c2b2b68580646a073b58, 61f4a3415524ad567b486aba283ee80a03d2f298, 9e3bc0c2fefcd713ecf099f3233dc20d3c6914ba, Mon Apr 11 18:10:29 BRT 2016
5d1ba89bffef2112aee336866c69df3b4e90f884, fbfd5fd9bb171b1ab5533822c1a201f6d12c6523, 7660f6ad511ecf72388bf2834b967a74e2822a2a, Wed Apr 20 21:55:30 BRT 2016
f667668148d05770b74f1d7a12e05ddfcec50921, 1c3bc7d2c3e4e95de1f85b283b0d7e12c70b54fc, c1d69bf9e004bb8a84112ace3c88d36479e24c5e, Tue May 03 15:12:43 BRT 2016
5f5810a25d49e28bd202fe8e97209356f77171ba, 9efece1adf60deb6c88cbbff6d2a142714505e6e, 46f1ad69aaed7d9001134dcb7a5ac7735c894593, Wed May 04 14:44:50 BRT 2016
ce1de00b97ada9f9e878baeb4119f87967f119a4, a4bf215f5e7f9a70b5451ab393eea0796965d40f, 78f478ef8320ec48bac79128c4d23ae1292335a8, Tue May 10 12:51:36 BRT 2016
cca1ccdb3354a22dbb230bd3aa180e678ae48c9c, cd922314691eaf34557e7724c3ae3bc61e65e288, a49147fdd69043f41e3b35e473bdddd3b19e22e9, Thu May 19 21:05:50 BRT 2016
77f6cd3293fdeff945982ba82f4ed77d0e5c0827, 4530b55b4f83b20f67803e2e40921dc5fd2e3368, cca1ccdb3354a22dbb230bd3aa180e678ae48c9c, Thu May 19 22:24:44 BRT 2016
4a9fe1431178d256c712c081770c35904e46bd52, 990c19dce2485ae54883d54cdd0ffd636cf1798f, d694351979591ed76c8cb0bc7d2d782b8c9881e9, Tue May 31 14:58:15 BRT 2016
7f818412c8d3a64582d37f18faca8865cf3ff59e, 4047754cadfeb091f73672117f54b8d0279020ac, 4a9fe1431178d256c712c081770c35904e46bd52, Tue May 31 17:29:40 BRT 2016
ebdfabf87208d5cbc733b7b020b82dedbf0b8c7a, 6bf46018460057762f6ad3bf2590e9958d56b66e, 8cf9792052dd2ab44b106218347f20f8b0fc3aad, Mon Jun 06 13:16:08 BRT 2016
Merge scenario [1] from a total of [132] merge scenarios

Merge scenario [2] from a total of [132] merge scenarios

Merge scenario [3] from a total of [132] merge scenarios

Merge scenario [4] from a total of [132] merge scenarios

Merge scenario [5] from a total of [132] merge scenarios

Merge scenario [6] from a total of [132] merge scenarios

Merge scenario [7] from a total of [132] merge scenarios

Merge scenario [8] from a total of [132] merge scenarios

Merge scenario [9] from a total of [132] merge scenarios

Merge scenario [10] from a total of [132] merge scenarios

Merge scenario [11] from a total of [132] merge scenarios

Merge scenario [12] from a total of [132] merge scenarios

Merge scenario [13] from a total of [132] merge scenarios

Merge scenario [14] from a total of [132] merge scenarios

Merge scenario [15] from a total of [132] merge scenarios

Merge scenario [16] from a total of [132] merge scenarios

Merge scenario [17] from a total of [132] merge scenarios

Merge scenario [18] from a total of [132] merge scenarios

Merge scenario [19] from a total of [132] merge scenarios

Merge scenario [20] from a total of [132] merge scenarios

Merge scenario [21] from a total of [132] merge scenarios

Merge scenario [22] from a total of [132] merge scenarios

Analyzing merge scenario...
Reseted sucessfully to: HEAD
     [copy] Copying 5415 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_left_30eb6
Checked out and created branch sucessfully: refs/heads/new
     [copy] Copying 5572 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_right_c94e9
Checked out branch sucessfully: refs/heads/master
     [copy] Copying 5572 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_merged_git
The common ancestor is: d18d5954e3fc38653c228ea13550b4c994155329
Reseted sucessfully to: HEAD
     [copy] Copying 5415 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_base_d18d5
Closing git repository...
starting to run the conflicts analyzer on revision /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_30eb6-c94e9.revisions
Found the following features in expression file:
rev_left_30eb6
rev_base_d18d5
rev_right_c94e9
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_left_30eb6/src/main/java/com/amazonaws/http/HttpClientFactory.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_left_30eb6/src/main/java/com/amazonaws/http/HttpClientFactory.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_base_d18d5/src/main/java/com/amazonaws/http/HttpClientFactory.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_base_d18d5/src/main/java/com/amazonaws/http/HttpClientFactory.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_right_c94e9/src/main/java/com/amazonaws/http/HttpClientFactory.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_right_c94e9/src/main/java/com/amazonaws/http/HttpClientFactory.java
[NT -> rev_left_30eb6 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package com.amazonaws.http;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.UnknownHostException{ImportPackage} : ImportDeclaration "import java.net.UnknownHostException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.CertificateException{ImportPackage} : ImportDeclaration "import java.security.cert.CertificateException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.X509Certificate{ImportPackage} : ImportDeclaration "import java.security.cert.X509Certificate;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLContext{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLContext;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLSocket{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLSocket;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.X509TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.X509TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.Header{ImportPackage} : ImportDeclaration "import org.apache.http.Header;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpHost{ImportPackage} : ImportDeclaration "import org.apache.http.HttpHost;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpRequest{ImportPackage} : ImportDeclaration "import org.apache.http.HttpRequest;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpResponse{ImportPackage} : ImportDeclaration "import org.apache.http.HttpResponse;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpStatus{ImportPackage} : ImportDeclaration "import org.apache.http.HttpStatus;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.ProtocolException{ImportPackage} : ImportDeclaration "import org.apache.http.ProtocolException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.AuthScope{ImportPackage} : ImportDeclaration "import org.apache.http.auth.AuthScope;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.NTCredentials{ImportPackage} : ImportDeclaration "import org.apache.http.auth.NTCredentials;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.client.HttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.client.HttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ConnectTimeoutException{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ConnectTimeoutException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.params.ConnRoutePNames{ImportPackage} : ImportDeclaration "import org.apache.http.conn.params.ConnRoutePNames;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.LayeredSchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.LayeredSchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.PlainSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.PlainSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.Scheme{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.Scheme;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeRegistry{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeRegistry;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ssl.SSLSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ssl.SSLSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultHttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultHttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultRedirectStrategy{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultRedirectStrategy;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager{ImportPackage} : ImportDeclaration "import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.BasicHttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.BasicHttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpConnectionParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpConnectionParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpProtocolParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpProtocolParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.protocol.HttpContext{ImportPackage} : ImportDeclaration "import org.apache.http.protocol.HttpContext;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
									[NT -> HttpClientFactory : ClassDeclaration]
										[T -> - : Modifiers "" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
										[T -> HttpClientFactory : Id "HttpClientFactory" compose:Replacement merge: Default]
										[T -> createHttpClient(ClientConfiguration-ClientConfiguration) : MethodDecl "public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, false);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context", e);         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }" compose:Replacement merge: LineBased]
										[NT -> LocationHeaderNotRequiredRedirectStrategy : InnerClassDecl]
											[T -> - : Modifiers "private final" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> LocationHeaderNotRequiredRedirectStrategy : Id "LocationHeaderNotRequiredRedirectStrategy" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends DefaultRedirectStrategy" compose:Replacement merge: SemanticConflict]
											[T -> isRedirected(HttpRequest-HttpRequest-HttpResponse-HttpResponse-HttpContext-HttpContext) : MethodDecl "@Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }" compose:Replacement merge: LineBased]
										[NT -> TrustingSocketFactory : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingSocketFactory : Id "TrustingSocketFactory" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements SchemeSocketFactory, LayeredSchemeSocketFactory" compose:Replacement merge: SemanticConflict]
											[T -> sslcontext : FieldDecl "private SSLContext sslcontext = null;" compose:Replacement merge: SemanticConflict]
											[T -> createSSLContext({FormalParametersInternal}) : MethodDecl "private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage(), e);             }         }" compose:Replacement merge: LineBased]
											[T -> getSSLContext({FormalParametersInternal}) : MethodDecl "private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }" compose:Replacement merge: LineBased]
											[T -> createSocket(HttpParams-HttpParams) : MethodDecl "public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
											[T -> connectSocket(Socket-Socket-InetSocketAddress-InetSocketAddress-InetSocketAddress-InetSocketAddress-HttpParams-HttpParams) : MethodDecl "public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }" compose:Replacement merge: LineBased]
											[T -> isSecure(Socket-Socket) : MethodDecl "public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }" compose:Replacement merge: LineBased]
											[T -> createLayeredSocket(Socket-Socket-String-String-int-int-boolean-boolean) : MethodDecl "public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
										[NT -> TrustingX509TrustManager : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingX509TrustManager : Id "TrustingX509TrustManager" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements X509TrustManager" compose:Replacement merge: SemanticConflict]
											[T -> X509_CERTIFICATES : FieldDecl "private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];" compose:Replacement merge: SemanticConflict]
											[T -> getAcceptedIssuers({FormalParametersInternal}) : MethodDecl "public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }" compose:Replacement merge: LineBased]
											[T -> checkServerTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
											[T -> checkClientTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
										[T -> auto1 : EmptyDecl ";" compose:Replacement merge: Default]
[NT -> rev_base_d18d5 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package com.amazonaws.http;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.UnknownHostException{ImportPackage} : ImportDeclaration "import java.net.UnknownHostException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.CertificateException{ImportPackage} : ImportDeclaration "import java.security.cert.CertificateException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.X509Certificate{ImportPackage} : ImportDeclaration "import java.security.cert.X509Certificate;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLContext{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLContext;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLSocket{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLSocket;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.X509TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.X509TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.Header{ImportPackage} : ImportDeclaration "import org.apache.http.Header;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpHost{ImportPackage} : ImportDeclaration "import org.apache.http.HttpHost;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpRequest{ImportPackage} : ImportDeclaration "import org.apache.http.HttpRequest;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpResponse{ImportPackage} : ImportDeclaration "import org.apache.http.HttpResponse;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpStatus{ImportPackage} : ImportDeclaration "import org.apache.http.HttpStatus;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.ProtocolException{ImportPackage} : ImportDeclaration "import org.apache.http.ProtocolException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.AuthScope{ImportPackage} : ImportDeclaration "import org.apache.http.auth.AuthScope;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.NTCredentials{ImportPackage} : ImportDeclaration "import org.apache.http.auth.NTCredentials;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.client.HttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.client.HttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ConnectTimeoutException{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ConnectTimeoutException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.params.ConnRoutePNames{ImportPackage} : ImportDeclaration "import org.apache.http.conn.params.ConnRoutePNames;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.LayeredSchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.LayeredSchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.PlainSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.PlainSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.Scheme{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.Scheme;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeRegistry{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeRegistry;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ssl.SSLSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ssl.SSLSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultHttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultHttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultRedirectStrategy{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultRedirectStrategy;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager{ImportPackage} : ImportDeclaration "import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.BasicHttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.BasicHttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpConnectionParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpConnectionParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpProtocolParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpProtocolParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.protocol.HttpContext{ImportPackage} : ImportDeclaration "import org.apache.http.protocol.HttpContext;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
									[NT -> HttpClientFactory : ClassDeclaration]
										[T -> - : Modifiers "" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
										[T -> HttpClientFactory : Id "HttpClientFactory" compose:Replacement merge: Default]
										[T -> createHttpClient(ClientConfiguration-ClientConfiguration) : MethodDecl "public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, false);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context");         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }" compose:Replacement merge: LineBased]
										[NT -> LocationHeaderNotRequiredRedirectStrategy : InnerClassDecl]
											[T -> - : Modifiers "private final" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> LocationHeaderNotRequiredRedirectStrategy : Id "LocationHeaderNotRequiredRedirectStrategy" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends DefaultRedirectStrategy" compose:Replacement merge: SemanticConflict]
											[T -> isRedirected(HttpRequest-HttpRequest-HttpResponse-HttpResponse-HttpContext-HttpContext) : MethodDecl "@Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }" compose:Replacement merge: LineBased]
										[NT -> TrustingSocketFactory : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingSocketFactory : Id "TrustingSocketFactory" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements SchemeSocketFactory, LayeredSchemeSocketFactory" compose:Replacement merge: SemanticConflict]
											[T -> sslcontext : FieldDecl "private SSLContext sslcontext = null;" compose:Replacement merge: SemanticConflict]
											[T -> createSSLContext({FormalParametersInternal}) : MethodDecl "private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage());             }         }" compose:Replacement merge: LineBased]
											[T -> getSSLContext({FormalParametersInternal}) : MethodDecl "private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }" compose:Replacement merge: LineBased]
											[T -> createSocket(HttpParams-HttpParams) : MethodDecl "public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
											[T -> connectSocket(Socket-Socket-InetSocketAddress-InetSocketAddress-InetSocketAddress-InetSocketAddress-HttpParams-HttpParams) : MethodDecl "public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }" compose:Replacement merge: LineBased]
											[T -> isSecure(Socket-Socket) : MethodDecl "public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }" compose:Replacement merge: LineBased]
											[T -> createLayeredSocket(Socket-Socket-String-String-int-int-boolean-boolean) : MethodDecl "public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
										[NT -> TrustingX509TrustManager : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingX509TrustManager : Id "TrustingX509TrustManager" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements X509TrustManager" compose:Replacement merge: SemanticConflict]
											[T -> X509_CERTIFICATES : FieldDecl "private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];" compose:Replacement merge: SemanticConflict]
											[T -> getAcceptedIssuers({FormalParametersInternal}) : MethodDecl "public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }" compose:Replacement merge: LineBased]
											[T -> checkServerTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
											[T -> checkClientTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
										[T -> auto2 : EmptyDecl ";" compose:Replacement merge: Default]
[NT -> rev_right_c94e9 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package com.amazonaws.http;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.UnknownHostException{ImportPackage} : ImportDeclaration "import java.net.UnknownHostException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.CertificateException{ImportPackage} : ImportDeclaration "import java.security.cert.CertificateException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.X509Certificate{ImportPackage} : ImportDeclaration "import java.security.cert.X509Certificate;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLContext{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLContext;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLSocket{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLSocket;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.X509TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.X509TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.Header{ImportPackage} : ImportDeclaration "import org.apache.http.Header;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpHost{ImportPackage} : ImportDeclaration "import org.apache.http.HttpHost;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpRequest{ImportPackage} : ImportDeclaration "import org.apache.http.HttpRequest;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpResponse{ImportPackage} : ImportDeclaration "import org.apache.http.HttpResponse;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpStatus{ImportPackage} : ImportDeclaration "import org.apache.http.HttpStatus;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.ProtocolException{ImportPackage} : ImportDeclaration "import org.apache.http.ProtocolException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.AuthScope{ImportPackage} : ImportDeclaration "import org.apache.http.auth.AuthScope;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.NTCredentials{ImportPackage} : ImportDeclaration "import org.apache.http.auth.NTCredentials;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.client.HttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.client.HttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ConnectTimeoutException{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ConnectTimeoutException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.params.ConnRoutePNames{ImportPackage} : ImportDeclaration "import org.apache.http.conn.params.ConnRoutePNames;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.LayeredSchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.LayeredSchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.PlainSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.PlainSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.Scheme{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.Scheme;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeRegistry{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeRegistry;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ssl.SSLSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ssl.SSLSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultHttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultHttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultRedirectStrategy{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultRedirectStrategy;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager{ImportPackage} : ImportDeclaration "import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.BasicHttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.BasicHttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpConnectionParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpConnectionParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpProtocolParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpProtocolParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.protocol.HttpContext{ImportPackage} : ImportDeclaration "import org.apache.http.protocol.HttpContext;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
									[NT -> HttpClientFactory : ClassDeclaration]
										[T -> - : Modifiers "" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
										[T -> HttpClientFactory : Id "HttpClientFactory" compose:Replacement merge: Default]
										[T -> createHttpClient(ClientConfiguration-ClientConfiguration) : MethodDecl "public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, true);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context");         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }" compose:Replacement merge: LineBased]
										[NT -> LocationHeaderNotRequiredRedirectStrategy : InnerClassDecl]
											[T -> - : Modifiers "private final" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> LocationHeaderNotRequiredRedirectStrategy : Id "LocationHeaderNotRequiredRedirectStrategy" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends DefaultRedirectStrategy" compose:Replacement merge: SemanticConflict]
											[T -> isRedirected(HttpRequest-HttpRequest-HttpResponse-HttpResponse-HttpContext-HttpContext) : MethodDecl "@Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }" compose:Replacement merge: LineBased]
										[NT -> TrustingSocketFactory : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingSocketFactory : Id "TrustingSocketFactory" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements SchemeSocketFactory, LayeredSchemeSocketFactory" compose:Replacement merge: SemanticConflict]
											[T -> sslcontext : FieldDecl "private SSLContext sslcontext = null;" compose:Replacement merge: SemanticConflict]
											[T -> createSSLContext({FormalParametersInternal}) : MethodDecl "private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage());             }         }" compose:Replacement merge: LineBased]
											[T -> getSSLContext({FormalParametersInternal}) : MethodDecl "private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }" compose:Replacement merge: LineBased]
											[T -> createSocket(HttpParams-HttpParams) : MethodDecl "public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
											[T -> connectSocket(Socket-Socket-InetSocketAddress-InetSocketAddress-InetSocketAddress-InetSocketAddress-HttpParams-HttpParams) : MethodDecl "public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }" compose:Replacement merge: LineBased]
											[T -> isSecure(Socket-Socket) : MethodDecl "public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }" compose:Replacement merge: LineBased]
											[T -> createLayeredSocket(Socket-Socket-String-String-int-int-boolean-boolean) : MethodDecl "public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }" compose:Replacement merge: LineBased]
										[NT -> TrustingX509TrustManager : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingX509TrustManager : Id "TrustingX509TrustManager" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements X509TrustManager" compose:Replacement merge: SemanticConflict]
											[T -> X509_CERTIFICATES : FieldDecl "private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];" compose:Replacement merge: SemanticConflict]
											[T -> getAcceptedIssuers({FormalParametersInternal}) : MethodDecl "public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }" compose:Replacement merge: LineBased]
											[T -> checkServerTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
											[T -> checkClientTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }" compose:Replacement merge: LineBased]
										[T -> auto3 : EmptyDecl ";" compose:Replacement merge: Default]
Having repository: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/GitBlameRepo/.git
Checked out and created branch sucessfully: refs/heads/left
Checked out branch sucessfully: refs/heads/master
Checked out and created branch sucessfully: refs/heads/right
Checked out branch sucessfully: refs/heads/master
Fast-forward
Merged-not-committed
[NT -> rev_left_30eb6 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package com.amazonaws.http;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: SemanticConflict]
									[T -> java.net.UnknownHostException{ImportPackage} : ImportDeclaration "import java.net.UnknownHostException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.CertificateException{ImportPackage} : ImportDeclaration "import java.security.cert.CertificateException;" compose:Replacement merge: SemanticConflict]
									[T -> java.security.cert.X509Certificate{ImportPackage} : ImportDeclaration "import java.security.cert.X509Certificate;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLContext{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLContext;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.SSLSocket{ImportPackage} : ImportDeclaration "import javax.net.ssl.SSLSocket;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> javax.net.ssl.X509TrustManager{ImportPackage} : ImportDeclaration "import javax.net.ssl.X509TrustManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.Header{ImportPackage} : ImportDeclaration "import org.apache.http.Header;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpHost{ImportPackage} : ImportDeclaration "import org.apache.http.HttpHost;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpRequest{ImportPackage} : ImportDeclaration "import org.apache.http.HttpRequest;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpResponse{ImportPackage} : ImportDeclaration "import org.apache.http.HttpResponse;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.HttpStatus{ImportPackage} : ImportDeclaration "import org.apache.http.HttpStatus;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.ProtocolException{ImportPackage} : ImportDeclaration "import org.apache.http.ProtocolException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.AuthScope{ImportPackage} : ImportDeclaration "import org.apache.http.auth.AuthScope;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.auth.NTCredentials{ImportPackage} : ImportDeclaration "import org.apache.http.auth.NTCredentials;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.client.HttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.client.HttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ConnectTimeoutException{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ConnectTimeoutException;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.params.ConnRoutePNames{ImportPackage} : ImportDeclaration "import org.apache.http.conn.params.ConnRoutePNames;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.LayeredSchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.LayeredSchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.PlainSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.PlainSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.Scheme{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.Scheme;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeRegistry{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeRegistry;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.scheme.SchemeSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.scheme.SchemeSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.conn.ssl.SSLSocketFactory{ImportPackage} : ImportDeclaration "import org.apache.http.conn.ssl.SSLSocketFactory;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultHttpClient{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultHttpClient;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.client.DefaultRedirectStrategy{ImportPackage} : ImportDeclaration "import org.apache.http.impl.client.DefaultRedirectStrategy;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager{ImportPackage} : ImportDeclaration "import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.BasicHttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.BasicHttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpConnectionParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpConnectionParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.params.HttpProtocolParams{ImportPackage} : ImportDeclaration "import org.apache.http.params.HttpProtocolParams;" compose:Replacement merge: SemanticConflict]
									[T -> org.apache.http.protocol.HttpContext{ImportPackage} : ImportDeclaration "import org.apache.http.protocol.HttpContext;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
									[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
									[NT -> HttpClientFactory : ClassDeclaration]
										[T -> - : Modifiers "" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
										[T -> HttpClientFactory : Id "HttpClientFactory" compose:Replacement merge: Default]
										[T -> createHttpClient(ClientConfiguration-ClientConfiguration) : MethodDecl "// START createHttpClient(ClientConfiguration-ClientConfiguration)//public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout()); // RIGHT //        HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, true);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) { // LEFT //            throw new AmazonClientException("Unable to access default SSL context", e);         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient; // END createHttpClient(ClientConfiguration-ClientConfiguration)//    }" compose:Replacement merge: LineBased]
										[NT -> LocationHeaderNotRequiredRedirectStrategy : InnerClassDecl]
											[T -> - : Modifiers "private final" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> LocationHeaderNotRequiredRedirectStrategy : Id "LocationHeaderNotRequiredRedirectStrategy" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends DefaultRedirectStrategy" compose:Replacement merge: SemanticConflict]
											[T -> isRedirected(HttpRequest-HttpRequest-HttpResponse-HttpResponse-HttpContext-HttpContext) : MethodDecl "@Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         } " compose:Replacement merge: LineBased]
										[NT -> TrustingSocketFactory : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingSocketFactory : Id "TrustingSocketFactory" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements SchemeSocketFactory, LayeredSchemeSocketFactory" compose:Replacement merge: SemanticConflict]
											[T -> sslcontext : FieldDecl "private SSLContext sslcontext = null;" compose:Replacement merge: SemanticConflict]
											[T -> createSSLContext({FormalParametersInternal}) : MethodDecl "private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage(), e);             }         } " compose:Replacement merge: LineBased]
											[T -> getSSLContext({FormalParametersInternal}) : MethodDecl "private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         } " compose:Replacement merge: LineBased]
											[T -> createSocket(HttpParams-HttpParams) : MethodDecl "public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         } " compose:Replacement merge: LineBased]
											[T -> connectSocket(Socket-Socket-InetSocketAddress-InetSocketAddress-InetSocketAddress-InetSocketAddress-HttpParams-HttpParams) : MethodDecl "public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         } " compose:Replacement merge: LineBased]
											[T -> isSecure(Socket-Socket) : MethodDecl "public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         } " compose:Replacement merge: LineBased]
											[T -> createLayeredSocket(Socket-Socket-String-String-int-int-boolean-boolean) : MethodDecl "public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         } " compose:Replacement merge: LineBased]
										[NT -> TrustingX509TrustManager : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> TrustingX509TrustManager : Id "TrustingX509TrustManager" compose:Replacement merge: Default]
											[T -> ImplList : ImplementsList "implements X509TrustManager" compose:Replacement merge: SemanticConflict]
											[T -> X509_CERTIFICATES : FieldDecl "private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];" compose:Replacement merge: SemanticConflict]
											[T -> getAcceptedIssuers({FormalParametersInternal}) : MethodDecl "public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         } " compose:Replacement merge: LineBased]
											[T -> checkServerTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         } " compose:Replacement merge: LineBased]
											[T -> checkClientTrusted(X509Certificate[]-X509Certificate[]-String-String) : MethodDecl "public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         } " compose:Replacement merge: LineBased]
										[T -> auto3 : EmptyDecl ";" compose:Replacement merge: Default]
										[T -> auto1 : EmptyDecl ";" compose:Replacement merge: Default]
[NT -> rev_left_30eb6 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java.merge : .java.merge-File]
								[T -> HttpClientFactory.java : .java-Content "/*  * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.http;  import java.io.IOException; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocket; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager;  import org.apache.http.Header; import org.apache.http.HttpHost; import org.apache.http.HttpRequest; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.ProtocolException; import org.apache.http.auth.AuthScope; import org.apache.http.auth.NTCredentials; import org.apache.http.client.HttpClient; import org.apache.http.conn.ConnectTimeoutException; import org.apache.http.conn.params.ConnRoutePNames; import org.apache.http.conn.scheme.LayeredSchemeSocketFactory; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.scheme.SchemeSocketFactory; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.client.DefaultRedirectStrategy; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HttpContext;  import com.amazonaws.AmazonClientException; import com.amazonaws.ClientConfiguration;  /** Responsible for creating and configuring instances of Apache HttpClient4. */ class HttpClientFactory {      /**      * Creates a new HttpClient object using the specified AWS      * ClientConfiguration to configure the client.      *      * @param config      *            Client configuration options (ex: proxy settings, connection      *            limits, etc).      *      * @return The new, configured HttpClient.      */     public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, false);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context", e);         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }      /**      * Customization of the default redirect strategy provided by HttpClient to be a little      * less strict about the Location header to account for S3 not sending the Location      * header with 301 responses.      */     private final class LocationHeaderNotRequiredRedirectStrategy extends DefaultRedirectStrategy {         @Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }     }      /**      * Simple implementation of SchemeSocketFactory (and      * LayeredSchemeSocketFactory) that bypasses SSL certificate checks. This      * class is only intended to be used for testing purposes.      */     private static class TrustingSocketFactory implements SchemeSocketFactory, LayeredSchemeSocketFactory {          private SSLContext sslcontext = null;          private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage(), e);             }         }          private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }          public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }          public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }          public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }          public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }     }      /**      * Simple implementation of X509TrustManager that trusts all certificates.      * This class is only intended to be used for testing purposes.      */     private static class TrustingX509TrustManager implements X509TrustManager {         private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];          public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }          public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }          public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }     }; } " compose:StringConcatenation merge: LineBased]
[NT -> rev_base_d18d5 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java.merge : .java.merge-File]
								[T -> HttpClientFactory.java : .java-Content "/*  * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.http;  import java.io.IOException; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocket; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager;  import org.apache.http.Header; import org.apache.http.HttpHost; import org.apache.http.HttpRequest; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.ProtocolException; import org.apache.http.auth.AuthScope; import org.apache.http.auth.NTCredentials; import org.apache.http.client.HttpClient; import org.apache.http.conn.ConnectTimeoutException; import org.apache.http.conn.params.ConnRoutePNames; import org.apache.http.conn.scheme.LayeredSchemeSocketFactory; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.scheme.SchemeSocketFactory; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.client.DefaultRedirectStrategy; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HttpContext;  import com.amazonaws.AmazonClientException; import com.amazonaws.ClientConfiguration;  /** Responsible for creating and configuring instances of Apache HttpClient4. */ class HttpClientFactory {      /**      * Creates a new HttpClient object using the specified AWS      * ClientConfiguration to configure the client.      *      * @param config      *            Client configuration options (ex: proxy settings, connection      *            limits, etc).      *      * @return The new, configured HttpClient.      */     public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, false);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context");         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }      /**      * Customization of the default redirect strategy provided by HttpClient to be a little      * less strict about the Location header to account for S3 not sending the Location      * header with 301 responses.      */     private final class LocationHeaderNotRequiredRedirectStrategy extends DefaultRedirectStrategy {         @Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }     }      /**      * Simple implementation of SchemeSocketFactory (and      * LayeredSchemeSocketFactory) that bypasses SSL certificate checks. This      * class is only intended to be used for testing purposes.      */     private static class TrustingSocketFactory implements SchemeSocketFactory, LayeredSchemeSocketFactory {          private SSLContext sslcontext = null;          private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage());             }         }          private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }          public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }          public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }          public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }          public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }     }      /**      * Simple implementation of X509TrustManager that trusts all certificates.      * This class is only intended to be used for testing purposes.      */     private static class TrustingX509TrustManager implements X509TrustManager {         private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];          public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }          public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }          public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }     }; } " compose:StringConcatenation merge: LineBased]
[NT -> rev_right_c94e9 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java.merge : .java.merge-File]
								[T -> HttpClientFactory.java : .java-Content "/*  * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.http;  import java.io.IOException; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocket; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager;  import org.apache.http.Header; import org.apache.http.HttpHost; import org.apache.http.HttpRequest; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.ProtocolException; import org.apache.http.auth.AuthScope; import org.apache.http.auth.NTCredentials; import org.apache.http.client.HttpClient; import org.apache.http.conn.ConnectTimeoutException; import org.apache.http.conn.params.ConnRoutePNames; import org.apache.http.conn.scheme.LayeredSchemeSocketFactory; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.scheme.SchemeSocketFactory; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.client.DefaultRedirectStrategy; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HttpContext;  import com.amazonaws.AmazonClientException; import com.amazonaws.ClientConfiguration;  /** Responsible for creating and configuring instances of Apache HttpClient4. */ class HttpClientFactory {      /**      * Creates a new HttpClient object using the specified AWS      * ClientConfiguration to configure the client.      *      * @param config      *            Client configuration options (ex: proxy settings, connection      *            limits, etc).      *      * @return The new, configured HttpClient.      */     public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, true);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context");         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }      /**      * Customization of the default redirect strategy provided by HttpClient to be a little      * less strict about the Location header to account for S3 not sending the Location      * header with 301 responses.      */     private final class LocationHeaderNotRequiredRedirectStrategy extends DefaultRedirectStrategy {         @Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }     }      /**      * Simple implementation of SchemeSocketFactory (and      * LayeredSchemeSocketFactory) that bypasses SSL certificate checks. This      * class is only intended to be used for testing purposes.      */     private static class TrustingSocketFactory implements SchemeSocketFactory, LayeredSchemeSocketFactory {          private SSLContext sslcontext = null;          private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage());             }         }          private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }          public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }          public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }          public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }          public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }     }      /**      * Simple implementation of X509TrustManager that trusts all certificates.      * This class is only intended to be used for testing purposes.      */     private static class TrustingX509TrustManager implements X509TrustManager {         private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];          public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }          public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }          public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }     }; } " compose:StringConcatenation merge: LineBased]
[NT -> rev_left_30eb6 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> http : Folder]
							[NT -> HttpClientFactory.java.merge : .java.merge-File]
								[T -> HttpClientFactory.java : .java-Content "/*  * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.http;  import java.io.IOException; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocket; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager;  import org.apache.http.Header; import org.apache.http.HttpHost; import org.apache.http.HttpRequest; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.ProtocolException; import org.apache.http.auth.AuthScope; import org.apache.http.auth.NTCredentials; import org.apache.http.client.HttpClient; import org.apache.http.conn.ConnectTimeoutException; import org.apache.http.conn.params.ConnRoutePNames; import org.apache.http.conn.scheme.LayeredSchemeSocketFactory; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.scheme.SchemeSocketFactory; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.client.DefaultRedirectStrategy; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HttpContext;  import com.amazonaws.AmazonClientException; import com.amazonaws.ClientConfiguration;  /** Responsible for creating and configuring instances of Apache HttpClient4. */ class HttpClientFactory {      /**      * Creates a new HttpClient object using the specified AWS      * ClientConfiguration to configure the client.      *      * @param config      *            Client configuration options (ex: proxy settings, connection      *            limits, etc).      *      * @return The new, configured HttpClient.      */     public HttpClient createHttpClient(ClientConfiguration config) {         /* Form User-Agent information */         String userAgent = config.getUserAgent();         if (!(userAgent.equals(ClientConfiguration.DEFAULT_USER_AGENT))) {             userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;         }          /* Set HTTP client parameters */         HttpParams httpClientParams = new BasicHttpParams();         HttpProtocolParams.setUserAgent(httpClientParams, userAgent);         HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());         HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());         HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, true);         HttpConnectionParams.setTcpNoDelay(httpClientParams, true);          int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];         int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];         if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {             HttpConnectionParams.setSocketBufferSize(httpClientParams,                     Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));         }          /* Set connection manager */         ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory.createThreadSafeClientConnManager(config, httpClientParams);         DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager, httpClientParams);         httpClient.setRedirectStrategy(new LocationHeaderNotRequiredRedirectStrategy());          try {             Scheme http = new Scheme("http", 80, PlainSocketFactory.getSocketFactory());              SSLSocketFactory sf = new SSLSocketFactory(                     SSLContext.getDefault(),                     SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);             Scheme https = new Scheme("https", 443, sf);              SchemeRegistry sr = connectionManager.getSchemeRegistry();             sr.register(http);             sr.register(https);         } catch (NoSuchAlgorithmException e) {             throw new AmazonClientException("Unable to access default SSL context", e);         }          /*          * If SSL cert checking for endpoints has been explicitly disabled,          * register a new scheme for HTTPS that won't cause self-signed certs to          * error out.          */         if (System.getProperty("com.amazonaws.sdk.disableCertChecking") != null) {             Scheme sch = new Scheme("https", 443, new TrustingSocketFactory());             httpClient.getConnectionManager().getSchemeRegistry().register(sch);         }          /* Set proxy if configured */         String proxyHost = config.getProxyHost();         int proxyPort = config.getProxyPort();         if (proxyHost != null && proxyPort > 0) {             AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " " + "Proxy Port: " + proxyPort);             HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);             httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);              String proxyUsername    = config.getProxyUsername();             String proxyPassword    = config.getProxyPassword();             String proxyDomain      = config.getProxyDomain();             String proxyWorkstation = config.getProxyWorkstation();              if (proxyUsername != null && proxyPassword != null) {                 httpClient.getCredentialsProvider().setCredentials(                         new AuthScope(proxyHost, proxyPort),                         new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation, proxyDomain));             }         }          return httpClient;     }      /**      * Customization of the default redirect strategy provided by HttpClient to be a little      * less strict about the Location header to account for S3 not sending the Location      * header with 301 responses.      */     private final class LocationHeaderNotRequiredRedirectStrategy extends DefaultRedirectStrategy {         @Override         public boolean isRedirected(HttpRequest request,                 HttpResponse response, HttpContext context) throws ProtocolException {             int statusCode = response.getStatusLine().getStatusCode();             Header locationHeader = response.getFirstHeader("location");              // Instead of throwing a ProtocolException in this case, just             // return false to indicate that this is not redirected             if (locationHeader == null &&                 statusCode == HttpStatus.SC_MOVED_PERMANENTLY) return false;              return super.isRedirected(request, response, context);         }     }      /**      * Simple implementation of SchemeSocketFactory (and      * LayeredSchemeSocketFactory) that bypasses SSL certificate checks. This      * class is only intended to be used for testing purposes.      */     private static class TrustingSocketFactory implements SchemeSocketFactory, LayeredSchemeSocketFactory {          private SSLContext sslcontext = null;          private static SSLContext createSSLContext() throws IOException {             try {                 SSLContext context = SSLContext.getInstance("TLS");                 context.init(null, new TrustManager[] { new TrustingX509TrustManager() }, null);                 return context;             } catch (Exception e) {                 throw new IOException(e.getMessage(), e);             }         }          private SSLContext getSSLContext() throws IOException {             if (this.sslcontext == null) this.sslcontext = createSSLContext();             return this.sslcontext;         }          public Socket createSocket(HttpParams params) throws IOException {             return getSSLContext().getSocketFactory().createSocket();         }          public Socket connectSocket(Socket sock,                 InetSocketAddress remoteAddress,                 InetSocketAddress localAddress, HttpParams params)                 throws IOException, UnknownHostException,                 ConnectTimeoutException {             int connTimeout = HttpConnectionParams.getConnectionTimeout(params);             int soTimeout = HttpConnectionParams.getSoTimeout(params);              SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket(params));             if (localAddress != null) sslsock.bind(localAddress);              sslsock.connect(remoteAddress, connTimeout);             sslsock.setSoTimeout(soTimeout);             return sslsock;         }          public boolean isSecure(Socket sock) throws IllegalArgumentException {             return true;         }          public Socket createLayeredSocket(Socket arg0, String arg1, int arg2, boolean arg3)                 throws IOException, UnknownHostException {             return getSSLContext().getSocketFactory().createSocket();         }     }      /**      * Simple implementation of X509TrustManager that trusts all certificates.      * This class is only intended to be used for testing purposes.      */     private static class TrustingX509TrustManager implements X509TrustManager {         private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];          public X509Certificate[] getAcceptedIssuers() {             return X509_CERTIFICATES;         }          public void checkServerTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }          public void checkClientTrusted(X509Certificate[] chain, String authType)                 throws CertificateException {             // No-op, to trust all certs         }     }; } " compose:StringConcatenation merge: LineBased]
Merge scenario /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_30eb6-c94e9.revisions deleted!
false
22, [/home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_30eb6_c94e9/rev_30eb6-c94e9/src/main/java/com/amazonaws/http/HttpClientFactory.java]
Merge scenario [23] from a total of [132] merge scenarios

Merge scenario [24] from a total of [132] merge scenarios

Merge scenario [25] from a total of [132] merge scenarios

Merge scenario [26] from a total of [132] merge scenarios

Merge scenario [27] from a total of [132] merge scenarios

Merge scenario [28] from a total of [132] merge scenarios

Merge scenario [29] from a total of [132] merge scenarios

Merge scenario [30] from a total of [132] merge scenarios

Merge scenario [31] from a total of [132] merge scenarios

Merge scenario [32] from a total of [132] merge scenarios

Merge scenario [33] from a total of [132] merge scenarios

Merge scenario [34] from a total of [132] merge scenarios

Merge scenario [35] from a total of [132] merge scenarios

Merge scenario [36] from a total of [132] merge scenarios

Merge scenario [37] from a total of [132] merge scenarios

Merge scenario [38] from a total of [132] merge scenarios

Merge scenario [39] from a total of [132] merge scenarios

Merge scenario [40] from a total of [132] merge scenarios

Merge scenario [41] from a total of [132] merge scenarios

Merge scenario [42] from a total of [132] merge scenarios

Merge scenario [43] from a total of [132] merge scenarios

Merge scenario [44] from a total of [132] merge scenarios

Analyzing merge scenario...
Reseted sucessfully to: HEAD
     [copy] Copying 6927 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_left_7ab10
Checked out and created branch sucessfully: refs/heads/new
     [copy] Copying 6933 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_right_257dd
Checked out branch sucessfully: refs/heads/master
     [copy] Copying 6933 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_merged_git
The common ancestor is: f9d6352a4c3f376202b8951e30b319794ad3e2be
Reseted sucessfully to: HEAD
     [copy] Copying 6927 files to /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_base_f9d63
Closing git repository...
starting to run the conflicts analyzer on revision /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_7ab10-257dd.revisions
Found the following features in expression file:
rev_left_7ab10
rev_base_f9d63
rev_right_257dd
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_left_7ab10/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_left_7ab10/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_base_f9d63/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_base_f9d63/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_right_257dd/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
processing: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_right_257dd/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java
[NT -> rev_left_7ab10 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.amazonaws.services.s3;" compose:Replacement merge: Default]
										[T -> com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.FileNotFoundException{ImportPackage} : ImportDeclaration "import java.io.FileNotFoundException;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URISyntaxException{ImportPackage} : ImportDeclaration "import java.net.URISyntaxException;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.MessageDigest{ImportPackage} : ImportDeclaration "import java.security.MessageDigest;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.LinkedList{ImportPackage} : ImportDeclaration "import java.util.LinkedList;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map.Entry{ImportPackage} : ImportDeclaration "import java.util.Map.Entry;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.regex.Matcher{ImportPackage} : ImportDeclaration "import java.util.regex.Matcher;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.Log{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.Log;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.LogFactory{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.LogFactory;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.http.client.methods.HttpRequestBase{ImportPackage} : ImportDeclaration "import org.apache.http.client.methods.HttpRequestBase;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AbortedException{ImportPackage} : ImportDeclaration "import com.amazonaws.AbortedException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException.ErrorType{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException.ErrorType;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceClient{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceClient;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.DefaultRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.DefaultRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.HttpMethod{ImportPackage} : ImportDeclaration "import com.amazonaws.HttpMethod;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Request{ImportPackage} : ImportDeclaration "import com.amazonaws.Request;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Response{ImportPackage} : ImportDeclaration "import com.amazonaws.Response;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.SDKGlobalConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.SDKGlobalConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentials{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentials;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.DefaultAWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.EnvironmentVariableCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.InstanceProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.InstanceProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Presigner{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Presigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SignerFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SignerFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SystemPropertiesCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SystemPropertiesCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.profile.ProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.profile.ProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressEvent{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressEvent;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListener{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListener;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListenerCallbackExecutor{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListenerCallbackExecutor;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressReportingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressReportingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.HandlerChainFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.HandlerChainFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.RequestHandler2{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.RequestHandler2;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.http.ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpMethodName{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpMethodName;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.internal.StaticCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.internal.StaticCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.AwsSdkMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.AwsSdkMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.RequestMetricCollector{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.RequestMetricCollector;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.regions.RegionUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.regions.RegionUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.AWSS3V4Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.AWSS3V4Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.BucketNameUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.BucketNameUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Constants{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Constants;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DeleteObjectsResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DeleteObjectsResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DigestValidationInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DigestValidationInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.InputSubstream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.InputSubstream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Mimetypes{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Mimetypes;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableFileInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableFileInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ErrorResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ErrorResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3MetadataResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3MetadataResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ObjectResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ObjectResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3QueryStringSigner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3QueryStringSigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3StringResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3StringResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3VersionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3VersionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3XmlResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3XmlResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServiceUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServiceUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.XmlWriter{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.XmlWriter;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.metrics.S3ServiceMetric{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.metrics.S3ServiceMetric;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AbortMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AmazonS3Exception{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AmazonS3Exception;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Bucket{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Bucket;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketCrossOriginConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLifecycleConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLifecycleConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLoggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLoggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketNotificationConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketNotificationConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketPolicy{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketPolicy;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketTaggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketTaggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketVersioningConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketVersioningConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketWebsiteConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketWebsiteConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CannedAccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CannedAccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CreateBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CreateBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteVersionRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteVersionRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GeneratePresignedUrlRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GenericBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GenericBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketLocationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketLocationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectMetadataRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectMetadataRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grant{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grant;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GroupGrantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GroupGrantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.HeadBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.HeadBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListBucketsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListBucketsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListMultipartUploadsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListMultipartUploadsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListPartsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListPartsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListVersionsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListVersionsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiFactorAuthentication{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiFactorAuthentication;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiObjectDeleteException{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiObjectDeleteException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultipartUploadListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultipartUploadListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectMetadata{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectMetadata;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Owner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Owner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PartListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PartListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Permission{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Permission;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Region{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Region;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ResponseHeaderOverrides{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ResponseHeaderOverrides;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RestoreObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RestoreObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3Object{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3Object;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3ObjectInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3ObjectInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SSECustomerKey{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SSECustomerKey;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.StorageClass{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.StorageClass;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.VersionListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.VersionListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.AclXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.AclXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.Unmarshallers{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.Unmarshallers;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.transform.Unmarshaller{ImportPackage} : ImportDeclaration "import com.amazonaws.transform.Unmarshaller;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics.Field{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics.Field;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Base64{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Base64;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.BinaryUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.BinaryUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.DateUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.DateUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.HttpUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.HttpUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.LengthCheckInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Md5Utils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Md5Utils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.ServiceClientHolderInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.ServiceClientHolderInputStream;" compose:Replacement merge: SemanticConflict]
										[NT -> AmazonS3Client : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client : Id "AmazonS3Client" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AmazonWebServiceClient" compose:Replacement merge: SemanticConflict]
											[T -> ImplList : ImplementsList "implements AmazonS3" compose:Replacement merge: SemanticConflict]
											[T -> S3_SERVICE_NAME : FieldDecl "public static final String S3_SERVICE_NAME = "s3";" compose:Replacement merge: SemanticConflict]
											[T -> S3_SIGNER : FieldDecl "private static final String S3_SIGNER = "S3SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> S3_V4_SIGNER : FieldDecl "private static final String S3_V4_SIGNER = "AWSS3V4SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> log : FieldDecl "private static Log log = LogFactory.getLog(AmazonS3Client.class);" compose:Replacement merge: SemanticConflict]
											[T -> auto4 : InitializerDecl "static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }" compose:Replacement merge: Default]
											[T -> errorResponseHandler : FieldDecl "private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();" compose:Replacement merge: SemanticConflict]
											[T -> voidResponseHandler : FieldDecl "private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);" compose:Replacement merge: SemanticConflict]
											[T -> bucketConfigurationXmlFactory : FieldDecl "private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> requestPaymentConfigurationXmlFactory : FieldDecl "private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> clientOptions : FieldDecl "private S3ClientOptions clientOptions = new S3ClientOptions();" compose:Replacement merge: SemanticConflict]
											[T -> awsCredentialsProvider : FieldDecl "private AWSCredentialsProvider awsCredentialsProvider;" compose:Replacement merge: SemanticConflict]
											[T -> hasExplicitRegion : FieldDecl "private boolean hasExplicitRegion;" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client({FormalParametersInternal}) : ConstructorDecl "public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration-RequestMetricCollector-RequestMetricCollector) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }" compose:Replacement merge: LineBased]
											[T -> init({FormalParametersInternal}) : MethodDecl "private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }" compose:Replacement merge: LineBased]
											[T -> setEndpoint(String-String) : MethodDecl "@Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }" compose:Replacement merge: LineBased]
											[T -> setRegion(com.amazonaws.regions.Region-com.amazonaws.regions.Region) : MethodDecl "@Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }" compose:Replacement merge: LineBased]
											[T -> setS3ClientOptions(S3ClientOptions-S3ClientOptions) : MethodDecl "public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfVersions(VersionListing-VersionListing) : MethodDecl "public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String-String-String-String-String-String-String-Integer-Integer) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }" compose:Replacement merge: LineBased]
											[T -> listVersions(ListVersionsRequest-ListVersionsRequest) : MethodDecl "public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String) : MethodDecl "public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String-String-String) : MethodDecl "public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(ListObjectsRequest-ListObjectsRequest) : MethodDecl "public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfObjects(ObjectListing-ObjectListing) : MethodDecl "public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> getS3AccountOwner({FormalParametersInternal}) : MethodDecl "public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets(ListBucketsRequest-ListBucketsRequest) : MethodDecl "public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets({FormalParametersInternal}) : MethodDecl "public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(GetBucketLocationRequest-GetBucketLocationRequest) : MethodDecl "public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(String-String) : MethodDecl "public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String) : MethodDecl "public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-Region-Region) : MethodDecl "public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-String-String) : MethodDecl "public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(CreateBucketRequest-CreateBucketRequest) : MethodDecl "public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(String-String) : MethodDecl "public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(GetBucketAclRequest-GetBucketAclRequest) : MethodDecl "public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(SetBucketAclRequest-SetBucketAclRequest) : MethodDecl "@Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(String-String-String-String) : MethodDecl "public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(GetObjectMetadataRequest-GetObjectMetadataRequest) : MethodDecl "public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> getObject(String-String-String-String) : MethodDecl "public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> doesBucketExist(String-String) : MethodDecl "public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }" compose:Replacement merge: LineBased]
											[T -> headBucket(HeadBucketRequest-HeadBucketRequest) : MethodDecl "private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> changeObjectStorageClass(String-String-String-String-StorageClass-StorageClass) : MethodDecl "public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }" compose:Replacement merge: LineBased]
											[T -> setObjectRedirectLocation(String-String-String-String-String-String) : MethodDecl "public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest) : MethodDecl "public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest-File-File) : MethodDecl "public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }" compose:Replacement merge: LineBased]
											[T -> skipContentMd5IntegrityCheck(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(String-String) : MethodDecl "public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(DeleteBucketRequest-DeleteBucketRequest) : MethodDecl "public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-File-File) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-InputStream-InputStream-ObjectMetadata-ObjectMetadata) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }" compose:Replacement merge: LineBased]
											[T -> putObject(PutObjectRequest-PutObjectRequest) : MethodDecl "public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (metadata.getContentMD5() == null && !skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(input);                 input = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }" compose:Replacement merge: LineBased]
											[T -> addAclHeaders(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-AccessControlList-AccessControlList) : MethodDecl "private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }" compose:Replacement merge: LineBased]
											[T -> copyObject(String-String-String-String-String-String-String-String) : MethodDecl "public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }" compose:Replacement merge: LineBased]
											[T -> copyObject(CopyObjectRequest-CopyObjectRequest) : MethodDecl "public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }" compose:Replacement merge: LineBased]
											[T -> copyPart(CopyPartRequest-CopyPartRequest) : MethodDecl "public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(String-String-String-String) : MethodDecl "public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(DeleteObjectRequest-DeleteObjectRequest) : MethodDecl "public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> deleteObjects(DeleteObjectsRequest-DeleteObjectsRequest) : MethodDecl "public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(String-String-String-String-String-String) : MethodDecl "public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(DeleteVersionRequest-DeleteVersionRequest) : MethodDecl "public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest-SetBucketVersioningConfigurationRequest) : MethodDecl "public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketVersioningConfiguration(String-String) : MethodDecl "public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(String-String) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest-GetBucketWebsiteConfigurationRequest) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getBucketLifecycleConfiguration(String-String) : MethodDecl "public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(String-String-BucketLifecycleConfiguration-BucketLifecycleConfiguration) : MethodDecl "public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(SetBucketLifecycleConfigurationRequest-SetBucketLifecycleConfigurationRequest) : MethodDecl "public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(String-String) : MethodDecl "public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(DeleteBucketLifecycleConfigurationRequest-DeleteBucketLifecycleConfigurationRequest) : MethodDecl "public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketCrossOriginConfiguration(String-String) : MethodDecl "public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(String-String-BucketCrossOriginConfiguration-BucketCrossOriginConfiguration) : MethodDecl "public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(SetBucketCrossOriginConfigurationRequest-SetBucketCrossOriginConfigurationRequest) : MethodDecl "public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(String-String) : MethodDecl "public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(DeleteBucketCrossOriginConfigurationRequest-DeleteBucketCrossOriginConfigurationRequest) : MethodDecl "public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketTaggingConfiguration(String-String) : MethodDecl "public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(String-String-BucketTaggingConfiguration-BucketTaggingConfiguration) : MethodDecl "public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(SetBucketTaggingConfigurationRequest-SetBucketTaggingConfigurationRequest) : MethodDecl "public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(String-String) : MethodDecl "public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(DeleteBucketTaggingConfigurationRequest-DeleteBucketTaggingConfigurationRequest) : MethodDecl "public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(String-String-BucketWebsiteConfiguration-BucketWebsiteConfiguration) : MethodDecl "public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest-SetBucketWebsiteConfigurationRequest) : MethodDecl "public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(String-String) : MethodDecl "public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest-DeleteBucketWebsiteConfigurationRequest) : MethodDecl "public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(String-String-BucketNotificationConfiguration-BucketNotificationConfiguration) : MethodDecl "public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(SetBucketNotificationConfigurationRequest-SetBucketNotificationConfigurationRequest) : MethodDecl "public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketNotificationConfiguration(String-String) : MethodDecl "public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLoggingConfiguration(String-String) : MethodDecl "public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest-SetBucketLoggingConfigurationRequest) : MethodDecl "public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(String-String) : MethodDecl "public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(String-String-String-String) : MethodDecl "public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(String-String) : MethodDecl "public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(GetBucketPolicyRequest-GetBucketPolicyRequest) : MethodDecl "public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(SetBucketPolicyRequest-SetBucketPolicyRequest) : MethodDecl "public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(DeleteBucketPolicyRequest-DeleteBucketPolicyRequest) : MethodDecl "public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date-HttpMethod-HttpMethod) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(GeneratePresignedUrlRequest-GeneratePresignedUrlRequest) : MethodDecl "public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }" compose:Replacement merge: LineBased]
											[T -> abortMultipartUpload(AbortMultipartUploadRequest-AbortMultipartUploadRequest) : MethodDecl "public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> completeMultipartUpload(CompleteMultipartUploadRequest-CompleteMultipartUploadRequest) : MethodDecl "public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }" compose:Replacement merge: LineBased]
											[T -> initiateMultipartUpload(InitiateMultipartUploadRequest-InitiateMultipartUploadRequest) : MethodDecl "public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> listMultipartUploads(ListMultipartUploadsRequest-ListMultipartUploadsRequest) : MethodDecl "public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listParts(ListPartsRequest-ListPartsRequest) : MethodDecl "public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> uploadPart(UploadPartRequest-UploadPartRequest) : MethodDecl "public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);                 inputStream = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 String contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());                 byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }" compose:Replacement merge: LineBased]
											[T -> getCachedResponseMetadata(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(RestoreObjectRequest-RestoreObjectRequest) : MethodDecl "public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(String-String-String-String-int-int) : MethodDecl "public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }" compose:Replacement merge: LineBased]
											[T -> assertParameterNotNull(Object-Object-String-String) : MethodDecl "private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }" compose:Replacement merge: LineBased]
											[T -> fireProgressEvent(ProgressListenerCallbackExecutor-ProgressListenerCallbackExecutor-int-int) : MethodDecl "private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }" compose:Replacement merge: LineBased]
											[T -> getAcl(String-String-String-String-String-String-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createSigner(Request<?>-Request<?>-String-String-String-String) : MethodDecl "protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }" compose:Replacement merge: LineBased]
											[T -> upgradeToSigV4({FormalParametersInternal}) : MethodDecl "private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }" compose:Replacement merge: LineBased]
											[T -> presignRequest(Request<T>-Request<T>-HttpMethod-HttpMethod-String-String-String-String-Date-Date-String-String) : MethodDecl "protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }" compose:Replacement merge: LineBased]
											[T -> beforeRequest(Request<T>-Request<T>) : MethodDecl "private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }" compose:Replacement merge: LineBased]
											[T -> convertToVirtualHostEndpoint(String-String) : MethodDecl "private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestMetadata(Request<?>-Request<?>-ObjectMetadata-ObjectMetadata) : MethodDecl "protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithMfaDetails(Request<?>-Request<?>-MultiFactorAuthentication-MultiFactorAuthentication) : MethodDecl "private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyObjectParameters(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-CopyObjectRequest-CopyObjectRequest) : MethodDecl "private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyPartParameters(Request<?>-Request<?>-CopyPartRequest-CopyPartRequest) : MethodDecl "private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> populateSourceSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> addHeaderIfNotNull(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }" compose:Replacement merge: LineBased]
											[T -> addDateHeader(Request<?>-Request<?>-String-String-Date-Date) : MethodDecl "private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }" compose:Replacement merge: LineBased]
											[T -> addStringListHeader(Request<?>-Request<?>-String-String-List<String>-List<String>) : MethodDecl "private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }" compose:Replacement merge: LineBased]
											[T -> addResponseHeaderParameters(Request<?>-Request<?>-ResponseHeaderOverrides-ResponseHeaderOverrides) : MethodDecl "private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }" compose:Replacement merge: LineBased]
											[T -> getResourceUrl(String-String-String-String) : MethodDecl "public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }" compose:Replacement merge: LineBased]
											[T -> getUrl(String-String-String-String) : MethodDecl "public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> getRegion({FormalParametersInternal}) : MethodDecl "public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }" compose:Replacement merge: LineBased]
											[T -> createRequest(String-String-String-String-X-X-HttpMethodName-HttpMethodName) : MethodDecl "protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }" compose:Replacement merge: LineBased]
											[T -> configRequest(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }" compose:Replacement merge: LineBased]
											[T -> validIP(String-String) : MethodDecl "private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-Unmarshaller<X,InputStream>-Unmarshaller<X,InputStream>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createExecutionContext(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "@Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-HttpResponseHandler<AmazonWebServiceResponse<X>>-HttpResponseHandler<AmazonWebServiceResponse<X>>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }" compose:Replacement merge: LineBased]
											[T -> enableRequesterPays(String-String) : MethodDecl "@Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> disableRequesterPays(String-String) : MethodDecl "@Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> isRequesterPaysEnabled(String-String) : MethodDecl "@Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }" compose:Replacement merge: LineBased]
											[T -> setBucketRequestPayment(SetRequestPaymentConfigurationRequest-SetRequestPaymentConfigurationRequest) : MethodDecl "private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketRequestPayment(GetRequestPaymentConfigurationRequest-GetRequestPaymentConfigurationRequest) : MethodDecl "private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }" compose:Replacement merge: LineBased]
											[T -> setZeroContentLength(Request<?>-Request<?>) : MethodDecl "private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));    }" compose:Replacement merge: LineBased]
[NT -> rev_base_f9d63 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.amazonaws.services.s3;" compose:Replacement merge: Default]
										[T -> com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.FileNotFoundException{ImportPackage} : ImportDeclaration "import java.io.FileNotFoundException;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URISyntaxException{ImportPackage} : ImportDeclaration "import java.net.URISyntaxException;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.MessageDigest{ImportPackage} : ImportDeclaration "import java.security.MessageDigest;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.LinkedList{ImportPackage} : ImportDeclaration "import java.util.LinkedList;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map.Entry{ImportPackage} : ImportDeclaration "import java.util.Map.Entry;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.regex.Matcher{ImportPackage} : ImportDeclaration "import java.util.regex.Matcher;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.Log{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.Log;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.LogFactory{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.LogFactory;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.http.client.methods.HttpRequestBase{ImportPackage} : ImportDeclaration "import org.apache.http.client.methods.HttpRequestBase;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AbortedException{ImportPackage} : ImportDeclaration "import com.amazonaws.AbortedException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException.ErrorType{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException.ErrorType;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceClient{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceClient;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.DefaultRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.DefaultRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.HttpMethod{ImportPackage} : ImportDeclaration "import com.amazonaws.HttpMethod;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Request{ImportPackage} : ImportDeclaration "import com.amazonaws.Request;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Response{ImportPackage} : ImportDeclaration "import com.amazonaws.Response;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.SDKGlobalConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.SDKGlobalConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentials{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentials;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.DefaultAWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.EnvironmentVariableCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.InstanceProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.InstanceProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Presigner{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Presigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SignerFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SignerFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SystemPropertiesCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SystemPropertiesCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.profile.ProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.profile.ProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressEvent{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressEvent;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListener{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListener;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListenerCallbackExecutor{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListenerCallbackExecutor;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressReportingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressReportingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.HandlerChainFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.HandlerChainFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.RequestHandler2{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.RequestHandler2;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.http.ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpMethodName{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpMethodName;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.internal.StaticCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.internal.StaticCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.AwsSdkMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.AwsSdkMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.RequestMetricCollector{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.RequestMetricCollector;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.regions.RegionUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.regions.RegionUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.AWSS3V4Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.AWSS3V4Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.BucketNameUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.BucketNameUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Constants{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Constants;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DeleteObjectsResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DeleteObjectsResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DigestValidationInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DigestValidationInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.InputSubstream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.InputSubstream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Mimetypes{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Mimetypes;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableFileInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableFileInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ErrorResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ErrorResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3MetadataResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3MetadataResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ObjectResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ObjectResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3QueryStringSigner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3QueryStringSigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3StringResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3StringResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3VersionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3VersionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3XmlResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3XmlResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServiceUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServiceUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.XmlWriter{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.XmlWriter;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.metrics.S3ServiceMetric{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.metrics.S3ServiceMetric;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AbortMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AmazonS3Exception{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AmazonS3Exception;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Bucket{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Bucket;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketCrossOriginConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLifecycleConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLifecycleConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLoggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLoggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketNotificationConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketNotificationConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketPolicy{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketPolicy;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketTaggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketTaggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketVersioningConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketVersioningConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketWebsiteConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketWebsiteConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CannedAccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CannedAccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CreateBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CreateBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteVersionRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteVersionRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GeneratePresignedUrlRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GenericBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GenericBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketLocationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketLocationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectMetadataRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectMetadataRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grant{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grant;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GroupGrantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GroupGrantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.HeadBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.HeadBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListBucketsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListBucketsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListMultipartUploadsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListMultipartUploadsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListPartsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListPartsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListVersionsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListVersionsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiFactorAuthentication{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiFactorAuthentication;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiObjectDeleteException{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiObjectDeleteException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultipartUploadListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultipartUploadListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectMetadata{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectMetadata;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Owner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Owner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PartListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PartListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Permission{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Permission;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Region{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Region;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ResponseHeaderOverrides{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ResponseHeaderOverrides;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RestoreObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RestoreObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3Object{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3Object;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3ObjectInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3ObjectInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SSECustomerKey{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SSECustomerKey;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.StorageClass{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.StorageClass;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.VersionListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.VersionListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.AclXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.AclXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.Unmarshallers{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.Unmarshallers;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.transform.Unmarshaller{ImportPackage} : ImportDeclaration "import com.amazonaws.transform.Unmarshaller;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics.Field{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics.Field;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Base64{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Base64;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.BinaryUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.BinaryUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.DateUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.DateUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.HttpUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.HttpUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.LengthCheckInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Md5Utils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Md5Utils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.ServiceClientHolderInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.ServiceClientHolderInputStream;" compose:Replacement merge: SemanticConflict]
										[NT -> AmazonS3Client : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client : Id "AmazonS3Client" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AmazonWebServiceClient" compose:Replacement merge: SemanticConflict]
											[T -> ImplList : ImplementsList "implements AmazonS3" compose:Replacement merge: SemanticConflict]
											[T -> S3_SERVICE_NAME : FieldDecl "public static final String S3_SERVICE_NAME = "s3";" compose:Replacement merge: SemanticConflict]
											[T -> S3_SIGNER : FieldDecl "private static final String S3_SIGNER = "S3SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> S3_V4_SIGNER : FieldDecl "private static final String S3_V4_SIGNER = "AWSS3V4SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> log : FieldDecl "private static Log log = LogFactory.getLog(AmazonS3Client.class);" compose:Replacement merge: SemanticConflict]
											[T -> auto5 : InitializerDecl "static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }" compose:Replacement merge: Default]
											[T -> errorResponseHandler : FieldDecl "private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();" compose:Replacement merge: SemanticConflict]
											[T -> voidResponseHandler : FieldDecl "private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);" compose:Replacement merge: SemanticConflict]
											[T -> bucketConfigurationXmlFactory : FieldDecl "private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> requestPaymentConfigurationXmlFactory : FieldDecl "private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> clientOptions : FieldDecl "private S3ClientOptions clientOptions = new S3ClientOptions();" compose:Replacement merge: SemanticConflict]
											[T -> awsCredentialsProvider : FieldDecl "private AWSCredentialsProvider awsCredentialsProvider;" compose:Replacement merge: SemanticConflict]
											[T -> hasExplicitRegion : FieldDecl "private boolean hasExplicitRegion;" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client({FormalParametersInternal}) : ConstructorDecl "public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration-RequestMetricCollector-RequestMetricCollector) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }" compose:Replacement merge: LineBased]
											[T -> init({FormalParametersInternal}) : MethodDecl "private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }" compose:Replacement merge: LineBased]
											[T -> setEndpoint(String-String) : MethodDecl "@Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }" compose:Replacement merge: LineBased]
											[T -> setRegion(com.amazonaws.regions.Region-com.amazonaws.regions.Region) : MethodDecl "@Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }" compose:Replacement merge: LineBased]
											[T -> setS3ClientOptions(S3ClientOptions-S3ClientOptions) : MethodDecl "public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfVersions(VersionListing-VersionListing) : MethodDecl "public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String-String-String-String-String-String-String-Integer-Integer) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }" compose:Replacement merge: LineBased]
											[T -> listVersions(ListVersionsRequest-ListVersionsRequest) : MethodDecl "public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String) : MethodDecl "public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String-String-String) : MethodDecl "public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(ListObjectsRequest-ListObjectsRequest) : MethodDecl "public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfObjects(ObjectListing-ObjectListing) : MethodDecl "public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> getS3AccountOwner({FormalParametersInternal}) : MethodDecl "public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets(ListBucketsRequest-ListBucketsRequest) : MethodDecl "public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets({FormalParametersInternal}) : MethodDecl "public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(GetBucketLocationRequest-GetBucketLocationRequest) : MethodDecl "public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(String-String) : MethodDecl "public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String) : MethodDecl "public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-Region-Region) : MethodDecl "public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-String-String) : MethodDecl "public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(CreateBucketRequest-CreateBucketRequest) : MethodDecl "public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(String-String) : MethodDecl "public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(GetBucketAclRequest-GetBucketAclRequest) : MethodDecl "public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(SetBucketAclRequest-SetBucketAclRequest) : MethodDecl "@Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(String-String-String-String) : MethodDecl "public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(GetObjectMetadataRequest-GetObjectMetadataRequest) : MethodDecl "public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> getObject(String-String-String-String) : MethodDecl "public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> doesBucketExist(String-String) : MethodDecl "public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }" compose:Replacement merge: LineBased]
											[T -> headBucket(HeadBucketRequest-HeadBucketRequest) : MethodDecl "private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> changeObjectStorageClass(String-String-String-String-StorageClass-StorageClass) : MethodDecl "public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }" compose:Replacement merge: LineBased]
											[T -> setObjectRedirectLocation(String-String-String-String-String-String) : MethodDecl "public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest) : MethodDecl "public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest-File-File) : MethodDecl "public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }" compose:Replacement merge: LineBased]
											[T -> skipContentMd5IntegrityCheck(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(String-String) : MethodDecl "public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(DeleteBucketRequest-DeleteBucketRequest) : MethodDecl "public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-File-File) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-InputStream-InputStream-ObjectMetadata-ObjectMetadata) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }" compose:Replacement merge: LineBased]
											[T -> putObject(PutObjectRequest-PutObjectRequest) : MethodDecl "public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (!skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(input);                 input = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }" compose:Replacement merge: LineBased]
											[T -> addAclHeaders(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-AccessControlList-AccessControlList) : MethodDecl "private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }" compose:Replacement merge: LineBased]
											[T -> copyObject(String-String-String-String-String-String-String-String) : MethodDecl "public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }" compose:Replacement merge: LineBased]
											[T -> copyObject(CopyObjectRequest-CopyObjectRequest) : MethodDecl "public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }" compose:Replacement merge: LineBased]
											[T -> copyPart(CopyPartRequest-CopyPartRequest) : MethodDecl "public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(String-String-String-String) : MethodDecl "public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(DeleteObjectRequest-DeleteObjectRequest) : MethodDecl "public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> deleteObjects(DeleteObjectsRequest-DeleteObjectsRequest) : MethodDecl "public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(String-String-String-String-String-String) : MethodDecl "public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(DeleteVersionRequest-DeleteVersionRequest) : MethodDecl "public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest-SetBucketVersioningConfigurationRequest) : MethodDecl "public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketVersioningConfiguration(String-String) : MethodDecl "public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(String-String) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest-GetBucketWebsiteConfigurationRequest) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getBucketLifecycleConfiguration(String-String) : MethodDecl "public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(String-String-BucketLifecycleConfiguration-BucketLifecycleConfiguration) : MethodDecl "public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(SetBucketLifecycleConfigurationRequest-SetBucketLifecycleConfigurationRequest) : MethodDecl "public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(String-String) : MethodDecl "public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(DeleteBucketLifecycleConfigurationRequest-DeleteBucketLifecycleConfigurationRequest) : MethodDecl "public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketCrossOriginConfiguration(String-String) : MethodDecl "public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(String-String-BucketCrossOriginConfiguration-BucketCrossOriginConfiguration) : MethodDecl "public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(SetBucketCrossOriginConfigurationRequest-SetBucketCrossOriginConfigurationRequest) : MethodDecl "public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(String-String) : MethodDecl "public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(DeleteBucketCrossOriginConfigurationRequest-DeleteBucketCrossOriginConfigurationRequest) : MethodDecl "public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketTaggingConfiguration(String-String) : MethodDecl "public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(String-String-BucketTaggingConfiguration-BucketTaggingConfiguration) : MethodDecl "public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(SetBucketTaggingConfigurationRequest-SetBucketTaggingConfigurationRequest) : MethodDecl "public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(String-String) : MethodDecl "public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(DeleteBucketTaggingConfigurationRequest-DeleteBucketTaggingConfigurationRequest) : MethodDecl "public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(String-String-BucketWebsiteConfiguration-BucketWebsiteConfiguration) : MethodDecl "public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest-SetBucketWebsiteConfigurationRequest) : MethodDecl "public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(String-String) : MethodDecl "public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest-DeleteBucketWebsiteConfigurationRequest) : MethodDecl "public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(String-String-BucketNotificationConfiguration-BucketNotificationConfiguration) : MethodDecl "public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(SetBucketNotificationConfigurationRequest-SetBucketNotificationConfigurationRequest) : MethodDecl "public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketNotificationConfiguration(String-String) : MethodDecl "public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLoggingConfiguration(String-String) : MethodDecl "public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest-SetBucketLoggingConfigurationRequest) : MethodDecl "public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(String-String) : MethodDecl "public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(String-String-String-String) : MethodDecl "public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(String-String) : MethodDecl "public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(GetBucketPolicyRequest-GetBucketPolicyRequest) : MethodDecl "public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(SetBucketPolicyRequest-SetBucketPolicyRequest) : MethodDecl "public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(DeleteBucketPolicyRequest-DeleteBucketPolicyRequest) : MethodDecl "public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date-HttpMethod-HttpMethod) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(GeneratePresignedUrlRequest-GeneratePresignedUrlRequest) : MethodDecl "public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }" compose:Replacement merge: LineBased]
											[T -> abortMultipartUpload(AbortMultipartUploadRequest-AbortMultipartUploadRequest) : MethodDecl "public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> completeMultipartUpload(CompleteMultipartUploadRequest-CompleteMultipartUploadRequest) : MethodDecl "public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }" compose:Replacement merge: LineBased]
											[T -> initiateMultipartUpload(InitiateMultipartUploadRequest-InitiateMultipartUploadRequest) : MethodDecl "public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> listMultipartUploads(ListMultipartUploadsRequest-ListMultipartUploadsRequest) : MethodDecl "public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listParts(ListPartsRequest-ListPartsRequest) : MethodDecl "public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> uploadPart(UploadPartRequest-UploadPartRequest) : MethodDecl "public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);                 inputStream = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 String contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());                 byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }" compose:Replacement merge: LineBased]
											[T -> getCachedResponseMetadata(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(RestoreObjectRequest-RestoreObjectRequest) : MethodDecl "public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(String-String-String-String-int-int) : MethodDecl "public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }" compose:Replacement merge: LineBased]
											[T -> assertParameterNotNull(Object-Object-String-String) : MethodDecl "private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }" compose:Replacement merge: LineBased]
											[T -> fireProgressEvent(ProgressListenerCallbackExecutor-ProgressListenerCallbackExecutor-int-int) : MethodDecl "private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }" compose:Replacement merge: LineBased]
											[T -> getAcl(String-String-String-String-String-String-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createSigner(Request<?>-Request<?>-String-String-String-String) : MethodDecl "protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }" compose:Replacement merge: LineBased]
											[T -> upgradeToSigV4({FormalParametersInternal}) : MethodDecl "private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }" compose:Replacement merge: LineBased]
											[T -> presignRequest(Request<T>-Request<T>-HttpMethod-HttpMethod-String-String-String-String-Date-Date-String-String) : MethodDecl "protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }" compose:Replacement merge: LineBased]
											[T -> beforeRequest(Request<T>-Request<T>) : MethodDecl "private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }" compose:Replacement merge: LineBased]
											[T -> convertToVirtualHostEndpoint(String-String) : MethodDecl "private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestMetadata(Request<?>-Request<?>-ObjectMetadata-ObjectMetadata) : MethodDecl "protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithMfaDetails(Request<?>-Request<?>-MultiFactorAuthentication-MultiFactorAuthentication) : MethodDecl "private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyObjectParameters(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-CopyObjectRequest-CopyObjectRequest) : MethodDecl "private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyPartParameters(Request<?>-Request<?>-CopyPartRequest-CopyPartRequest) : MethodDecl "private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> populateSourceSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> addHeaderIfNotNull(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }" compose:Replacement merge: LineBased]
											[T -> addDateHeader(Request<?>-Request<?>-String-String-Date-Date) : MethodDecl "private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }" compose:Replacement merge: LineBased]
											[T -> addStringListHeader(Request<?>-Request<?>-String-String-List<String>-List<String>) : MethodDecl "private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }" compose:Replacement merge: LineBased]
											[T -> addResponseHeaderParameters(Request<?>-Request<?>-ResponseHeaderOverrides-ResponseHeaderOverrides) : MethodDecl "private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }" compose:Replacement merge: LineBased]
											[T -> getResourceUrl(String-String-String-String) : MethodDecl "public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }" compose:Replacement merge: LineBased]
											[T -> getUrl(String-String-String-String) : MethodDecl "public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> getRegion({FormalParametersInternal}) : MethodDecl "public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }" compose:Replacement merge: LineBased]
											[T -> createRequest(String-String-String-String-X-X-HttpMethodName-HttpMethodName) : MethodDecl "protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }" compose:Replacement merge: LineBased]
											[T -> configRequest(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }" compose:Replacement merge: LineBased]
											[T -> validIP(String-String) : MethodDecl "private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-Unmarshaller<X,InputStream>-Unmarshaller<X,InputStream>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createExecutionContext(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "@Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-HttpResponseHandler<AmazonWebServiceResponse<X>>-HttpResponseHandler<AmazonWebServiceResponse<X>>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }" compose:Replacement merge: LineBased]
											[T -> enableRequesterPays(String-String) : MethodDecl "@Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> disableRequesterPays(String-String) : MethodDecl "@Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> isRequesterPaysEnabled(String-String) : MethodDecl "@Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }" compose:Replacement merge: LineBased]
											[T -> setBucketRequestPayment(SetRequestPaymentConfigurationRequest-SetRequestPaymentConfigurationRequest) : MethodDecl "private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketRequestPayment(GetRequestPaymentConfigurationRequest-GetRequestPaymentConfigurationRequest) : MethodDecl "private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }" compose:Replacement merge: LineBased]
											[T -> setZeroContentLength(Request<?>-Request<?>) : MethodDecl "private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));     }" compose:Replacement merge: LineBased]
[NT -> rev_right_257dd : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.amazonaws.services.s3;" compose:Replacement merge: Default]
										[T -> com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.FileNotFoundException{ImportPackage} : ImportDeclaration "import java.io.FileNotFoundException;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URISyntaxException{ImportPackage} : ImportDeclaration "import java.net.URISyntaxException;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.MessageDigest{ImportPackage} : ImportDeclaration "import java.security.MessageDigest;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.LinkedList{ImportPackage} : ImportDeclaration "import java.util.LinkedList;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map.Entry{ImportPackage} : ImportDeclaration "import java.util.Map.Entry;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.regex.Matcher{ImportPackage} : ImportDeclaration "import java.util.regex.Matcher;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.Log{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.Log;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.LogFactory{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.LogFactory;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.http.client.methods.HttpRequestBase{ImportPackage} : ImportDeclaration "import org.apache.http.client.methods.HttpRequestBase;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AbortedException{ImportPackage} : ImportDeclaration "import com.amazonaws.AbortedException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException.ErrorType{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException.ErrorType;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceClient{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceClient;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.DefaultRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.DefaultRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.HttpMethod{ImportPackage} : ImportDeclaration "import com.amazonaws.HttpMethod;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Request{ImportPackage} : ImportDeclaration "import com.amazonaws.Request;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Response{ImportPackage} : ImportDeclaration "import com.amazonaws.Response;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.SDKGlobalConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.SDKGlobalConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentials{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentials;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.DefaultAWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.EnvironmentVariableCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.InstanceProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.InstanceProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Presigner{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Presigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SignerFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SignerFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SystemPropertiesCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SystemPropertiesCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.profile.ProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.profile.ProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressEvent{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressEvent;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListener{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListener;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListenerCallbackExecutor{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListenerCallbackExecutor;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressReportingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressReportingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.HandlerChainFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.HandlerChainFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.RequestHandler2{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.RequestHandler2;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.http.ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpMethodName{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpMethodName;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.internal.StaticCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.internal.StaticCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.AwsSdkMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.AwsSdkMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.RequestMetricCollector{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.RequestMetricCollector;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.regions.RegionUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.regions.RegionUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.AWSS3V4Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.AWSS3V4Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.BucketNameUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.BucketNameUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Constants{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Constants;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DeleteObjectsResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DeleteObjectsResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DigestValidationInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DigestValidationInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.InputSubstream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.InputSubstream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Mimetypes{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Mimetypes;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableFileInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableFileInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ErrorResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ErrorResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3MetadataResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3MetadataResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ObjectResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ObjectResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3QueryStringSigner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3QueryStringSigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3StringResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3StringResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3VersionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3VersionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3XmlResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3XmlResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServiceUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServiceUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.XmlWriter{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.XmlWriter;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.metrics.S3ServiceMetric{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.metrics.S3ServiceMetric;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AbortMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AmazonS3Exception{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AmazonS3Exception;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Bucket{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Bucket;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketCrossOriginConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLifecycleConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLifecycleConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLoggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLoggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketNotificationConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketNotificationConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketPolicy{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketPolicy;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketTaggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketTaggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketVersioningConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketVersioningConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketWebsiteConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketWebsiteConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CannedAccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CannedAccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CreateBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CreateBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteVersionRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteVersionRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GeneratePresignedUrlRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GenericBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GenericBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketLocationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketLocationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectMetadataRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectMetadataRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grant{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grant;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GroupGrantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GroupGrantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.HeadBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.HeadBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListBucketsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListBucketsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListMultipartUploadsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListMultipartUploadsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListPartsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListPartsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListVersionsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListVersionsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiFactorAuthentication{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiFactorAuthentication;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiObjectDeleteException{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiObjectDeleteException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultipartUploadListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultipartUploadListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectMetadata{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectMetadata;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Owner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Owner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PartListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PartListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Permission{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Permission;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Region{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Region;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ResponseHeaderOverrides{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ResponseHeaderOverrides;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RestoreObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RestoreObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3Object{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3Object;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3ObjectInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3ObjectInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SSECustomerKey{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SSECustomerKey;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.StorageClass{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.StorageClass;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.VersionListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.VersionListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.AclXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.AclXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.Unmarshallers{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.Unmarshallers;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.transform.Unmarshaller{ImportPackage} : ImportDeclaration "import com.amazonaws.transform.Unmarshaller;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics.Field{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics.Field;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Base64{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Base64;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.BinaryUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.BinaryUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.DateUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.DateUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.HttpUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.HttpUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.LengthCheckInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Md5Utils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Md5Utils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.ServiceClientHolderInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.ServiceClientHolderInputStream;" compose:Replacement merge: SemanticConflict]
										[NT -> AmazonS3Client : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client : Id "AmazonS3Client" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AmazonWebServiceClient" compose:Replacement merge: SemanticConflict]
											[T -> ImplList : ImplementsList "implements AmazonS3" compose:Replacement merge: SemanticConflict]
											[T -> S3_SERVICE_NAME : FieldDecl "public static final String S3_SERVICE_NAME = "s3";" compose:Replacement merge: SemanticConflict]
											[T -> S3_SIGNER : FieldDecl "private static final String S3_SIGNER = "S3SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> S3_V4_SIGNER : FieldDecl "private static final String S3_V4_SIGNER = "AWSS3V4SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> log : FieldDecl "private static Log log = LogFactory.getLog(AmazonS3Client.class);" compose:Replacement merge: SemanticConflict]
											[T -> auto6 : InitializerDecl "static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }" compose:Replacement merge: Default]
											[T -> errorResponseHandler : FieldDecl "private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();" compose:Replacement merge: SemanticConflict]
											[T -> voidResponseHandler : FieldDecl "private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);" compose:Replacement merge: SemanticConflict]
											[T -> bucketConfigurationXmlFactory : FieldDecl "private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> requestPaymentConfigurationXmlFactory : FieldDecl "private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> clientOptions : FieldDecl "private S3ClientOptions clientOptions = new S3ClientOptions();" compose:Replacement merge: SemanticConflict]
											[T -> awsCredentialsProvider : FieldDecl "private AWSCredentialsProvider awsCredentialsProvider;" compose:Replacement merge: SemanticConflict]
											[T -> hasExplicitRegion : FieldDecl "private boolean hasExplicitRegion;" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client({FormalParametersInternal}) : ConstructorDecl "public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration-RequestMetricCollector-RequestMetricCollector) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }" compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }" compose:Replacement merge: LineBased]
											[T -> init({FormalParametersInternal}) : MethodDecl "private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }" compose:Replacement merge: LineBased]
											[T -> setEndpoint(String-String) : MethodDecl "@Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }" compose:Replacement merge: LineBased]
											[T -> setRegion(com.amazonaws.regions.Region-com.amazonaws.regions.Region) : MethodDecl "@Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }" compose:Replacement merge: LineBased]
											[T -> setS3ClientOptions(S3ClientOptions-S3ClientOptions) : MethodDecl "public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfVersions(VersionListing-VersionListing) : MethodDecl "public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String-String-String-String-String-String-String-Integer-Integer) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }" compose:Replacement merge: LineBased]
											[T -> listVersions(ListVersionsRequest-ListVersionsRequest) : MethodDecl "public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String) : MethodDecl "public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(String-String-String-String) : MethodDecl "public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }" compose:Replacement merge: LineBased]
											[T -> listObjects(ListObjectsRequest-ListObjectsRequest) : MethodDecl "public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listNextBatchOfObjects(ObjectListing-ObjectListing) : MethodDecl "public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }" compose:Replacement merge: LineBased]
											[T -> getS3AccountOwner({FormalParametersInternal}) : MethodDecl "public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets(ListBucketsRequest-ListBucketsRequest) : MethodDecl "public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }" compose:Replacement merge: LineBased]
											[T -> listBuckets({FormalParametersInternal}) : MethodDecl "public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(GetBucketLocationRequest-GetBucketLocationRequest) : MethodDecl "public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLocation(String-String) : MethodDecl "public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String) : MethodDecl "public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-Region-Region) : MethodDecl "public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-String-String) : MethodDecl "public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }" compose:Replacement merge: LineBased]
											[T -> createBucket(CreateBucketRequest-CreateBucketRequest) : MethodDecl "public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }" compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(String-String) : MethodDecl "public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketAcl(GetBucketAclRequest-GetBucketAclRequest) : MethodDecl "public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(SetBucketAclRequest-SetBucketAclRequest) : MethodDecl "@Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }" compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(String-String-String-String) : MethodDecl "public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(GetObjectMetadataRequest-GetObjectMetadataRequest) : MethodDecl "public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> getObject(String-String-String-String) : MethodDecl "public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> doesBucketExist(String-String) : MethodDecl "public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }" compose:Replacement merge: LineBased]
											[T -> headBucket(HeadBucketRequest-HeadBucketRequest) : MethodDecl "private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> changeObjectStorageClass(String-String-String-String-StorageClass-StorageClass) : MethodDecl "public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }" compose:Replacement merge: LineBased]
											[T -> setObjectRedirectLocation(String-String-String-String-String-String) : MethodDecl "public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest) : MethodDecl "public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest-File-File) : MethodDecl "public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }" compose:Replacement merge: LineBased]
											[T -> skipContentMd5IntegrityCheck(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(String-String) : MethodDecl "public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucket(DeleteBucketRequest-DeleteBucketRequest) : MethodDecl "public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-File-File) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }" compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-InputStream-InputStream-ObjectMetadata-ObjectMetadata) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }" compose:Replacement merge: LineBased]
											[T -> putObject(PutObjectRequest-PutObjectRequest) : MethodDecl "public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (!skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             input = md5DigestStream = new MD5DigestCalculatingInputStream(input);         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }" compose:Replacement merge: LineBased]
											[T -> addAclHeaders(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-AccessControlList-AccessControlList) : MethodDecl "private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }" compose:Replacement merge: LineBased]
											[T -> copyObject(String-String-String-String-String-String-String-String) : MethodDecl "public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }" compose:Replacement merge: LineBased]
											[T -> copyObject(CopyObjectRequest-CopyObjectRequest) : MethodDecl "public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }" compose:Replacement merge: LineBased]
											[T -> copyPart(CopyPartRequest-CopyPartRequest) : MethodDecl "public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(String-String-String-String) : MethodDecl "public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }" compose:Replacement merge: LineBased]
											[T -> deleteObject(DeleteObjectRequest-DeleteObjectRequest) : MethodDecl "public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> deleteObjects(DeleteObjectsRequest-DeleteObjectsRequest) : MethodDecl "public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(String-String-String-String-String-String) : MethodDecl "public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }" compose:Replacement merge: LineBased]
											[T -> deleteVersion(DeleteVersionRequest-DeleteVersionRequest) : MethodDecl "public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest-SetBucketVersioningConfigurationRequest) : MethodDecl "public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketVersioningConfiguration(String-String) : MethodDecl "public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(String-String) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest-GetBucketWebsiteConfigurationRequest) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> getBucketLifecycleConfiguration(String-String) : MethodDecl "public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(String-String-BucketLifecycleConfiguration-BucketLifecycleConfiguration) : MethodDecl "public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(SetBucketLifecycleConfigurationRequest-SetBucketLifecycleConfigurationRequest) : MethodDecl "public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(String-String) : MethodDecl "public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(DeleteBucketLifecycleConfigurationRequest-DeleteBucketLifecycleConfigurationRequest) : MethodDecl "public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketCrossOriginConfiguration(String-String) : MethodDecl "public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(String-String-BucketCrossOriginConfiguration-BucketCrossOriginConfiguration) : MethodDecl "public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(SetBucketCrossOriginConfigurationRequest-SetBucketCrossOriginConfigurationRequest) : MethodDecl "public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(String-String) : MethodDecl "public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }" compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(DeleteBucketCrossOriginConfigurationRequest-DeleteBucketCrossOriginConfigurationRequest) : MethodDecl "public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketTaggingConfiguration(String-String) : MethodDecl "public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(String-String-BucketTaggingConfiguration-BucketTaggingConfiguration) : MethodDecl "public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(SetBucketTaggingConfigurationRequest-SetBucketTaggingConfigurationRequest) : MethodDecl "public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(String-String) : MethodDecl "public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(DeleteBucketTaggingConfigurationRequest-DeleteBucketTaggingConfigurationRequest) : MethodDecl "public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(String-String-BucketWebsiteConfiguration-BucketWebsiteConfiguration) : MethodDecl "public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest-SetBucketWebsiteConfigurationRequest) : MethodDecl "public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(String-String) : MethodDecl "public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest-DeleteBucketWebsiteConfigurationRequest) : MethodDecl "public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(String-String-BucketNotificationConfiguration-BucketNotificationConfiguration) : MethodDecl "public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }" compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(SetBucketNotificationConfigurationRequest-SetBucketNotificationConfigurationRequest) : MethodDecl "public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketNotificationConfiguration(String-String) : MethodDecl "public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketLoggingConfiguration(String-String) : MethodDecl "public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest-SetBucketLoggingConfigurationRequest) : MethodDecl "public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(String-String) : MethodDecl "public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(String-String-String-String) : MethodDecl "public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(String-String) : MethodDecl "public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }" compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(GetBucketPolicyRequest-GetBucketPolicyRequest) : MethodDecl "public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }" compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(SetBucketPolicyRequest-SetBucketPolicyRequest) : MethodDecl "public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(DeleteBucketPolicyRequest-DeleteBucketPolicyRequest) : MethodDecl "public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date-HttpMethod-HttpMethod) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(GeneratePresignedUrlRequest-GeneratePresignedUrlRequest) : MethodDecl "public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }" compose:Replacement merge: LineBased]
											[T -> abortMultipartUpload(AbortMultipartUploadRequest-AbortMultipartUploadRequest) : MethodDecl "public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> completeMultipartUpload(CompleteMultipartUploadRequest-CompleteMultipartUploadRequest) : MethodDecl "public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }" compose:Replacement merge: LineBased]
											[T -> initiateMultipartUpload(InitiateMultipartUploadRequest-InitiateMultipartUploadRequest) : MethodDecl "public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> listMultipartUploads(ListMultipartUploadsRequest-ListMultipartUploadsRequest) : MethodDecl "public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }" compose:Replacement merge: LineBased]
											[T -> listParts(ListPartsRequest-ListPartsRequest) : MethodDecl "public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }" compose:Replacement merge: LineBased]
											[T -> uploadPart(UploadPartRequest-UploadPartRequest) : MethodDecl "public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             inputStream = md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 byte[] clientSideHash = md5DigestStream.getMd5Digest();                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }" compose:Replacement merge: LineBased]
											[T -> getCachedResponseMetadata(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(RestoreObjectRequest-RestoreObjectRequest) : MethodDecl "public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> restoreObject(String-String-String-String-int-int) : MethodDecl "public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }" compose:Replacement merge: LineBased]
											[T -> assertParameterNotNull(Object-Object-String-String) : MethodDecl "private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }" compose:Replacement merge: LineBased]
											[T -> fireProgressEvent(ProgressListenerCallbackExecutor-ProgressListenerCallbackExecutor-int-int) : MethodDecl "private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }" compose:Replacement merge: LineBased]
											[T -> getAcl(String-String-String-String-String-String-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createSigner(Request<?>-Request<?>-String-String-String-String) : MethodDecl "protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }" compose:Replacement merge: LineBased]
											[T -> upgradeToSigV4({FormalParametersInternal}) : MethodDecl "private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }" compose:Replacement merge: LineBased]
											[T -> presignRequest(Request<T>-Request<T>-HttpMethod-HttpMethod-String-String-String-String-Date-Date-String-String) : MethodDecl "protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }" compose:Replacement merge: LineBased]
											[T -> beforeRequest(Request<T>-Request<T>) : MethodDecl "private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }" compose:Replacement merge: LineBased]
											[T -> convertToVirtualHostEndpoint(String-String) : MethodDecl "private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestMetadata(Request<?>-Request<?>-ObjectMetadata-ObjectMetadata) : MethodDecl "protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithMfaDetails(Request<?>-Request<?>-MultiFactorAuthentication-MultiFactorAuthentication) : MethodDecl "private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyObjectParameters(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-CopyObjectRequest-CopyObjectRequest) : MethodDecl "private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyPartParameters(Request<?>-Request<?>-CopyPartRequest-CopyPartRequest) : MethodDecl "private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }" compose:Replacement merge: LineBased]
											[T -> populateSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> populateSourceSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }" compose:Replacement merge: LineBased]
											[T -> addHeaderIfNotNull(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }" compose:Replacement merge: LineBased]
											[T -> addDateHeader(Request<?>-Request<?>-String-String-Date-Date) : MethodDecl "private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }" compose:Replacement merge: LineBased]
											[T -> addStringListHeader(Request<?>-Request<?>-String-String-List<String>-List<String>) : MethodDecl "private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }" compose:Replacement merge: LineBased]
											[T -> addResponseHeaderParameters(Request<?>-Request<?>-ResponseHeaderOverrides-ResponseHeaderOverrides) : MethodDecl "private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }" compose:Replacement merge: LineBased]
											[T -> getResourceUrl(String-String-String-String) : MethodDecl "public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }" compose:Replacement merge: LineBased]
											[T -> getUrl(String-String-String-String) : MethodDecl "public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }" compose:Replacement merge: LineBased]
											[T -> getRegion({FormalParametersInternal}) : MethodDecl "public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }" compose:Replacement merge: LineBased]
											[T -> createRequest(String-String-String-String-X-X-HttpMethodName-HttpMethodName) : MethodDecl "protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }" compose:Replacement merge: LineBased]
											[T -> configRequest(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }" compose:Replacement merge: LineBased]
											[T -> validIP(String-String) : MethodDecl "private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-Unmarshaller<X,InputStream>-Unmarshaller<X,InputStream>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }" compose:Replacement merge: LineBased]
											[T -> createExecutionContext(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "@Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }" compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-HttpResponseHandler<AmazonWebServiceResponse<X>>-HttpResponseHandler<AmazonWebServiceResponse<X>>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }" compose:Replacement merge: LineBased]
											[T -> enableRequesterPays(String-String) : MethodDecl "@Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> disableRequesterPays(String-String) : MethodDecl "@Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }" compose:Replacement merge: LineBased]
											[T -> isRequesterPaysEnabled(String-String) : MethodDecl "@Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }" compose:Replacement merge: LineBased]
											[T -> setBucketRequestPayment(SetRequestPaymentConfigurationRequest-SetRequestPaymentConfigurationRequest) : MethodDecl "private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }" compose:Replacement merge: LineBased]
											[T -> getBucketRequestPayment(GetRequestPaymentConfigurationRequest-GetRequestPaymentConfigurationRequest) : MethodDecl "private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }" compose:Replacement merge: LineBased]
											[T -> setZeroContentLength(Request<?>-Request<?>) : MethodDecl "private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));     }" compose:Replacement merge: LineBased]
Having repository: /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/GitBlameRepo/.git
Checked out and created branch sucessfully: refs/heads/left
Checked out branch sucessfully: refs/heads/master
Checked out and created branch sucessfully: refs/heads/right
Checked out branch sucessfully: refs/heads/master
Fast-forward
Merged-not-committed
[NT -> rev_left_7ab10 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.amazonaws.services.s3;" compose:Replacement merge: Default]
										[T -> com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES{ImportPackage} : ImportDeclaration "import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.FileNotFoundException{ImportPackage} : ImportDeclaration "import java.io.FileNotFoundException;" compose:Replacement merge: SemanticConflict]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URISyntaxException{ImportPackage} : ImportDeclaration "import java.net.URISyntaxException;" compose:Replacement merge: SemanticConflict]
										[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.MessageDigest{ImportPackage} : ImportDeclaration "import java.security.MessageDigest;" compose:Replacement merge: SemanticConflict]
										[T -> java.security.NoSuchAlgorithmException{ImportPackage} : ImportDeclaration "import java.security.NoSuchAlgorithmException;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.LinkedList{ImportPackage} : ImportDeclaration "import java.util.LinkedList;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Map.Entry{ImportPackage} : ImportDeclaration "import java.util.Map.Entry;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: SemanticConflict]
										[T -> java.util.regex.Matcher{ImportPackage} : ImportDeclaration "import java.util.regex.Matcher;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.Log{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.Log;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.commons.logging.LogFactory{ImportPackage} : ImportDeclaration "import org.apache.commons.logging.LogFactory;" compose:Replacement merge: SemanticConflict]
										[T -> org.apache.http.client.methods.HttpRequestBase{ImportPackage} : ImportDeclaration "import org.apache.http.client.methods.HttpRequestBase;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AbortedException{ImportPackage} : ImportDeclaration "import com.amazonaws.AbortedException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonClientException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonClientException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonServiceException.ErrorType{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonServiceException.ErrorType;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceClient{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceClient;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.AmazonWebServiceResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.AmazonWebServiceResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.ClientConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.ClientConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.DefaultRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.DefaultRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.HttpMethod{ImportPackage} : ImportDeclaration "import com.amazonaws.HttpMethod;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Request{ImportPackage} : ImportDeclaration "import com.amazonaws.Request;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.Response{ImportPackage} : ImportDeclaration "import com.amazonaws.Response;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.SDKGlobalConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.SDKGlobalConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentials{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentials;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.AWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.AWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.DefaultAWSCredentialsProviderChain{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.EnvironmentVariableCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.InstanceProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.InstanceProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Presigner{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Presigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SignerFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SignerFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.SystemPropertiesCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.SystemPropertiesCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.auth.profile.ProfileCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.auth.profile.ProfileCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressEvent{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressEvent;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListener{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListener;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressListenerCallbackExecutor{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressListenerCallbackExecutor;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.event.ProgressReportingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.event.ProgressReportingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.HandlerChainFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.HandlerChainFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.handlers.RequestHandler2{ImportPackage} : ImportDeclaration "import com.amazonaws.handlers.RequestHandler2;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.http.ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpMethodName{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpMethodName;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.http.HttpResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.http.HttpResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.internal.StaticCredentialsProvider{ImportPackage} : ImportDeclaration "import com.amazonaws.internal.StaticCredentialsProvider;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.AwsSdkMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.AwsSdkMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.metrics.RequestMetricCollector{ImportPackage} : ImportDeclaration "import com.amazonaws.metrics.RequestMetricCollector;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.regions.RegionUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.regions.RegionUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.AWSS3V4Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.AWSS3V4Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.BucketNameUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.BucketNameUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Constants{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Constants;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DeleteObjectsResponse{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DeleteObjectsResponse;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.DigestValidationInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.DigestValidationInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.InputSubstream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.InputSubstream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.Mimetypes{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.Mimetypes;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableFileInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableFileInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.RepeatableInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.RepeatableInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ErrorResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ErrorResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ExecutionContext{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ExecutionContext;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3MetadataResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3MetadataResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3ObjectResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3ObjectResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3QueryStringSigner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3QueryStringSigner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3Signer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3Signer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3StringResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3StringResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3VersionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3VersionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.S3XmlResponseHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.S3XmlResponseHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.ServiceUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.ServiceUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.internal.XmlWriter{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.internal.XmlWriter;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.metrics.S3ServiceMetric{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.metrics.S3ServiceMetric;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AbortMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.AmazonS3Exception{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.AmazonS3Exception;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Bucket{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Bucket;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketCrossOriginConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLifecycleConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLifecycleConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketLoggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketLoggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketNotificationConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketNotificationConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketPolicy{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketPolicy;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketTaggingConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketTaggingConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketVersioningConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketVersioningConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.BucketWebsiteConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.BucketWebsiteConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CannedAccessControlList{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CannedAccessControlList;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CompleteMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CompleteMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CopyPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CopyPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.CreateBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.CreateBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteObjectsResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteObjectsResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.DeleteVersionRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.DeleteVersionRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GeneratePresignedUrlRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GenericBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GenericBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketLocationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketLocationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectMetadataRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectMetadataRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grant{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grant;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Grantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Grantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.GroupGrantee{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.GroupGrantee;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.HeadBucketRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.HeadBucketRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.InitiateMultipartUploadResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.InitiateMultipartUploadResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListBucketsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListBucketsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListMultipartUploadsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListMultipartUploadsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListObjectsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListObjectsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListPartsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListPartsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ListVersionsRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ListVersionsRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiFactorAuthentication{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiFactorAuthentication;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultiObjectDeleteException{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultiObjectDeleteException;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.MultipartUploadListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.MultipartUploadListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ObjectMetadata{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ObjectMetadata;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Owner{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Owner;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PartListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PartListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Permission{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Permission;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.PutObjectResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.PutObjectResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.Region{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.Region;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.ResponseHeaderOverrides{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.ResponseHeaderOverrides;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.RestoreObjectRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.RestoreObjectRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3Object{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3Object;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.S3ObjectInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.S3ObjectInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SSECustomerKey{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SSECustomerKey;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketAclRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketAclRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketPolicyRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketPolicyRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.StorageClass{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.StorageClass;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartRequest{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartRequest;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.UploadPartResult{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.UploadPartResult;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.VersionListing{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.VersionListing;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.AclXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.AclXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.RequestXmlFactory{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.RequestXmlFactory;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.Unmarshallers{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.Unmarshallers;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler{ImportPackage} : ImportDeclaration "import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.transform.Unmarshaller{ImportPackage} : ImportDeclaration "import com.amazonaws.transform.Unmarshaller;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.AWSRequestMetrics.Field{ImportPackage} : ImportDeclaration "import com.amazonaws.util.AWSRequestMetrics.Field;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Base64{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Base64;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.BinaryUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.BinaryUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.DateUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.DateUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.HttpUtils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.HttpUtils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.LengthCheckInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.LengthCheckInputStream;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.Md5Utils{ImportPackage} : ImportDeclaration "import com.amazonaws.util.Md5Utils;" compose:Replacement merge: SemanticConflict]
										[T -> com.amazonaws.util.ServiceClientHolderInputStream{ImportPackage} : ImportDeclaration "import com.amazonaws.util.ServiceClientHolderInputStream;" compose:Replacement merge: SemanticConflict]
										[NT -> AmazonS3Client : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface "class" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client : Id "AmazonS3Client" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AmazonWebServiceClient" compose:Replacement merge: SemanticConflict]
											[T -> ImplList : ImplementsList "implements AmazonS3" compose:Replacement merge: SemanticConflict]
											[T -> S3_SERVICE_NAME : FieldDecl "public static final String S3_SERVICE_NAME = "s3";" compose:Replacement merge: SemanticConflict]
											[T -> S3_SIGNER : FieldDecl "private static final String S3_SIGNER = "S3SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> S3_V4_SIGNER : FieldDecl "private static final String S3_V4_SIGNER = "AWSS3V4SignerType";" compose:Replacement merge: SemanticConflict]
											[T -> log : FieldDecl "private static Log log = LogFactory.getLog(AmazonS3Client.class);" compose:Replacement merge: SemanticConflict]
											[T -> auto6 : InitializerDecl "static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }" compose:Replacement merge: Default]
											[T -> errorResponseHandler : FieldDecl "private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();" compose:Replacement merge: SemanticConflict]
											[T -> voidResponseHandler : FieldDecl "private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);" compose:Replacement merge: SemanticConflict]
											[T -> bucketConfigurationXmlFactory : FieldDecl "private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> requestPaymentConfigurationXmlFactory : FieldDecl "private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();" compose:Replacement merge: SemanticConflict]
											[T -> clientOptions : FieldDecl "private S3ClientOptions clientOptions = new S3ClientOptions();" compose:Replacement merge: SemanticConflict]
											[T -> awsCredentialsProvider : FieldDecl "private AWSCredentialsProvider awsCredentialsProvider;" compose:Replacement merge: SemanticConflict]
											[T -> hasExplicitRegion : FieldDecl "private boolean hasExplicitRegion;" compose:Replacement merge: SemanticConflict]
											[T -> AmazonS3Client({FormalParametersInternal}) : ConstructorDecl "public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentials-AWSCredentials-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(AWSCredentialsProvider-AWSCredentialsProvider-ClientConfiguration-ClientConfiguration-RequestMetricCollector-RequestMetricCollector) : ConstructorDecl "public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     } " compose:Replacement merge: LineBased]
											[T -> AmazonS3Client(ClientConfiguration-ClientConfiguration) : ConstructorDecl "public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     } " compose:Replacement merge: LineBased]
											[T -> init({FormalParametersInternal}) : MethodDecl "private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     } " compose:Replacement merge: LineBased]
											[T -> setEndpoint(String-String) : MethodDecl "@Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     } " compose:Replacement merge: LineBased]
											[T -> setRegion(com.amazonaws.regions.Region-com.amazonaws.regions.Region) : MethodDecl "@Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     } " compose:Replacement merge: LineBased]
											[T -> setS3ClientOptions(S3ClientOptions-S3ClientOptions) : MethodDecl "public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     } " compose:Replacement merge: LineBased]
											[T -> listNextBatchOfVersions(VersionListing-VersionListing) : MethodDecl "public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     } " compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     } " compose:Replacement merge: LineBased]
											[T -> listVersions(String-String-String-String-String-String-String-String-String-String-Integer-Integer) : MethodDecl "public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     } " compose:Replacement merge: LineBased]
											[T -> listVersions(ListVersionsRequest-ListVersionsRequest) : MethodDecl "public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     } " compose:Replacement merge: LineBased]
											[T -> listObjects(String-String) : MethodDecl "public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     } " compose:Replacement merge: LineBased]
											[T -> listObjects(String-String-String-String) : MethodDecl "public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     } " compose:Replacement merge: LineBased]
											[T -> listObjects(ListObjectsRequest-ListObjectsRequest) : MethodDecl "public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     } " compose:Replacement merge: LineBased]
											[T -> listNextBatchOfObjects(ObjectListing-ObjectListing) : MethodDecl "public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     } " compose:Replacement merge: LineBased]
											[T -> getS3AccountOwner({FormalParametersInternal}) : MethodDecl "public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     } " compose:Replacement merge: LineBased]
											[T -> listBuckets(ListBucketsRequest-ListBucketsRequest) : MethodDecl "public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     } " compose:Replacement merge: LineBased]
											[T -> listBuckets({FormalParametersInternal}) : MethodDecl "public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     } " compose:Replacement merge: LineBased]
											[T -> getBucketLocation(GetBucketLocationRequest-GetBucketLocationRequest) : MethodDecl "public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketLocation(String-String) : MethodDecl "public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> createBucket(String-String) : MethodDecl "public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-Region-Region) : MethodDecl "public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     } " compose:Replacement merge: LineBased]
											[T -> createBucket(String-String-String-String) : MethodDecl "public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     } " compose:Replacement merge: LineBased]
											[T -> createBucket(CreateBucketRequest-CreateBucketRequest) : MethodDecl "public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     } " compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     } " compose:Replacement merge: LineBased]
											[T -> getObjectAcl(String-String-String-String-String-String) : MethodDecl "public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     } " compose:Replacement merge: LineBased]
											[T -> setObjectAcl0(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     } " compose:Replacement merge: LineBased]
											[T -> getBucketAcl(String-String) : MethodDecl "public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketAcl(GetBucketAclRequest-GetBucketAclRequest) : MethodDecl "public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-AccessControlList-AccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl(SetBucketAclRequest-SetBucketAclRequest) : MethodDecl "@Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList) : MethodDecl "@Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     } " compose:Replacement merge: LineBased]
											[T -> setBucketAcl0(String-String-CannedAccessControlList-CannedAccessControlList-RequestMetricCollector-RequestMetricCollector) : MethodDecl "private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     } " compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(String-String-String-String) : MethodDecl "public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     } " compose:Replacement merge: LineBased]
											[T -> getObjectMetadata(GetObjectMetadataRequest-GetObjectMetadataRequest) : MethodDecl "public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> getObject(String-String-String-String) : MethodDecl "public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     } " compose:Replacement merge: LineBased]
											[T -> doesBucketExist(String-String) : MethodDecl "public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     } " compose:Replacement merge: LineBased]
											[T -> headBucket(HeadBucketRequest-HeadBucketRequest) : MethodDecl "private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> changeObjectStorageClass(String-String-String-String-StorageClass-StorageClass) : MethodDecl "public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     } " compose:Replacement merge: LineBased]
											[T -> setObjectRedirectLocation(String-String-String-String-String-String) : MethodDecl "public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     } " compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest) : MethodDecl "public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     } " compose:Replacement merge: LineBased]
											[T -> getObject(GetObjectRequest-GetObjectRequest-File-File) : MethodDecl "public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     } " compose:Replacement merge: LineBased]
											[T -> skipContentMd5IntegrityCheck(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     } " compose:Replacement merge: LineBased]
											[T -> deleteBucket(String-String) : MethodDecl "public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> deleteBucket(DeleteBucketRequest-DeleteBucketRequest) : MethodDecl "public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-File-File) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     } " compose:Replacement merge: LineBased]
											[T -> putObject(String-String-String-String-InputStream-InputStream-ObjectMetadata-ObjectMetadata) : MethodDecl "public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     } " compose:Replacement merge: LineBased]
											[T -> putObject(PutObjectRequest-PutObjectRequest) : MethodDecl "// START putObject(PutObjectRequest-PutObjectRequest)//public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }  // LEFT //            if (metadata.getContentMD5() == null && !skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */ // RIGHT //            input = md5DigestStream = new MD5DigestCalculatingInputStream(input);         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result; // END putObject(PutObjectRequest-PutObjectRequest)//    }" compose:Replacement merge: LineBased]
											[T -> addAclHeaders(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-AccessControlList-AccessControlList) : MethodDecl "private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     } " compose:Replacement merge: LineBased]
											[T -> copyObject(String-String-String-String-String-String-String-String) : MethodDecl "public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     } " compose:Replacement merge: LineBased]
											[T -> copyObject(CopyObjectRequest-CopyObjectRequest) : MethodDecl "public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     } " compose:Replacement merge: LineBased]
											[T -> copyPart(CopyPartRequest-CopyPartRequest) : MethodDecl "public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     } " compose:Replacement merge: LineBased]
											[T -> deleteObject(String-String-String-String) : MethodDecl "public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     } " compose:Replacement merge: LineBased]
											[T -> deleteObject(DeleteObjectRequest-DeleteObjectRequest) : MethodDecl "public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     } " compose:Replacement merge: LineBased]
											[T -> deleteObjects(DeleteObjectsRequest-DeleteObjectsRequest) : MethodDecl "public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     } " compose:Replacement merge: LineBased]
											[T -> deleteVersion(String-String-String-String-String-String) : MethodDecl "public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     } " compose:Replacement merge: LineBased]
											[T -> deleteVersion(DeleteVersionRequest-DeleteVersionRequest) : MethodDecl "public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest-SetBucketVersioningConfigurationRequest) : MethodDecl "public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketVersioningConfiguration(String-String) : MethodDecl "public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(String-String) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest-GetBucketWebsiteConfigurationRequest) : MethodDecl "public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     } " compose:Replacement merge: LineBased]
											[T -> getBucketLifecycleConfiguration(String-String) : MethodDecl "public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     } " compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(String-String-BucketLifecycleConfiguration-BucketLifecycleConfiguration) : MethodDecl "public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     } " compose:Replacement merge: LineBased]
											[T -> setBucketLifecycleConfiguration(SetBucketLifecycleConfigurationRequest-SetBucketLifecycleConfigurationRequest) : MethodDecl "public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(String-String) : MethodDecl "public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketLifecycleConfiguration(DeleteBucketLifecycleConfigurationRequest-DeleteBucketLifecycleConfigurationRequest) : MethodDecl "public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketCrossOriginConfiguration(String-String) : MethodDecl "public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     } " compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(String-String-BucketCrossOriginConfiguration-BucketCrossOriginConfiguration) : MethodDecl "public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     } " compose:Replacement merge: LineBased]
											[T -> setBucketCrossOriginConfiguration(SetBucketCrossOriginConfigurationRequest-SetBucketCrossOriginConfigurationRequest) : MethodDecl "public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(String-String) : MethodDecl "public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       } " compose:Replacement merge: LineBased]
											[T -> deleteBucketCrossOriginConfiguration(DeleteBucketCrossOriginConfigurationRequest-DeleteBucketCrossOriginConfigurationRequest) : MethodDecl "public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketTaggingConfiguration(String-String) : MethodDecl "public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     } " compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(String-String-BucketTaggingConfiguration-BucketTaggingConfiguration) : MethodDecl "public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     } " compose:Replacement merge: LineBased]
											[T -> setBucketTaggingConfiguration(SetBucketTaggingConfigurationRequest-SetBucketTaggingConfigurationRequest) : MethodDecl "public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(String-String) : MethodDecl "public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketTaggingConfiguration(DeleteBucketTaggingConfigurationRequest-DeleteBucketTaggingConfigurationRequest) : MethodDecl "public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(String-String-BucketWebsiteConfiguration-BucketWebsiteConfiguration) : MethodDecl "public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     } " compose:Replacement merge: LineBased]
											[T -> setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest-SetBucketWebsiteConfigurationRequest) : MethodDecl "public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(String-String) : MethodDecl "public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest-DeleteBucketWebsiteConfigurationRequest) : MethodDecl "public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(String-String-BucketNotificationConfiguration-BucketNotificationConfiguration) : MethodDecl "public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     } " compose:Replacement merge: LineBased]
											[T -> setBucketNotificationConfiguration(SetBucketNotificationConfigurationRequest-SetBucketNotificationConfigurationRequest) : MethodDecl "public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketNotificationConfiguration(String-String) : MethodDecl "public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketLoggingConfiguration(String-String) : MethodDecl "public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest-SetBucketLoggingConfigurationRequest) : MethodDecl "public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(String-String) : MethodDecl "public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(String-String-String-String) : MethodDecl "public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(String-String) : MethodDecl "public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     } " compose:Replacement merge: LineBased]
											[T -> getBucketPolicy(GetBucketPolicyRequest-GetBucketPolicyRequest) : MethodDecl "public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     } " compose:Replacement merge: LineBased]
											[T -> setBucketPolicy(SetBucketPolicyRequest-SetBucketPolicyRequest) : MethodDecl "public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> deleteBucketPolicy(DeleteBucketPolicyRequest-DeleteBucketPolicyRequest) : MethodDecl "public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     } " compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(String-String-String-String-Date-Date-HttpMethod-HttpMethod) : MethodDecl "public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     } " compose:Replacement merge: LineBased]
											[T -> generatePresignedUrl(GeneratePresignedUrlRequest-GeneratePresignedUrlRequest) : MethodDecl "public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     } " compose:Replacement merge: LineBased]
											[T -> abortMultipartUpload(AbortMultipartUploadRequest-AbortMultipartUploadRequest) : MethodDecl "public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> completeMultipartUpload(CompleteMultipartUploadRequest-CompleteMultipartUploadRequest) : MethodDecl "public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     } " compose:Replacement merge: LineBased]
											[T -> initiateMultipartUpload(InitiateMultipartUploadRequest-InitiateMultipartUploadRequest) : MethodDecl "public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     } " compose:Replacement merge: LineBased]
											[T -> listMultipartUploads(ListMultipartUploadsRequest-ListMultipartUploadsRequest) : MethodDecl "public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     } " compose:Replacement merge: LineBased]
											[T -> listParts(ListPartsRequest-ListPartsRequest) : MethodDecl "public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     } " compose:Replacement merge: LineBased]
											[T -> uploadPart(UploadPartRequest-UploadPartRequest) : MethodDecl "public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             inputStream = md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 byte[] clientSideHash = md5DigestStream.getMd5Digest();                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     } " compose:Replacement merge: LineBased]
											[T -> getCachedResponseMetadata(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     } " compose:Replacement merge: LineBased]
											[T -> restoreObject(RestoreObjectRequest-RestoreObjectRequest) : MethodDecl "public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> restoreObject(String-String-String-String-int-int) : MethodDecl "public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     } " compose:Replacement merge: LineBased]
											[T -> assertParameterNotNull(Object-Object-String-String) : MethodDecl "private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     } " compose:Replacement merge: LineBased]
											[T -> fireProgressEvent(ProgressListenerCallbackExecutor-ProgressListenerCallbackExecutor-int-int) : MethodDecl "private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     } " compose:Replacement merge: LineBased]
											[T -> getAcl(String-String-String-String-String-String-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-CannedAccessControlList-CannedAccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> setAcl(String-String-String-String-String-String-AccessControlList-AccessControlList-AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> createSigner(Request<?>-Request<?>-String-String-String-String) : MethodDecl "protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     } " compose:Replacement merge: LineBased]
											[T -> upgradeToSigV4({FormalParametersInternal}) : MethodDecl "private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     } " compose:Replacement merge: LineBased]
											[T -> presignRequest(Request<T>-Request<T>-HttpMethod-HttpMethod-String-String-String-String-Date-Date-String-String) : MethodDecl "protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     } " compose:Replacement merge: LineBased]
											[T -> beforeRequest(Request<T>-Request<T>) : MethodDecl "private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     } " compose:Replacement merge: LineBased]
											[T -> convertToVirtualHostEndpoint(String-String) : MethodDecl "private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     } " compose:Replacement merge: LineBased]
											[T -> populateRequestMetadata(Request<?>-Request<?>-ObjectMetadata-ObjectMetadata) : MethodDecl "protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     } " compose:Replacement merge: LineBased]
											[T -> populateRequestWithMfaDetails(Request<?>-Request<?>-MultiFactorAuthentication-MultiFactorAuthentication) : MethodDecl "private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     } " compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyObjectParameters(Request<?extendsAmazonWebServiceRequest>-Request<?extendsAmazonWebServiceRequest>-CopyObjectRequest-CopyObjectRequest) : MethodDecl "private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     } " compose:Replacement merge: LineBased]
											[T -> populateRequestWithCopyPartParameters(Request<?>-Request<?>-CopyPartRequest-CopyPartRequest) : MethodDecl "private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     } " compose:Replacement merge: LineBased]
											[T -> populateSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     } " compose:Replacement merge: LineBased]
											[T -> populateSourceSseCpkRequestParameters(Request<?>-Request<?>-SSECustomerKey-SSECustomerKey) : MethodDecl "private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     } " compose:Replacement merge: LineBased]
											[T -> addHeaderIfNotNull(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     } " compose:Replacement merge: LineBased]
											[T -> addDateHeader(Request<?>-Request<?>-String-String-Date-Date) : MethodDecl "private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     } " compose:Replacement merge: LineBased]
											[T -> addStringListHeader(Request<?>-Request<?>-String-String-List<String>-List<String>) : MethodDecl "private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     } " compose:Replacement merge: LineBased]
											[T -> addResponseHeaderParameters(Request<?>-Request<?>-ResponseHeaderOverrides-ResponseHeaderOverrides) : MethodDecl "private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     } " compose:Replacement merge: LineBased]
											[T -> getResourceUrl(String-String-String-String) : MethodDecl "public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     } " compose:Replacement merge: LineBased]
											[T -> getUrl(String-String-String-String) : MethodDecl "public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     } " compose:Replacement merge: LineBased]
											[T -> getRegion({FormalParametersInternal}) : MethodDecl "public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     } " compose:Replacement merge: LineBased]
											[T -> createRequest(String-String-String-String-X-X-HttpMethodName-HttpMethodName) : MethodDecl "protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     } " compose:Replacement merge: LineBased]
											[T -> configRequest(Request<?>-Request<?>-String-String-String-String) : MethodDecl "private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     } " compose:Replacement merge: LineBased]
											[T -> validIP(String-String) : MethodDecl "private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     } " compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-Unmarshaller<X,InputStream>-Unmarshaller<X,InputStream>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     } " compose:Replacement merge: LineBased]
											[T -> createExecutionContext(AmazonWebServiceRequest-AmazonWebServiceRequest) : MethodDecl "@Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     } " compose:Replacement merge: LineBased]
											[T -> invoke(Request<Y>-Request<Y>-HttpResponseHandler<AmazonWebServiceResponse<X>>-HttpResponseHandler<AmazonWebServiceResponse<X>>-String-String-String-String) : MethodDecl "private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    } " compose:Replacement merge: LineBased]
											[T -> enableRequesterPays(String-String) : MethodDecl "@Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     } " compose:Replacement merge: LineBased]
											[T -> disableRequesterPays(String-String) : MethodDecl "@Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     } " compose:Replacement merge: LineBased]
											[T -> isRequesterPaysEnabled(String-String) : MethodDecl "@Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     } " compose:Replacement merge: LineBased]
											[T -> setBucketRequestPayment(SetRequestPaymentConfigurationRequest-SetRequestPaymentConfigurationRequest) : MethodDecl "private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     } " compose:Replacement merge: LineBased]
											[T -> getBucketRequestPayment(GetRequestPaymentConfigurationRequest-GetRequestPaymentConfigurationRequest) : MethodDecl "private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      } " compose:Replacement merge: LineBased]
											[T -> setZeroContentLength(Request<?>-Request<?>) : MethodDecl "private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));    } " compose:Replacement merge: LineBased]
											[T -> auto4 : InitializerDecl "static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }" compose:Replacement merge: Default]
[NT -> rev_left_7ab10 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java.merge : .java.merge-File]
									[T -> AmazonS3Client.java : .java-Content "/*  * Copyright 2010-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.services.s3;  import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES; import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;  import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.InputStream; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.regex.Matcher;  import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.http.client.methods.HttpRequestBase;  import com.amazonaws.AbortedException; import com.amazonaws.AmazonClientException; import com.amazonaws.AmazonServiceException; import com.amazonaws.AmazonServiceException.ErrorType; import com.amazonaws.AmazonWebServiceClient; import com.amazonaws.AmazonWebServiceRequest; import com.amazonaws.AmazonWebServiceResponse; import com.amazonaws.ClientConfiguration; import com.amazonaws.DefaultRequest; import com.amazonaws.HttpMethod; import com.amazonaws.Request; import com.amazonaws.Response; import com.amazonaws.SDKGlobalConfiguration; import com.amazonaws.auth.AWSCredentials; import com.amazonaws.auth.AWSCredentialsProvider; import com.amazonaws.auth.AWSCredentialsProviderChain; import com.amazonaws.auth.DefaultAWSCredentialsProviderChain; import com.amazonaws.auth.EnvironmentVariableCredentialsProvider; import com.amazonaws.auth.InstanceProfileCredentialsProvider; import com.amazonaws.auth.Presigner; import com.amazonaws.auth.Signer; import com.amazonaws.auth.SignerFactory; import com.amazonaws.auth.SystemPropertiesCredentialsProvider; import com.amazonaws.auth.profile.ProfileCredentialsProvider; import com.amazonaws.event.ProgressEvent; import com.amazonaws.event.ProgressListener; import com.amazonaws.event.ProgressListenerCallbackExecutor; import com.amazonaws.event.ProgressReportingInputStream; import com.amazonaws.handlers.HandlerChainFactory; import com.amazonaws.handlers.RequestHandler2; import com.amazonaws.http.ExecutionContext; import com.amazonaws.http.HttpMethodName; import com.amazonaws.http.HttpResponseHandler; import com.amazonaws.internal.StaticCredentialsProvider; import com.amazonaws.metrics.AwsSdkMetrics; import com.amazonaws.metrics.RequestMetricCollector; import com.amazonaws.regions.RegionUtils; import com.amazonaws.services.s3.internal.AWSS3V4Signer; import com.amazonaws.services.s3.internal.BucketNameUtils; import com.amazonaws.services.s3.internal.Constants; import com.amazonaws.services.s3.internal.DeleteObjectsResponse; import com.amazonaws.services.s3.internal.DigestValidationInputStream; import com.amazonaws.services.s3.internal.InputSubstream; import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream; import com.amazonaws.services.s3.internal.Mimetypes; import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler; import com.amazonaws.services.s3.internal.RepeatableFileInputStream; import com.amazonaws.services.s3.internal.RepeatableInputStream; import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain; import com.amazonaws.services.s3.internal.S3ErrorResponseHandler; import com.amazonaws.services.s3.internal.S3ExecutionContext; import com.amazonaws.services.s3.internal.S3MetadataResponseHandler; import com.amazonaws.services.s3.internal.S3ObjectResponseHandler; import com.amazonaws.services.s3.internal.S3QueryStringSigner; import com.amazonaws.services.s3.internal.S3Signer; import com.amazonaws.services.s3.internal.S3StringResponseHandler; import com.amazonaws.services.s3.internal.S3VersionHeaderHandler; import com.amazonaws.services.s3.internal.S3XmlResponseHandler; import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler; import com.amazonaws.services.s3.internal.ServiceUtils; import com.amazonaws.services.s3.internal.XmlWriter; import com.amazonaws.services.s3.metrics.S3ServiceMetric; import com.amazonaws.services.s3.model.AbortMultipartUploadRequest; import com.amazonaws.services.s3.model.AccessControlList; import com.amazonaws.services.s3.model.AmazonS3Exception; import com.amazonaws.services.s3.model.Bucket; import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration; import com.amazonaws.services.s3.model.BucketLifecycleConfiguration; import com.amazonaws.services.s3.model.BucketLoggingConfiguration; import com.amazonaws.services.s3.model.BucketNotificationConfiguration; import com.amazonaws.services.s3.model.BucketPolicy; import com.amazonaws.services.s3.model.BucketTaggingConfiguration; import com.amazonaws.services.s3.model.BucketVersioningConfiguration; import com.amazonaws.services.s3.model.BucketWebsiteConfiguration; import com.amazonaws.services.s3.model.CannedAccessControlList; import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest; import com.amazonaws.services.s3.model.CompleteMultipartUploadResult; import com.amazonaws.services.s3.model.CopyObjectRequest; import com.amazonaws.services.s3.model.CopyObjectResult; import com.amazonaws.services.s3.model.CopyPartRequest; import com.amazonaws.services.s3.model.CopyPartResult; import com.amazonaws.services.s3.model.CreateBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest; import com.amazonaws.services.s3.model.DeleteBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.DeleteObjectRequest; import com.amazonaws.services.s3.model.DeleteObjectsRequest; import com.amazonaws.services.s3.model.DeleteObjectsResult; import com.amazonaws.services.s3.model.DeleteVersionRequest; import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest; import com.amazonaws.services.s3.model.GenericBucketRequest; import com.amazonaws.services.s3.model.GetBucketAclRequest; import com.amazonaws.services.s3.model.GetBucketLocationRequest; import com.amazonaws.services.s3.model.GetBucketPolicyRequest; import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.GetObjectMetadataRequest; import com.amazonaws.services.s3.model.GetObjectRequest; import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.Grant; import com.amazonaws.services.s3.model.Grantee; import com.amazonaws.services.s3.model.GroupGrantee; import com.amazonaws.services.s3.model.HeadBucketRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadResult; import com.amazonaws.services.s3.model.ListBucketsRequest; import com.amazonaws.services.s3.model.ListMultipartUploadsRequest; import com.amazonaws.services.s3.model.ListObjectsRequest; import com.amazonaws.services.s3.model.ListPartsRequest; import com.amazonaws.services.s3.model.ListVersionsRequest; import com.amazonaws.services.s3.model.MultiFactorAuthentication; import com.amazonaws.services.s3.model.MultiObjectDeleteException; import com.amazonaws.services.s3.model.MultipartUploadListing; import com.amazonaws.services.s3.model.ObjectListing; import com.amazonaws.services.s3.model.ObjectMetadata; import com.amazonaws.services.s3.model.Owner; import com.amazonaws.services.s3.model.PartListing; import com.amazonaws.services.s3.model.Permission; import com.amazonaws.services.s3.model.PutObjectRequest; import com.amazonaws.services.s3.model.PutObjectResult; import com.amazonaws.services.s3.model.Region; import com.amazonaws.services.s3.model.RequestPaymentConfiguration; import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer; import com.amazonaws.services.s3.model.ResponseHeaderOverrides; import com.amazonaws.services.s3.model.RestoreObjectRequest; import com.amazonaws.services.s3.model.S3Object; import com.amazonaws.services.s3.model.S3ObjectInputStream; import com.amazonaws.services.s3.model.SSECustomerKey; import com.amazonaws.services.s3.model.SetBucketAclRequest; import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketPolicyRequest; import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.StorageClass; import com.amazonaws.services.s3.model.UploadPartRequest; import com.amazonaws.services.s3.model.UploadPartResult; import com.amazonaws.services.s3.model.VersionListing; import com.amazonaws.services.s3.model.transform.AclXmlFactory; import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory; import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.RequestXmlFactory; import com.amazonaws.services.s3.model.transform.Unmarshallers; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler; import com.amazonaws.transform.Unmarshaller; import com.amazonaws.util.AWSRequestMetrics; import com.amazonaws.util.AWSRequestMetrics.Field; import com.amazonaws.util.Base64; import com.amazonaws.util.BinaryUtils; import com.amazonaws.util.DateUtils; import com.amazonaws.util.HttpUtils; import com.amazonaws.util.LengthCheckInputStream; import com.amazonaws.util.Md5Utils; import com.amazonaws.util.ServiceClientHolderInputStream;  /**  * <p>  * Provides the client for accessing the Amazon S3 web service.  * </p>  * <p>  * Amazon S3 provides storage for the Internet,  * and is designed to make web-scale computing easier for developers.  * </p>  * <p>  * The Amazon S3 Java Client provides a simple interface that can be  * used to store and retrieve any amount of data, at any time,  * from anywhere on the web. It gives any developer access to the same  * highly scalable, reliable, secure, fast, inexpensive infrastructure  * that Amazon uses to run its own global network of web sites.  * The service aims to maximize benefits of scale and to pass those  * benefits on to developers.  * </p>  * <p>  * For more information about Amazon S3, please see  * <a href="http://aws.amazon.com/s3">  * http://aws.amazon.com/s3</a>  * </p>  */ public class AmazonS3Client extends AmazonWebServiceClient implements AmazonS3 {      public static final String S3_SERVICE_NAME = "s3";      private static final String S3_SIGNER = "S3SignerType";     private static final String S3_V4_SIGNER = "AWSS3V4SignerType";      /** Shared logger for client events */     private static Log log = LogFactory.getLog(AmazonS3Client.class);      static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }      /** Responsible for handling error responses from all S3 service calls. */     private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();      /** Shared response handler for operations with no response.  */     private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);      /** Shared factory for converting configuration objects to XML */     private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();      /** Shared factory for converting request payment configuration objects to XML */     private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();      /** S3 specific client configuration options */     private S3ClientOptions clientOptions = new S3ClientOptions();      /** Provider for AWS credentials. */     private AWSCredentialsProvider awsCredentialsProvider;      /** Whether or not this client has an explicit region configured. */     private boolean hasExplicitRegion;      /**      * Constructs a new client to invoke service methods on Amazon S3. A      * credentials provider chain will be used that searches for credentials in      * this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Credential profiles file at the default location (~/.aws/credentials) shared by all AWS SDKs and the AWS CLI</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i> requests,      * but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the credentials      * provider chain, by passing in <code>null</code> for the credentials.      * </p>      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials to      * access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      */     public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials      * provider to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials,      * client configuration and request metric collector to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      * @param requestMetricCollector request metric collector      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }      /**      * Constructs a new client using the specified client configuration to      * access Amazon S3. A credentials provider chain will be used that searches      * for credentials in this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i>      * requests, but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the      * credentials provider chain, by passing in <code>null</code> for the      * credentials.      * </p>      *      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }      private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }      @Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }      @Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }       /**      * <p>      * Override the default S3 client options for this client.      * </p>      * @param clientOptions      *            The S3 client options to use.      */     public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfVersions(com.amazonaws.services.s3.model.S3VersionListing)      */     public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String)      */     public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Integer)      */     public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(com.amazonaws.services.s3.model.ListVersionsRequest)      */     public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String)      */     public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String, java.lang.String)      */     public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(com.amazonaws.services.s3.model.ListObjectsRequest)      */     public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfObjects(com.amazonaws.services.s3.model.S3ObjectListing)      */     public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getS3AccountOwner()      */     public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(com.amazonaws.services.s3.AmazonS3Client.GetBucketLocationRequest)      */     public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(java.lang.String)      */     public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucketjava.lang.String)      */     public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, com.amazonaws.services.s3.model.Region)      */     public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, java.lang.String)      */     public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(com.amazonaws.services.s3.model.CreateBucketRequest)      */     public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }      @Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(java.lang.String)      */     public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(com.amazonaws.services.s3.GetBucketAclRequest)      */     public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }      @Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }      @Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(java.lang.String, java.lang.String)      */     public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(com.amazonaws.services.s3.model.GetObjectMetadataRequest)      */     public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(java.lang.String, java.lang.String)      */     public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#doesBucketExist(java.lang.String)      */     public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }       /**      * Performs a head bucket operation on the requested bucket name. This is      * done to check if the bucket exists and the user has permissions to access      * it.      *      * @param headBucketRequest The request containing the bucket name.      * @throws AmazonClientException      * @throws AmazonServiceException      */     private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#changeStorageClass(java.lang.String, java.lang.String, java.lang.String)      */     public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setObjectRedirectLocation(java.lang.String, java.lang.String, java.lang.String)      */     public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest)      */     public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest, java.io.File)      */     public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }      /**      * Returns whether the specified request should skip MD5 check on the      * requested object content.      */     private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(java.lang.String)      */     public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(com.amazonaws.services.s3.model.DeleteBucketRequest)      */     public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.File)      */     public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.InputStream, com.amazonaws.services.s3.model.S3ObjectMetadata)      */     public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(com.amazonaws.services.s3.model.PutObjectRequest)      */     public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (metadata.getContentMD5() == null && !skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(input);                 input = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }      /**      * Sets the acccess control headers for the request given.      */     private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(java.lang.String, java.lang.String, java.lang.String, java.lang.String)      */     public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(com.amazonaws.services.s3.model.CopyObjectRequest)      */     public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }      /**      * Copies a source object to a part of a multipart upload.      *      * To copy an object, the caller's account must have read access to the source object and      * write access to the destination bucket.      * </p>      * <p>      * If constraints are specified in the <code>CopyPartRequest</code>      * (e.g.      * {@link CopyPartRequest#setMatchingETagConstraints(List)})      * and are not satisfied when Amazon S3 receives the      * request, this method returns <code>null</code>.      * This method returns a non-null result under all other      * circumstances.      * </p>      *      * @param copyPartRequest      *            The request object containing all the options for copying an      *            Amazon S3 object.      *      * @return A {@link CopyPartResult} object containing the information      *         returned by Amazon S3 about the newly created object, or <code>null</code> if      *         constraints were specified that weren't met when Amazon S3 attempted      *         to copy the object.      *      * @throws AmazonClientException      *             If any errors are encountered in the client while making the      *             request or handling the response.      * @throws AmazonServiceException      *             If any errors occurred in Amazon S3 while processing the      *             request.      *      * @see AmazonS3#copyObject(CopyObjectRequest)      * @see AmazonS3#initiateMultipartUpload(InitiateMultipartUploadRequest)      */     public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(java.lang.String, java.lang.String)      */     public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(com.amazonaws.services.s3.DeleteObjectRequest)      */     public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjects(com.amazonaws.services.s3.model.DeleteObjectsRequest)      */     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjectVersion(java.lang.String, java.lang.String, java.lang.String)      */     public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteVersion(com.amazonaws.services.s3.model.DeleteVersionRequest)      */     public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketVersioningConfiguration(com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest)      */     public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketVersioningConfiguration(java.lang.String)      */     public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(java.lang.String)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLifecycleConfiguration(java.lang.String)      */     public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest)      */     public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(java.lang.String)      */     public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest)      */     public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketCrossOriginConfiguration(java.lang.String)      */     public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketCrossOriginConfiguration)      */     public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest)      */     public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(java.lang.String)      */     public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest)      */     public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketTaggingConfiguration(java.lang.String)      */     public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest)      */     public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(java.lang.String)      */     public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest)      */     public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketWebsiteConfiguration)      */     public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest)      */     public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(java.lang.String)      */     public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest)      */     public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(java.lang.String,com.amazonaws.services.s3.model.BucketNotificationConfiguration)      */     public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest)      */     public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketNotificationConfiguration(java.lang.String)      */     public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLoggingConfiguration(java.lang.String)      */     public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLoggingConfiguration(com.amazonaws.services.s3.SetBucketLoggingConfigurationRequest)      */     public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(java.lang.String)      */     public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(java.lang.String, java.lang.String)      */     public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(java.lang.String)      */     public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(com.amazonaws.services.s3.model.GetBucketPolicyRequest)      */     public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(com.amazonaws.services.s3.model.SetBucketPolicyRequest)      */     public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(com.amazonaws.services.s3.model.DeleteBucketPolicyRequest)      */     public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }        /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date, com.amazonaws.HttpMethod)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(com.amazonaws.services.s3.model.GeneratePresignedUrlRequest)      */     public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#abortMultipartUpload(com.amazonaws.services.s3.model.AbortMultipartUploadRequest)      */     public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#completeMultipartUpload(com.amazonaws.services.s3.model.CompleteMultipartUploadRequest)      */     public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#initiateMultipartUpload(com.amazonaws.services.s3.model.InitiateMultipartUploadRequest)      */     public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listMultipartUploads(com.amazonaws.services.s3.model.ListMultipartUploadsRequest)      */     public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listParts(com.amazonaws.services.s3.model.ListPartsRequest)      */     public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#uploadPart(com.amazonaws.services.s3.model.UploadPartRequest)      */     public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);                 inputStream = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 String contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());                 byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getResponseMetadataForRequest(com.amazonaws.AmazonWebServiceRequest)      */     public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#restoreObject(com.amazonaws.services.s3.model.RestoreObjectRequest)      */     public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }      /** (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyGlacierObject((java.lang.String, java.lang.String, int)      */     public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }       /*      * Private Interface      */      /**      * <p>      * Asserts that the specified parameter value is not <code>null</code> and if it is,      * throws an <code>IllegalArgumentException</code> with the specified error message.      * </p>      *      * @param parameterValue      *            The parameter value being checked.      * @param errorMessage      *            The error message to include in the IllegalArgumentException      *            if the specified parameter is null.      */     private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }       /**      * Fires a progress event with the specified event type to the specified      * listener.      *      * @param progressListenerCallbackExecutor      *            The listener callback executor.      * @param eventType      *            The type of event to fire.      */     private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }      /**      * <p>      * Gets the Amazon S3 {@link AccessControlList} (ACL) for the specified resource.      * (bucket if only the bucketName parameter is specified, otherwise the object with the      * specified key in the bucket).      * </p>      *      * @param bucketName      *            The name of the bucket whose ACL should be returned if the key      *            parameter is not specified, otherwise the bucket containing      *            the specified key.      * @param key      *            The object key whose ACL should be retrieve. If not specified,      *            the bucket's ACL is returned.      * @param versionId      *            The version ID of the object version whose ACL is being      *            retrieved.      * @param originalRequest      *            The original, user facing request object.      *      * @return The S3 ACL for the specified resource.      */     private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }      /**      * Sets the Canned ACL for the specified resource in S3. If only bucketName      * is specified, the canned ACL will be applied to the bucket, otherwise if      * bucketName and key are specified, the canned ACL will be applied to the      * object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param cannedAcl      *            The canned ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Sets the ACL for the specified resource in S3. If only bucketName is      * specified, the ACL will be applied to the bucket, otherwise if bucketName      * and key are specified, the ACL will be applied to the object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param acl      *            The ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Returns a "complete" S3 specific signer, taking into the S3 bucket, key,      * and the current S3 client configuration into account.      */     protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }      private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }      /**      * Pre-signs the specified request, using a signature query-string      * parameter.      *      * @param request      *            The request to sign.      * @param methodName      *            The HTTP method (GET, PUT, DELETE, HEAD) for the specified      *            request.      * @param bucketName      *            The name of the bucket involved in the request. If the request      *            is not an operation on a bucket this parameter should be null.      * @param key      *            The object key involved in the request. If the request is not      *            an operation on an object, this parameter should be null.      * @param expiration      *            The time at which the signed request is no longer valid, and      *            will stop working.      * @param subResource      *            The optional sub-resource being requested as part of the      *            request (e.g. "location", "acl", "logging", or "torrent").      */     protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }      private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }      /**      * Converts the current endpoint set for this client into virtual addressing      * style, by placing the name of the specified bucket before the S3 service      * endpoint.      *      * @param bucketName      *            The name of the bucket to use in the virtual addressing style      *            of the returned URI.      *      * @return A new URI, creating from the current service endpoint URI and the      *         specified bucket.      */     private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }      /**      * <p>      * Populates the specified request object with the appropriate headers from      * the {@link ObjectMetadata} object.      * </p>      *      * @param request      *            The request to populate with headers.      * @param metadata      *            The metadata containing the header information to include in      *            the request.      */     protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }      /**      * <p>      * Populates the specified request with the specified Multi-Factor      * Authentication (MFA) details. This includes the MFA header with device serial      * number and generated token. Since all requests which include the MFA      * header must be sent over HTTPS, this operation also configures the request object to      * use HTTPS instead of HTTP.      * </p>      *      * @param request      *            The request to populate.      * @param mfa      *            The Multi-Factor Authentication information.      */     private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyObjectRequest</code> object.      * @param copyObjectRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyPartRequest</code> object.      * @param copyPartRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous attributes available in      * <code>SSEWithCustomerKeyRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the      *            <code>ServerSideEncryptionWithCustomerKeyRequest</code>      *            object.      * @param sseCpkRequest      *            The request object for an S3 operation that allows server-side      *            encryption using customer-provided keys.      */     private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      /**      * Adds the specified header to the specified request, if the header value      * is not null.      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }      /**      * <p>      * Adds the specified date header in RFC 822 date format to the specified      * request.      * This method will not add a date header if the specified date value is <code>null</code>.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }      /**      * <p>      * Adds the specified string list header, joined together separated with      * commas, to the specified request.      * This method will not add a string list header if the specified values      * are <code>null</code> or empty.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param values      *            The list of strings to join together for the header value.      */     private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }      /**      * <p>      * Adds response headers parameters to the request given, if non-null.      * </p>      *      * @param request      *            The request to add the response header parameters to.      * @param responseHeaders      *            The full set of response headers to add, or null for none.      */     private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }      /**      * Returns the URL to the key in the bucket given, using the client's scheme      * and endpoint. Returns null if the given bucket and key cannot be      * converted to a URL.      */     public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }      /**      * Returns an URL for the object stored in the specified bucket and      * key.      * <p>      * If the object identified by the given bucket and key has public read      * permissions (ex: {@link CannedAccessControlList#PublicRead}), then this      * URL can be directly accessed to retrieve the object's data.      *      * @param bucketName      *            The name of the bucket containing the object whose URL is      *            being requested.      * @param key      *            The key under which the object whose URL is being requested is      *            stored.      *      * @return A unique URL for the object stored in the specified bucket and      *         key.      */     public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }      public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }      /**      * Creates and initializes a new request object for the specified S3      * resource. This method is responsible for determining the right way to      * address resources. For example, bucket names that are not DNS addressable      * cannot be addressed in V2, virtual host, style, and instead must use V1,      * path style. The returned request object has the service name, endpoint      * and resource path correctly populated. Callers can take the request, add      * any additional headers or parameters, then sign and execute the request.      *      * @param bucketName      *            An optional parameter indicating the name of the bucket      *            containing the resource involved in the request.      * @param key      *            An optional parameter indicating the key under which the      *            desired resource is stored in the specified bucket.      * @param originalRequest      *            The original request, as created by the user.      * @param httpMethod      *            The HTTP method to use when sending the request.      *      * @return A new request object, populated with endpoint, resource path, and      *         service name, ready for callers to populate any additional      *         headers or parameters, and execute.      */     protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }      /**      * Configure the given request with the specified bucket name and key.      * @return the request configured      */     private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }      private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }      @Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#enableRequesterPays(java.lang.String)      */     @Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#disableRequesterPays(java.lang.String)      */     @Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#isRequesterPaysEnabled(java.lang.String)      */     @Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }      /**      * Sets the request payment configuration for a given Amazon S3 bucket.      * This operation can be done only by the owner of the Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is set to      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /**      * Retrieves the request payment configuration for a given Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }      private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));    } } " compose:StringConcatenation merge: LineBased]
[NT -> rev_base_f9d63 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java.merge : .java.merge-File]
									[T -> AmazonS3Client.java : .java-Content "/*  * Copyright 2010-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.services.s3;  import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES; import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;  import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.InputStream; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.regex.Matcher;  import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.http.client.methods.HttpRequestBase;  import com.amazonaws.AbortedException; import com.amazonaws.AmazonClientException; import com.amazonaws.AmazonServiceException; import com.amazonaws.AmazonServiceException.ErrorType; import com.amazonaws.AmazonWebServiceClient; import com.amazonaws.AmazonWebServiceRequest; import com.amazonaws.AmazonWebServiceResponse; import com.amazonaws.ClientConfiguration; import com.amazonaws.DefaultRequest; import com.amazonaws.HttpMethod; import com.amazonaws.Request; import com.amazonaws.Response; import com.amazonaws.SDKGlobalConfiguration; import com.amazonaws.auth.AWSCredentials; import com.amazonaws.auth.AWSCredentialsProvider; import com.amazonaws.auth.AWSCredentialsProviderChain; import com.amazonaws.auth.DefaultAWSCredentialsProviderChain; import com.amazonaws.auth.EnvironmentVariableCredentialsProvider; import com.amazonaws.auth.InstanceProfileCredentialsProvider; import com.amazonaws.auth.Presigner; import com.amazonaws.auth.Signer; import com.amazonaws.auth.SignerFactory; import com.amazonaws.auth.SystemPropertiesCredentialsProvider; import com.amazonaws.auth.profile.ProfileCredentialsProvider; import com.amazonaws.event.ProgressEvent; import com.amazonaws.event.ProgressListener; import com.amazonaws.event.ProgressListenerCallbackExecutor; import com.amazonaws.event.ProgressReportingInputStream; import com.amazonaws.handlers.HandlerChainFactory; import com.amazonaws.handlers.RequestHandler2; import com.amazonaws.http.ExecutionContext; import com.amazonaws.http.HttpMethodName; import com.amazonaws.http.HttpResponseHandler; import com.amazonaws.internal.StaticCredentialsProvider; import com.amazonaws.metrics.AwsSdkMetrics; import com.amazonaws.metrics.RequestMetricCollector; import com.amazonaws.regions.RegionUtils; import com.amazonaws.services.s3.internal.AWSS3V4Signer; import com.amazonaws.services.s3.internal.BucketNameUtils; import com.amazonaws.services.s3.internal.Constants; import com.amazonaws.services.s3.internal.DeleteObjectsResponse; import com.amazonaws.services.s3.internal.DigestValidationInputStream; import com.amazonaws.services.s3.internal.InputSubstream; import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream; import com.amazonaws.services.s3.internal.Mimetypes; import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler; import com.amazonaws.services.s3.internal.RepeatableFileInputStream; import com.amazonaws.services.s3.internal.RepeatableInputStream; import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain; import com.amazonaws.services.s3.internal.S3ErrorResponseHandler; import com.amazonaws.services.s3.internal.S3ExecutionContext; import com.amazonaws.services.s3.internal.S3MetadataResponseHandler; import com.amazonaws.services.s3.internal.S3ObjectResponseHandler; import com.amazonaws.services.s3.internal.S3QueryStringSigner; import com.amazonaws.services.s3.internal.S3Signer; import com.amazonaws.services.s3.internal.S3StringResponseHandler; import com.amazonaws.services.s3.internal.S3VersionHeaderHandler; import com.amazonaws.services.s3.internal.S3XmlResponseHandler; import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler; import com.amazonaws.services.s3.internal.ServiceUtils; import com.amazonaws.services.s3.internal.XmlWriter; import com.amazonaws.services.s3.metrics.S3ServiceMetric; import com.amazonaws.services.s3.model.AbortMultipartUploadRequest; import com.amazonaws.services.s3.model.AccessControlList; import com.amazonaws.services.s3.model.AmazonS3Exception; import com.amazonaws.services.s3.model.Bucket; import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration; import com.amazonaws.services.s3.model.BucketLifecycleConfiguration; import com.amazonaws.services.s3.model.BucketLoggingConfiguration; import com.amazonaws.services.s3.model.BucketNotificationConfiguration; import com.amazonaws.services.s3.model.BucketPolicy; import com.amazonaws.services.s3.model.BucketTaggingConfiguration; import com.amazonaws.services.s3.model.BucketVersioningConfiguration; import com.amazonaws.services.s3.model.BucketWebsiteConfiguration; import com.amazonaws.services.s3.model.CannedAccessControlList; import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest; import com.amazonaws.services.s3.model.CompleteMultipartUploadResult; import com.amazonaws.services.s3.model.CopyObjectRequest; import com.amazonaws.services.s3.model.CopyObjectResult; import com.amazonaws.services.s3.model.CopyPartRequest; import com.amazonaws.services.s3.model.CopyPartResult; import com.amazonaws.services.s3.model.CreateBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest; import com.amazonaws.services.s3.model.DeleteBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.DeleteObjectRequest; import com.amazonaws.services.s3.model.DeleteObjectsRequest; import com.amazonaws.services.s3.model.DeleteObjectsResult; import com.amazonaws.services.s3.model.DeleteVersionRequest; import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest; import com.amazonaws.services.s3.model.GenericBucketRequest; import com.amazonaws.services.s3.model.GetBucketAclRequest; import com.amazonaws.services.s3.model.GetBucketLocationRequest; import com.amazonaws.services.s3.model.GetBucketPolicyRequest; import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.GetObjectMetadataRequest; import com.amazonaws.services.s3.model.GetObjectRequest; import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.Grant; import com.amazonaws.services.s3.model.Grantee; import com.amazonaws.services.s3.model.GroupGrantee; import com.amazonaws.services.s3.model.HeadBucketRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadResult; import com.amazonaws.services.s3.model.ListBucketsRequest; import com.amazonaws.services.s3.model.ListMultipartUploadsRequest; import com.amazonaws.services.s3.model.ListObjectsRequest; import com.amazonaws.services.s3.model.ListPartsRequest; import com.amazonaws.services.s3.model.ListVersionsRequest; import com.amazonaws.services.s3.model.MultiFactorAuthentication; import com.amazonaws.services.s3.model.MultiObjectDeleteException; import com.amazonaws.services.s3.model.MultipartUploadListing; import com.amazonaws.services.s3.model.ObjectListing; import com.amazonaws.services.s3.model.ObjectMetadata; import com.amazonaws.services.s3.model.Owner; import com.amazonaws.services.s3.model.PartListing; import com.amazonaws.services.s3.model.Permission; import com.amazonaws.services.s3.model.PutObjectRequest; import com.amazonaws.services.s3.model.PutObjectResult; import com.amazonaws.services.s3.model.Region; import com.amazonaws.services.s3.model.RequestPaymentConfiguration; import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer; import com.amazonaws.services.s3.model.ResponseHeaderOverrides; import com.amazonaws.services.s3.model.RestoreObjectRequest; import com.amazonaws.services.s3.model.S3Object; import com.amazonaws.services.s3.model.S3ObjectInputStream; import com.amazonaws.services.s3.model.SSECustomerKey; import com.amazonaws.services.s3.model.SetBucketAclRequest; import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketPolicyRequest; import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.StorageClass; import com.amazonaws.services.s3.model.UploadPartRequest; import com.amazonaws.services.s3.model.UploadPartResult; import com.amazonaws.services.s3.model.VersionListing; import com.amazonaws.services.s3.model.transform.AclXmlFactory; import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory; import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.RequestXmlFactory; import com.amazonaws.services.s3.model.transform.Unmarshallers; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler; import com.amazonaws.transform.Unmarshaller; import com.amazonaws.util.AWSRequestMetrics; import com.amazonaws.util.AWSRequestMetrics.Field; import com.amazonaws.util.Base64; import com.amazonaws.util.BinaryUtils; import com.amazonaws.util.DateUtils; import com.amazonaws.util.HttpUtils; import com.amazonaws.util.LengthCheckInputStream; import com.amazonaws.util.Md5Utils; import com.amazonaws.util.ServiceClientHolderInputStream;  /**  * <p>  * Provides the client for accessing the Amazon S3 web service.  * </p>  * <p>  * Amazon S3 provides storage for the Internet,  * and is designed to make web-scale computing easier for developers.  * </p>  * <p>  * The Amazon S3 Java Client provides a simple interface that can be  * used to store and retrieve any amount of data, at any time,  * from anywhere on the web. It gives any developer access to the same  * highly scalable, reliable, secure, fast, inexpensive infrastructure  * that Amazon uses to run its own global network of web sites.  * The service aims to maximize benefits of scale and to pass those  * benefits on to developers.  * </p>  * <p>  * For more information about Amazon S3, please see  * <a href="http://aws.amazon.com/s3">  * http://aws.amazon.com/s3</a>  * </p>  */ public class AmazonS3Client extends AmazonWebServiceClient implements AmazonS3 {      public static final String S3_SERVICE_NAME = "s3";      private static final String S3_SIGNER = "S3SignerType";     private static final String S3_V4_SIGNER = "AWSS3V4SignerType";      /** Shared logger for client events */     private static Log log = LogFactory.getLog(AmazonS3Client.class);      static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }      /** Responsible for handling error responses from all S3 service calls. */     private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();      /** Shared response handler for operations with no response.  */     private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);      /** Shared factory for converting configuration objects to XML */     private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();      /** Shared factory for converting request payment configuration objects to XML */     private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();      /** S3 specific client configuration options */     private S3ClientOptions clientOptions = new S3ClientOptions();      /** Provider for AWS credentials. */     private AWSCredentialsProvider awsCredentialsProvider;      /** Whether or not this client has an explicit region configured. */     private boolean hasExplicitRegion;      /**      * Constructs a new client to invoke service methods on Amazon S3. A      * credentials provider chain will be used that searches for credentials in      * this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Credential profiles file at the default location (~/.aws/credentials) shared by all AWS SDKs and the AWS CLI</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i> requests,      * but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the credentials      * provider chain, by passing in <code>null</code> for the credentials.      * </p>      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials to      * access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      */     public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials      * provider to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials,      * client configuration and request metric collector to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      * @param requestMetricCollector request metric collector      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }      /**      * Constructs a new client using the specified client configuration to      * access Amazon S3. A credentials provider chain will be used that searches      * for credentials in this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i>      * requests, but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the      * credentials provider chain, by passing in <code>null</code> for the      * credentials.      * </p>      *      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }      private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }      @Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }      @Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }       /**      * <p>      * Override the default S3 client options for this client.      * </p>      * @param clientOptions      *            The S3 client options to use.      */     public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfVersions(com.amazonaws.services.s3.model.S3VersionListing)      */     public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String)      */     public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Integer)      */     public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(com.amazonaws.services.s3.model.ListVersionsRequest)      */     public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String)      */     public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String, java.lang.String)      */     public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(com.amazonaws.services.s3.model.ListObjectsRequest)      */     public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfObjects(com.amazonaws.services.s3.model.S3ObjectListing)      */     public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getS3AccountOwner()      */     public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(com.amazonaws.services.s3.AmazonS3Client.GetBucketLocationRequest)      */     public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(java.lang.String)      */     public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucketjava.lang.String)      */     public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, com.amazonaws.services.s3.model.Region)      */     public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, java.lang.String)      */     public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(com.amazonaws.services.s3.model.CreateBucketRequest)      */     public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }      @Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(java.lang.String)      */     public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(com.amazonaws.services.s3.GetBucketAclRequest)      */     public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }      @Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }      @Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(java.lang.String, java.lang.String)      */     public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(com.amazonaws.services.s3.model.GetObjectMetadataRequest)      */     public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(java.lang.String, java.lang.String)      */     public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#doesBucketExist(java.lang.String)      */     public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }       /**      * Performs a head bucket operation on the requested bucket name. This is      * done to check if the bucket exists and the user has permissions to access      * it.      *      * @param headBucketRequest The request containing the bucket name.      * @throws AmazonClientException      * @throws AmazonServiceException      */     private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#changeStorageClass(java.lang.String, java.lang.String, java.lang.String)      */     public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setObjectRedirectLocation(java.lang.String, java.lang.String, java.lang.String)      */     public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest)      */     public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest, java.io.File)      */     public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }      /**      * Returns whether the specified request should skip MD5 check on the      * requested object content.      */     private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(java.lang.String)      */     public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(com.amazonaws.services.s3.model.DeleteBucketRequest)      */     public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.File)      */     public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.InputStream, com.amazonaws.services.s3.model.S3ObjectMetadata)      */     public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(com.amazonaws.services.s3.model.PutObjectRequest)      */     public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (!skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(input);                 input = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }      /**      * Sets the acccess control headers for the request given.      */     private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(java.lang.String, java.lang.String, java.lang.String, java.lang.String)      */     public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(com.amazonaws.services.s3.model.CopyObjectRequest)      */     public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }      /**      * Copies a source object to a part of a multipart upload.      *      * To copy an object, the caller's account must have read access to the source object and      * write access to the destination bucket.      * </p>      * <p>      * If constraints are specified in the <code>CopyPartRequest</code>      * (e.g.      * {@link CopyPartRequest#setMatchingETagConstraints(List)})      * and are not satisfied when Amazon S3 receives the      * request, this method returns <code>null</code>.      * This method returns a non-null result under all other      * circumstances.      * </p>      *      * @param copyPartRequest      *            The request object containing all the options for copying an      *            Amazon S3 object.      *      * @return A {@link CopyPartResult} object containing the information      *         returned by Amazon S3 about the newly created object, or <code>null</code> if      *         constraints were specified that weren't met when Amazon S3 attempted      *         to copy the object.      *      * @throws AmazonClientException      *             If any errors are encountered in the client while making the      *             request or handling the response.      * @throws AmazonServiceException      *             If any errors occurred in Amazon S3 while processing the      *             request.      *      * @see AmazonS3#copyObject(CopyObjectRequest)      * @see AmazonS3#initiateMultipartUpload(InitiateMultipartUploadRequest)      */     public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(java.lang.String, java.lang.String)      */     public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(com.amazonaws.services.s3.DeleteObjectRequest)      */     public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjects(com.amazonaws.services.s3.model.DeleteObjectsRequest)      */     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjectVersion(java.lang.String, java.lang.String, java.lang.String)      */     public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteVersion(com.amazonaws.services.s3.model.DeleteVersionRequest)      */     public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketVersioningConfiguration(com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest)      */     public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketVersioningConfiguration(java.lang.String)      */     public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(java.lang.String)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLifecycleConfiguration(java.lang.String)      */     public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest)      */     public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(java.lang.String)      */     public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest)      */     public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketCrossOriginConfiguration(java.lang.String)      */     public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketCrossOriginConfiguration)      */     public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest)      */     public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(java.lang.String)      */     public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest)      */     public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketTaggingConfiguration(java.lang.String)      */     public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest)      */     public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(java.lang.String)      */     public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest)      */     public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketWebsiteConfiguration)      */     public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest)      */     public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(java.lang.String)      */     public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest)      */     public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(java.lang.String,com.amazonaws.services.s3.model.BucketNotificationConfiguration)      */     public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest)      */     public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketNotificationConfiguration(java.lang.String)      */     public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLoggingConfiguration(java.lang.String)      */     public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLoggingConfiguration(com.amazonaws.services.s3.SetBucketLoggingConfigurationRequest)      */     public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(java.lang.String)      */     public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(java.lang.String, java.lang.String)      */     public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(java.lang.String)      */     public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(com.amazonaws.services.s3.model.GetBucketPolicyRequest)      */     public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(com.amazonaws.services.s3.model.SetBucketPolicyRequest)      */     public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(com.amazonaws.services.s3.model.DeleteBucketPolicyRequest)      */     public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }        /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date, com.amazonaws.HttpMethod)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(com.amazonaws.services.s3.model.GeneratePresignedUrlRequest)      */     public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#abortMultipartUpload(com.amazonaws.services.s3.model.AbortMultipartUploadRequest)      */     public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#completeMultipartUpload(com.amazonaws.services.s3.model.CompleteMultipartUploadRequest)      */     public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#initiateMultipartUpload(com.amazonaws.services.s3.model.InitiateMultipartUploadRequest)      */     public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listMultipartUploads(com.amazonaws.services.s3.model.ListMultipartUploadsRequest)      */     public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listParts(com.amazonaws.services.s3.model.ListPartsRequest)      */     public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#uploadPart(com.amazonaws.services.s3.model.UploadPartRequest)      */     public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             try {                 md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);                 inputStream = md5DigestStream;             } catch (NoSuchAlgorithmException e) {                 log.warn("No MD5 digest algorithm available.  Unable to calculate " +                          "checksum and verify data integrity.", e);             }         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 String contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());                 byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getResponseMetadataForRequest(com.amazonaws.AmazonWebServiceRequest)      */     public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#restoreObject(com.amazonaws.services.s3.model.RestoreObjectRequest)      */     public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }      /** (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyGlacierObject((java.lang.String, java.lang.String, int)      */     public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }       /*      * Private Interface      */      /**      * <p>      * Asserts that the specified parameter value is not <code>null</code> and if it is,      * throws an <code>IllegalArgumentException</code> with the specified error message.      * </p>      *      * @param parameterValue      *            The parameter value being checked.      * @param errorMessage      *            The error message to include in the IllegalArgumentException      *            if the specified parameter is null.      */     private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }       /**      * Fires a progress event with the specified event type to the specified      * listener.      *      * @param progressListenerCallbackExecutor      *            The listener callback executor.      * @param eventType      *            The type of event to fire.      */     private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }      /**      * <p>      * Gets the Amazon S3 {@link AccessControlList} (ACL) for the specified resource.      * (bucket if only the bucketName parameter is specified, otherwise the object with the      * specified key in the bucket).      * </p>      *      * @param bucketName      *            The name of the bucket whose ACL should be returned if the key      *            parameter is not specified, otherwise the bucket containing      *            the specified key.      * @param key      *            The object key whose ACL should be retrieve. If not specified,      *            the bucket's ACL is returned.      * @param versionId      *            The version ID of the object version whose ACL is being      *            retrieved.      * @param originalRequest      *            The original, user facing request object.      *      * @return The S3 ACL for the specified resource.      */     private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }      /**      * Sets the Canned ACL for the specified resource in S3. If only bucketName      * is specified, the canned ACL will be applied to the bucket, otherwise if      * bucketName and key are specified, the canned ACL will be applied to the      * object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param cannedAcl      *            The canned ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Sets the ACL for the specified resource in S3. If only bucketName is      * specified, the ACL will be applied to the bucket, otherwise if bucketName      * and key are specified, the ACL will be applied to the object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param acl      *            The ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Returns a "complete" S3 specific signer, taking into the S3 bucket, key,      * and the current S3 client configuration into account.      */     protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }      private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }      /**      * Pre-signs the specified request, using a signature query-string      * parameter.      *      * @param request      *            The request to sign.      * @param methodName      *            The HTTP method (GET, PUT, DELETE, HEAD) for the specified      *            request.      * @param bucketName      *            The name of the bucket involved in the request. If the request      *            is not an operation on a bucket this parameter should be null.      * @param key      *            The object key involved in the request. If the request is not      *            an operation on an object, this parameter should be null.      * @param expiration      *            The time at which the signed request is no longer valid, and      *            will stop working.      * @param subResource      *            The optional sub-resource being requested as part of the      *            request (e.g. "location", "acl", "logging", or "torrent").      */     protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }      private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }      /**      * Converts the current endpoint set for this client into virtual addressing      * style, by placing the name of the specified bucket before the S3 service      * endpoint.      *      * @param bucketName      *            The name of the bucket to use in the virtual addressing style      *            of the returned URI.      *      * @return A new URI, creating from the current service endpoint URI and the      *         specified bucket.      */     private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }      /**      * <p>      * Populates the specified request object with the appropriate headers from      * the {@link ObjectMetadata} object.      * </p>      *      * @param request      *            The request to populate with headers.      * @param metadata      *            The metadata containing the header information to include in      *            the request.      */     protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }      /**      * <p>      * Populates the specified request with the specified Multi-Factor      * Authentication (MFA) details. This includes the MFA header with device serial      * number and generated token. Since all requests which include the MFA      * header must be sent over HTTPS, this operation also configures the request object to      * use HTTPS instead of HTTP.      * </p>      *      * @param request      *            The request to populate.      * @param mfa      *            The Multi-Factor Authentication information.      */     private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyObjectRequest</code> object.      * @param copyObjectRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyPartRequest</code> object.      * @param copyPartRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous attributes available in      * <code>SSEWithCustomerKeyRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the      *            <code>ServerSideEncryptionWithCustomerKeyRequest</code>      *            object.      * @param sseCpkRequest      *            The request object for an S3 operation that allows server-side      *            encryption using customer-provided keys.      */     private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      /**      * Adds the specified header to the specified request, if the header value      * is not null.      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }      /**      * <p>      * Adds the specified date header in RFC 822 date format to the specified      * request.      * This method will not add a date header if the specified date value is <code>null</code>.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }      /**      * <p>      * Adds the specified string list header, joined together separated with      * commas, to the specified request.      * This method will not add a string list header if the specified values      * are <code>null</code> or empty.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param values      *            The list of strings to join together for the header value.      */     private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }      /**      * <p>      * Adds response headers parameters to the request given, if non-null.      * </p>      *      * @param request      *            The request to add the response header parameters to.      * @param responseHeaders      *            The full set of response headers to add, or null for none.      */     private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }      /**      * Returns the URL to the key in the bucket given, using the client's scheme      * and endpoint. Returns null if the given bucket and key cannot be      * converted to a URL.      */     public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }      /**      * Returns an URL for the object stored in the specified bucket and      * key.      * <p>      * If the object identified by the given bucket and key has public read      * permissions (ex: {@link CannedAccessControlList#PublicRead}), then this      * URL can be directly accessed to retrieve the object's data.      *      * @param bucketName      *            The name of the bucket containing the object whose URL is      *            being requested.      * @param key      *            The key under which the object whose URL is being requested is      *            stored.      *      * @return A unique URL for the object stored in the specified bucket and      *         key.      */     public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }      public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }      /**      * Creates and initializes a new request object for the specified S3      * resource. This method is responsible for determining the right way to      * address resources. For example, bucket names that are not DNS addressable      * cannot be addressed in V2, virtual host, style, and instead must use V1,      * path style. The returned request object has the service name, endpoint      * and resource path correctly populated. Callers can take the request, add      * any additional headers or parameters, then sign and execute the request.      *      * @param bucketName      *            An optional parameter indicating the name of the bucket      *            containing the resource involved in the request.      * @param key      *            An optional parameter indicating the key under which the      *            desired resource is stored in the specified bucket.      * @param originalRequest      *            The original request, as created by the user.      * @param httpMethod      *            The HTTP method to use when sending the request.      *      * @return A new request object, populated with endpoint, resource path, and      *         service name, ready for callers to populate any additional      *         headers or parameters, and execute.      */     protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }      /**      * Configure the given request with the specified bucket name and key.      * @return the request configured      */     private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }      private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }      @Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#enableRequesterPays(java.lang.String)      */     @Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#disableRequesterPays(java.lang.String)      */     @Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#isRequesterPaysEnabled(java.lang.String)      */     @Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }      /**      * Sets the request payment configuration for a given Amazon S3 bucket.      * This operation can be done only by the owner of the Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is set to      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /**      * Retrieves the request payment configuration for a given Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }      private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));     } } " compose:StringConcatenation merge: LineBased]
[NT -> rev_right_257dd : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java.merge : .java.merge-File]
									[T -> AmazonS3Client.java : .java-Content "/*  * Copyright 2010-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.services.s3;  import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES; import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;  import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.InputStream; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.regex.Matcher;  import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.http.client.methods.HttpRequestBase;  import com.amazonaws.AbortedException; import com.amazonaws.AmazonClientException; import com.amazonaws.AmazonServiceException; import com.amazonaws.AmazonServiceException.ErrorType; import com.amazonaws.AmazonWebServiceClient; import com.amazonaws.AmazonWebServiceRequest; import com.amazonaws.AmazonWebServiceResponse; import com.amazonaws.ClientConfiguration; import com.amazonaws.DefaultRequest; import com.amazonaws.HttpMethod; import com.amazonaws.Request; import com.amazonaws.Response; import com.amazonaws.SDKGlobalConfiguration; import com.amazonaws.auth.AWSCredentials; import com.amazonaws.auth.AWSCredentialsProvider; import com.amazonaws.auth.AWSCredentialsProviderChain; import com.amazonaws.auth.DefaultAWSCredentialsProviderChain; import com.amazonaws.auth.EnvironmentVariableCredentialsProvider; import com.amazonaws.auth.InstanceProfileCredentialsProvider; import com.amazonaws.auth.Presigner; import com.amazonaws.auth.Signer; import com.amazonaws.auth.SignerFactory; import com.amazonaws.auth.SystemPropertiesCredentialsProvider; import com.amazonaws.auth.profile.ProfileCredentialsProvider; import com.amazonaws.event.ProgressEvent; import com.amazonaws.event.ProgressListener; import com.amazonaws.event.ProgressListenerCallbackExecutor; import com.amazonaws.event.ProgressReportingInputStream; import com.amazonaws.handlers.HandlerChainFactory; import com.amazonaws.handlers.RequestHandler2; import com.amazonaws.http.ExecutionContext; import com.amazonaws.http.HttpMethodName; import com.amazonaws.http.HttpResponseHandler; import com.amazonaws.internal.StaticCredentialsProvider; import com.amazonaws.metrics.AwsSdkMetrics; import com.amazonaws.metrics.RequestMetricCollector; import com.amazonaws.regions.RegionUtils; import com.amazonaws.services.s3.internal.AWSS3V4Signer; import com.amazonaws.services.s3.internal.BucketNameUtils; import com.amazonaws.services.s3.internal.Constants; import com.amazonaws.services.s3.internal.DeleteObjectsResponse; import com.amazonaws.services.s3.internal.DigestValidationInputStream; import com.amazonaws.services.s3.internal.InputSubstream; import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream; import com.amazonaws.services.s3.internal.Mimetypes; import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler; import com.amazonaws.services.s3.internal.RepeatableFileInputStream; import com.amazonaws.services.s3.internal.RepeatableInputStream; import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain; import com.amazonaws.services.s3.internal.S3ErrorResponseHandler; import com.amazonaws.services.s3.internal.S3ExecutionContext; import com.amazonaws.services.s3.internal.S3MetadataResponseHandler; import com.amazonaws.services.s3.internal.S3ObjectResponseHandler; import com.amazonaws.services.s3.internal.S3QueryStringSigner; import com.amazonaws.services.s3.internal.S3Signer; import com.amazonaws.services.s3.internal.S3StringResponseHandler; import com.amazonaws.services.s3.internal.S3VersionHeaderHandler; import com.amazonaws.services.s3.internal.S3XmlResponseHandler; import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler; import com.amazonaws.services.s3.internal.ServiceUtils; import com.amazonaws.services.s3.internal.XmlWriter; import com.amazonaws.services.s3.metrics.S3ServiceMetric; import com.amazonaws.services.s3.model.AbortMultipartUploadRequest; import com.amazonaws.services.s3.model.AccessControlList; import com.amazonaws.services.s3.model.AmazonS3Exception; import com.amazonaws.services.s3.model.Bucket; import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration; import com.amazonaws.services.s3.model.BucketLifecycleConfiguration; import com.amazonaws.services.s3.model.BucketLoggingConfiguration; import com.amazonaws.services.s3.model.BucketNotificationConfiguration; import com.amazonaws.services.s3.model.BucketPolicy; import com.amazonaws.services.s3.model.BucketTaggingConfiguration; import com.amazonaws.services.s3.model.BucketVersioningConfiguration; import com.amazonaws.services.s3.model.BucketWebsiteConfiguration; import com.amazonaws.services.s3.model.CannedAccessControlList; import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest; import com.amazonaws.services.s3.model.CompleteMultipartUploadResult; import com.amazonaws.services.s3.model.CopyObjectRequest; import com.amazonaws.services.s3.model.CopyObjectResult; import com.amazonaws.services.s3.model.CopyPartRequest; import com.amazonaws.services.s3.model.CopyPartResult; import com.amazonaws.services.s3.model.CreateBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest; import com.amazonaws.services.s3.model.DeleteBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.DeleteObjectRequest; import com.amazonaws.services.s3.model.DeleteObjectsRequest; import com.amazonaws.services.s3.model.DeleteObjectsResult; import com.amazonaws.services.s3.model.DeleteVersionRequest; import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest; import com.amazonaws.services.s3.model.GenericBucketRequest; import com.amazonaws.services.s3.model.GetBucketAclRequest; import com.amazonaws.services.s3.model.GetBucketLocationRequest; import com.amazonaws.services.s3.model.GetBucketPolicyRequest; import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.GetObjectMetadataRequest; import com.amazonaws.services.s3.model.GetObjectRequest; import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.Grant; import com.amazonaws.services.s3.model.Grantee; import com.amazonaws.services.s3.model.GroupGrantee; import com.amazonaws.services.s3.model.HeadBucketRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadResult; import com.amazonaws.services.s3.model.ListBucketsRequest; import com.amazonaws.services.s3.model.ListMultipartUploadsRequest; import com.amazonaws.services.s3.model.ListObjectsRequest; import com.amazonaws.services.s3.model.ListPartsRequest; import com.amazonaws.services.s3.model.ListVersionsRequest; import com.amazonaws.services.s3.model.MultiFactorAuthentication; import com.amazonaws.services.s3.model.MultiObjectDeleteException; import com.amazonaws.services.s3.model.MultipartUploadListing; import com.amazonaws.services.s3.model.ObjectListing; import com.amazonaws.services.s3.model.ObjectMetadata; import com.amazonaws.services.s3.model.Owner; import com.amazonaws.services.s3.model.PartListing; import com.amazonaws.services.s3.model.Permission; import com.amazonaws.services.s3.model.PutObjectRequest; import com.amazonaws.services.s3.model.PutObjectResult; import com.amazonaws.services.s3.model.Region; import com.amazonaws.services.s3.model.RequestPaymentConfiguration; import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer; import com.amazonaws.services.s3.model.ResponseHeaderOverrides; import com.amazonaws.services.s3.model.RestoreObjectRequest; import com.amazonaws.services.s3.model.S3Object; import com.amazonaws.services.s3.model.S3ObjectInputStream; import com.amazonaws.services.s3.model.SSECustomerKey; import com.amazonaws.services.s3.model.SetBucketAclRequest; import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketPolicyRequest; import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.StorageClass; import com.amazonaws.services.s3.model.UploadPartRequest; import com.amazonaws.services.s3.model.UploadPartResult; import com.amazonaws.services.s3.model.VersionListing; import com.amazonaws.services.s3.model.transform.AclXmlFactory; import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory; import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.RequestXmlFactory; import com.amazonaws.services.s3.model.transform.Unmarshallers; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler; import com.amazonaws.transform.Unmarshaller; import com.amazonaws.util.AWSRequestMetrics; import com.amazonaws.util.AWSRequestMetrics.Field; import com.amazonaws.util.Base64; import com.amazonaws.util.BinaryUtils; import com.amazonaws.util.DateUtils; import com.amazonaws.util.HttpUtils; import com.amazonaws.util.LengthCheckInputStream; import com.amazonaws.util.Md5Utils; import com.amazonaws.util.ServiceClientHolderInputStream;  /**  * <p>  * Provides the client for accessing the Amazon S3 web service.  * </p>  * <p>  * Amazon S3 provides storage for the Internet,  * and is designed to make web-scale computing easier for developers.  * </p>  * <p>  * The Amazon S3 Java Client provides a simple interface that can be  * used to store and retrieve any amount of data, at any time,  * from anywhere on the web. It gives any developer access to the same  * highly scalable, reliable, secure, fast, inexpensive infrastructure  * that Amazon uses to run its own global network of web sites.  * The service aims to maximize benefits of scale and to pass those  * benefits on to developers.  * </p>  * <p>  * For more information about Amazon S3, please see  * <a href="http://aws.amazon.com/s3">  * http://aws.amazon.com/s3</a>  * </p>  */ public class AmazonS3Client extends AmazonWebServiceClient implements AmazonS3 {      public static final String S3_SERVICE_NAME = "s3";      private static final String S3_SIGNER = "S3SignerType";     private static final String S3_V4_SIGNER = "AWSS3V4SignerType";      /** Shared logger for client events */     private static Log log = LogFactory.getLog(AmazonS3Client.class);      static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }      /** Responsible for handling error responses from all S3 service calls. */     private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();      /** Shared response handler for operations with no response.  */     private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);      /** Shared factory for converting configuration objects to XML */     private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();      /** Shared factory for converting request payment configuration objects to XML */     private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();      /** S3 specific client configuration options */     private S3ClientOptions clientOptions = new S3ClientOptions();      /** Provider for AWS credentials. */     private AWSCredentialsProvider awsCredentialsProvider;      /** Whether or not this client has an explicit region configured. */     private boolean hasExplicitRegion;      /**      * Constructs a new client to invoke service methods on Amazon S3. A      * credentials provider chain will be used that searches for credentials in      * this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Credential profiles file at the default location (~/.aws/credentials) shared by all AWS SDKs and the AWS CLI</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i> requests,      * but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the credentials      * provider chain, by passing in <code>null</code> for the credentials.      * </p>      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials to      * access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      */     public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials      * provider to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials,      * client configuration and request metric collector to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      * @param requestMetricCollector request metric collector      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }      /**      * Constructs a new client using the specified client configuration to      * access Amazon S3. A credentials provider chain will be used that searches      * for credentials in this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i>      * requests, but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the      * credentials provider chain, by passing in <code>null</code> for the      * credentials.      * </p>      *      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }      private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }      @Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }      @Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }       /**      * <p>      * Override the default S3 client options for this client.      * </p>      * @param clientOptions      *            The S3 client options to use.      */     public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfVersions(com.amazonaws.services.s3.model.S3VersionListing)      */     public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String)      */     public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Integer)      */     public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(com.amazonaws.services.s3.model.ListVersionsRequest)      */     public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String)      */     public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String, java.lang.String)      */     public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(com.amazonaws.services.s3.model.ListObjectsRequest)      */     public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfObjects(com.amazonaws.services.s3.model.S3ObjectListing)      */     public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getS3AccountOwner()      */     public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(com.amazonaws.services.s3.AmazonS3Client.GetBucketLocationRequest)      */     public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(java.lang.String)      */     public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucketjava.lang.String)      */     public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, com.amazonaws.services.s3.model.Region)      */     public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, java.lang.String)      */     public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(com.amazonaws.services.s3.model.CreateBucketRequest)      */     public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }      @Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(java.lang.String)      */     public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(com.amazonaws.services.s3.GetBucketAclRequest)      */     public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }      @Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }      @Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(java.lang.String, java.lang.String)      */     public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(com.amazonaws.services.s3.model.GetObjectMetadataRequest)      */     public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(java.lang.String, java.lang.String)      */     public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#doesBucketExist(java.lang.String)      */     public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }       /**      * Performs a head bucket operation on the requested bucket name. This is      * done to check if the bucket exists and the user has permissions to access      * it.      *      * @param headBucketRequest The request containing the bucket name.      * @throws AmazonClientException      * @throws AmazonServiceException      */     private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#changeStorageClass(java.lang.String, java.lang.String, java.lang.String)      */     public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setObjectRedirectLocation(java.lang.String, java.lang.String, java.lang.String)      */     public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest)      */     public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest, java.io.File)      */     public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }      /**      * Returns whether the specified request should skip MD5 check on the      * requested object content.      */     private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(java.lang.String)      */     public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(com.amazonaws.services.s3.model.DeleteBucketRequest)      */     public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.File)      */     public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.InputStream, com.amazonaws.services.s3.model.S3ObjectMetadata)      */     public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(com.amazonaws.services.s3.model.PutObjectRequest)      */     public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (!skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             input = md5DigestStream = new MD5DigestCalculatingInputStream(input);         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }      /**      * Sets the acccess control headers for the request given.      */     private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(java.lang.String, java.lang.String, java.lang.String, java.lang.String)      */     public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(com.amazonaws.services.s3.model.CopyObjectRequest)      */     public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }      /**      * Copies a source object to a part of a multipart upload.      *      * To copy an object, the caller's account must have read access to the source object and      * write access to the destination bucket.      * </p>      * <p>      * If constraints are specified in the <code>CopyPartRequest</code>      * (e.g.      * {@link CopyPartRequest#setMatchingETagConstraints(List)})      * and are not satisfied when Amazon S3 receives the      * request, this method returns <code>null</code>.      * This method returns a non-null result under all other      * circumstances.      * </p>      *      * @param copyPartRequest      *            The request object containing all the options for copying an      *            Amazon S3 object.      *      * @return A {@link CopyPartResult} object containing the information      *         returned by Amazon S3 about the newly created object, or <code>null</code> if      *         constraints were specified that weren't met when Amazon S3 attempted      *         to copy the object.      *      * @throws AmazonClientException      *             If any errors are encountered in the client while making the      *             request or handling the response.      * @throws AmazonServiceException      *             If any errors occurred in Amazon S3 while processing the      *             request.      *      * @see AmazonS3#copyObject(CopyObjectRequest)      * @see AmazonS3#initiateMultipartUpload(InitiateMultipartUploadRequest)      */     public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(java.lang.String, java.lang.String)      */     public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(com.amazonaws.services.s3.DeleteObjectRequest)      */     public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjects(com.amazonaws.services.s3.model.DeleteObjectsRequest)      */     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjectVersion(java.lang.String, java.lang.String, java.lang.String)      */     public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteVersion(com.amazonaws.services.s3.model.DeleteVersionRequest)      */     public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketVersioningConfiguration(com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest)      */     public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketVersioningConfiguration(java.lang.String)      */     public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(java.lang.String)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLifecycleConfiguration(java.lang.String)      */     public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest)      */     public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(java.lang.String)      */     public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest)      */     public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketCrossOriginConfiguration(java.lang.String)      */     public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketCrossOriginConfiguration)      */     public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest)      */     public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(java.lang.String)      */     public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest)      */     public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketTaggingConfiguration(java.lang.String)      */     public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest)      */     public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(java.lang.String)      */     public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest)      */     public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketWebsiteConfiguration)      */     public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest)      */     public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(java.lang.String)      */     public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest)      */     public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(java.lang.String,com.amazonaws.services.s3.model.BucketNotificationConfiguration)      */     public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest)      */     public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketNotificationConfiguration(java.lang.String)      */     public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLoggingConfiguration(java.lang.String)      */     public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLoggingConfiguration(com.amazonaws.services.s3.SetBucketLoggingConfigurationRequest)      */     public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(java.lang.String)      */     public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(java.lang.String, java.lang.String)      */     public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(java.lang.String)      */     public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(com.amazonaws.services.s3.model.GetBucketPolicyRequest)      */     public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(com.amazonaws.services.s3.model.SetBucketPolicyRequest)      */     public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(com.amazonaws.services.s3.model.DeleteBucketPolicyRequest)      */     public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }        /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date, com.amazonaws.HttpMethod)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(com.amazonaws.services.s3.model.GeneratePresignedUrlRequest)      */     public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#abortMultipartUpload(com.amazonaws.services.s3.model.AbortMultipartUploadRequest)      */     public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#completeMultipartUpload(com.amazonaws.services.s3.model.CompleteMultipartUploadRequest)      */     public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#initiateMultipartUpload(com.amazonaws.services.s3.model.InitiateMultipartUploadRequest)      */     public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listMultipartUploads(com.amazonaws.services.s3.model.ListMultipartUploadsRequest)      */     public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listParts(com.amazonaws.services.s3.model.ListPartsRequest)      */     public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#uploadPart(com.amazonaws.services.s3.model.UploadPartRequest)      */     public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             inputStream = md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 byte[] clientSideHash = md5DigestStream.getMd5Digest();                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getResponseMetadataForRequest(com.amazonaws.AmazonWebServiceRequest)      */     public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#restoreObject(com.amazonaws.services.s3.model.RestoreObjectRequest)      */     public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }      /** (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyGlacierObject((java.lang.String, java.lang.String, int)      */     public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }       /*      * Private Interface      */      /**      * <p>      * Asserts that the specified parameter value is not <code>null</code> and if it is,      * throws an <code>IllegalArgumentException</code> with the specified error message.      * </p>      *      * @param parameterValue      *            The parameter value being checked.      * @param errorMessage      *            The error message to include in the IllegalArgumentException      *            if the specified parameter is null.      */     private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }       /**      * Fires a progress event with the specified event type to the specified      * listener.      *      * @param progressListenerCallbackExecutor      *            The listener callback executor.      * @param eventType      *            The type of event to fire.      */     private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }      /**      * <p>      * Gets the Amazon S3 {@link AccessControlList} (ACL) for the specified resource.      * (bucket if only the bucketName parameter is specified, otherwise the object with the      * specified key in the bucket).      * </p>      *      * @param bucketName      *            The name of the bucket whose ACL should be returned if the key      *            parameter is not specified, otherwise the bucket containing      *            the specified key.      * @param key      *            The object key whose ACL should be retrieve. If not specified,      *            the bucket's ACL is returned.      * @param versionId      *            The version ID of the object version whose ACL is being      *            retrieved.      * @param originalRequest      *            The original, user facing request object.      *      * @return The S3 ACL for the specified resource.      */     private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }      /**      * Sets the Canned ACL for the specified resource in S3. If only bucketName      * is specified, the canned ACL will be applied to the bucket, otherwise if      * bucketName and key are specified, the canned ACL will be applied to the      * object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param cannedAcl      *            The canned ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Sets the ACL for the specified resource in S3. If only bucketName is      * specified, the ACL will be applied to the bucket, otherwise if bucketName      * and key are specified, the ACL will be applied to the object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param acl      *            The ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Returns a "complete" S3 specific signer, taking into the S3 bucket, key,      * and the current S3 client configuration into account.      */     protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }      private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }      /**      * Pre-signs the specified request, using a signature query-string      * parameter.      *      * @param request      *            The request to sign.      * @param methodName      *            The HTTP method (GET, PUT, DELETE, HEAD) for the specified      *            request.      * @param bucketName      *            The name of the bucket involved in the request. If the request      *            is not an operation on a bucket this parameter should be null.      * @param key      *            The object key involved in the request. If the request is not      *            an operation on an object, this parameter should be null.      * @param expiration      *            The time at which the signed request is no longer valid, and      *            will stop working.      * @param subResource      *            The optional sub-resource being requested as part of the      *            request (e.g. "location", "acl", "logging", or "torrent").      */     protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }      private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }      /**      * Converts the current endpoint set for this client into virtual addressing      * style, by placing the name of the specified bucket before the S3 service      * endpoint.      *      * @param bucketName      *            The name of the bucket to use in the virtual addressing style      *            of the returned URI.      *      * @return A new URI, creating from the current service endpoint URI and the      *         specified bucket.      */     private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }      /**      * <p>      * Populates the specified request object with the appropriate headers from      * the {@link ObjectMetadata} object.      * </p>      *      * @param request      *            The request to populate with headers.      * @param metadata      *            The metadata containing the header information to include in      *            the request.      */     protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }      /**      * <p>      * Populates the specified request with the specified Multi-Factor      * Authentication (MFA) details. This includes the MFA header with device serial      * number and generated token. Since all requests which include the MFA      * header must be sent over HTTPS, this operation also configures the request object to      * use HTTPS instead of HTTP.      * </p>      *      * @param request      *            The request to populate.      * @param mfa      *            The Multi-Factor Authentication information.      */     private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyObjectRequest</code> object.      * @param copyObjectRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyPartRequest</code> object.      * @param copyPartRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous attributes available in      * <code>SSEWithCustomerKeyRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the      *            <code>ServerSideEncryptionWithCustomerKeyRequest</code>      *            object.      * @param sseCpkRequest      *            The request object for an S3 operation that allows server-side      *            encryption using customer-provided keys.      */     private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      /**      * Adds the specified header to the specified request, if the header value      * is not null.      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }      /**      * <p>      * Adds the specified date header in RFC 822 date format to the specified      * request.      * This method will not add a date header if the specified date value is <code>null</code>.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }      /**      * <p>      * Adds the specified string list header, joined together separated with      * commas, to the specified request.      * This method will not add a string list header if the specified values      * are <code>null</code> or empty.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param values      *            The list of strings to join together for the header value.      */     private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }      /**      * <p>      * Adds response headers parameters to the request given, if non-null.      * </p>      *      * @param request      *            The request to add the response header parameters to.      * @param responseHeaders      *            The full set of response headers to add, or null for none.      */     private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }      /**      * Returns the URL to the key in the bucket given, using the client's scheme      * and endpoint. Returns null if the given bucket and key cannot be      * converted to a URL.      */     public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }      /**      * Returns an URL for the object stored in the specified bucket and      * key.      * <p>      * If the object identified by the given bucket and key has public read      * permissions (ex: {@link CannedAccessControlList#PublicRead}), then this      * URL can be directly accessed to retrieve the object's data.      *      * @param bucketName      *            The name of the bucket containing the object whose URL is      *            being requested.      * @param key      *            The key under which the object whose URL is being requested is      *            stored.      *      * @return A unique URL for the object stored in the specified bucket and      *         key.      */     public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }      public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }      /**      * Creates and initializes a new request object for the specified S3      * resource. This method is responsible for determining the right way to      * address resources. For example, bucket names that are not DNS addressable      * cannot be addressed in V2, virtual host, style, and instead must use V1,      * path style. The returned request object has the service name, endpoint      * and resource path correctly populated. Callers can take the request, add      * any additional headers or parameters, then sign and execute the request.      *      * @param bucketName      *            An optional parameter indicating the name of the bucket      *            containing the resource involved in the request.      * @param key      *            An optional parameter indicating the key under which the      *            desired resource is stored in the specified bucket.      * @param originalRequest      *            The original request, as created by the user.      * @param httpMethod      *            The HTTP method to use when sending the request.      *      * @return A new request object, populated with endpoint, resource path, and      *         service name, ready for callers to populate any additional      *         headers or parameters, and execute.      */     protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }      /**      * Configure the given request with the specified bucket name and key.      * @return the request configured      */     private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }      private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }      @Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#enableRequesterPays(java.lang.String)      */     @Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#disableRequesterPays(java.lang.String)      */     @Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#isRequesterPaysEnabled(java.lang.String)      */     @Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }      /**      * Sets the request payment configuration for a given Amazon S3 bucket.      * This operation can be done only by the owner of the Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is set to      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /**      * Retrieves the request payment configuration for a given Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }      private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));     } } " compose:StringConcatenation merge: LineBased]
[NT -> rev_left_7ab10 : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> amazonaws : Folder]
						[NT -> services : Folder]
							[NT -> s3 : Folder]
								[NT -> AmazonS3Client.java.merge : .java.merge-File]
									[T -> AmazonS3Client.java : .java-Content "/*  * Copyright 2010-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License").  * You may not use this file except in compliance with the License.  * A copy of the License is located at  *  *  http://aws.amazon.com/apache2.0  *  * or in the "license" file accompanying this file. This file is distributed  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing  * permissions and limitations under the License.  */ package com.amazonaws.services.s3;  import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES; import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;  import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.InputStream; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.regex.Matcher;  import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.http.client.methods.HttpRequestBase;  import com.amazonaws.AbortedException; import com.amazonaws.AmazonClientException; import com.amazonaws.AmazonServiceException; import com.amazonaws.AmazonServiceException.ErrorType; import com.amazonaws.AmazonWebServiceClient; import com.amazonaws.AmazonWebServiceRequest; import com.amazonaws.AmazonWebServiceResponse; import com.amazonaws.ClientConfiguration; import com.amazonaws.DefaultRequest; import com.amazonaws.HttpMethod; import com.amazonaws.Request; import com.amazonaws.Response; import com.amazonaws.SDKGlobalConfiguration; import com.amazonaws.auth.AWSCredentials; import com.amazonaws.auth.AWSCredentialsProvider; import com.amazonaws.auth.AWSCredentialsProviderChain; import com.amazonaws.auth.DefaultAWSCredentialsProviderChain; import com.amazonaws.auth.EnvironmentVariableCredentialsProvider; import com.amazonaws.auth.InstanceProfileCredentialsProvider; import com.amazonaws.auth.Presigner; import com.amazonaws.auth.Signer; import com.amazonaws.auth.SignerFactory; import com.amazonaws.auth.SystemPropertiesCredentialsProvider; import com.amazonaws.auth.profile.ProfileCredentialsProvider; import com.amazonaws.event.ProgressEvent; import com.amazonaws.event.ProgressListener; import com.amazonaws.event.ProgressListenerCallbackExecutor; import com.amazonaws.event.ProgressReportingInputStream; import com.amazonaws.handlers.HandlerChainFactory; import com.amazonaws.handlers.RequestHandler2; import com.amazonaws.http.ExecutionContext; import com.amazonaws.http.HttpMethodName; import com.amazonaws.http.HttpResponseHandler; import com.amazonaws.internal.StaticCredentialsProvider; import com.amazonaws.metrics.AwsSdkMetrics; import com.amazonaws.metrics.RequestMetricCollector; import com.amazonaws.regions.RegionUtils; import com.amazonaws.services.s3.internal.AWSS3V4Signer; import com.amazonaws.services.s3.internal.BucketNameUtils; import com.amazonaws.services.s3.internal.Constants; import com.amazonaws.services.s3.internal.DeleteObjectsResponse; import com.amazonaws.services.s3.internal.DigestValidationInputStream; import com.amazonaws.services.s3.internal.InputSubstream; import com.amazonaws.services.s3.internal.MD5DigestCalculatingInputStream; import com.amazonaws.services.s3.internal.Mimetypes; import com.amazonaws.services.s3.internal.ObjectExpirationHeaderHandler; import com.amazonaws.services.s3.internal.RepeatableFileInputStream; import com.amazonaws.services.s3.internal.RepeatableInputStream; import com.amazonaws.services.s3.internal.ResponseHeaderHandlerChain; import com.amazonaws.services.s3.internal.S3ErrorResponseHandler; import com.amazonaws.services.s3.internal.S3ExecutionContext; import com.amazonaws.services.s3.internal.S3MetadataResponseHandler; import com.amazonaws.services.s3.internal.S3ObjectResponseHandler; import com.amazonaws.services.s3.internal.S3QueryStringSigner; import com.amazonaws.services.s3.internal.S3Signer; import com.amazonaws.services.s3.internal.S3StringResponseHandler; import com.amazonaws.services.s3.internal.S3VersionHeaderHandler; import com.amazonaws.services.s3.internal.S3XmlResponseHandler; import com.amazonaws.services.s3.internal.ServerSideEncryptionHeaderHandler; import com.amazonaws.services.s3.internal.ServiceUtils; import com.amazonaws.services.s3.internal.XmlWriter; import com.amazonaws.services.s3.metrics.S3ServiceMetric; import com.amazonaws.services.s3.model.AbortMultipartUploadRequest; import com.amazonaws.services.s3.model.AccessControlList; import com.amazonaws.services.s3.model.AmazonS3Exception; import com.amazonaws.services.s3.model.Bucket; import com.amazonaws.services.s3.model.BucketCrossOriginConfiguration; import com.amazonaws.services.s3.model.BucketLifecycleConfiguration; import com.amazonaws.services.s3.model.BucketLoggingConfiguration; import com.amazonaws.services.s3.model.BucketNotificationConfiguration; import com.amazonaws.services.s3.model.BucketPolicy; import com.amazonaws.services.s3.model.BucketTaggingConfiguration; import com.amazonaws.services.s3.model.BucketVersioningConfiguration; import com.amazonaws.services.s3.model.BucketWebsiteConfiguration; import com.amazonaws.services.s3.model.CannedAccessControlList; import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest; import com.amazonaws.services.s3.model.CompleteMultipartUploadResult; import com.amazonaws.services.s3.model.CopyObjectRequest; import com.amazonaws.services.s3.model.CopyObjectResult; import com.amazonaws.services.s3.model.CopyPartRequest; import com.amazonaws.services.s3.model.CopyPartResult; import com.amazonaws.services.s3.model.CreateBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketPolicyRequest; import com.amazonaws.services.s3.model.DeleteBucketRequest; import com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.DeleteObjectRequest; import com.amazonaws.services.s3.model.DeleteObjectsRequest; import com.amazonaws.services.s3.model.DeleteObjectsResult; import com.amazonaws.services.s3.model.DeleteVersionRequest; import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest; import com.amazonaws.services.s3.model.GenericBucketRequest; import com.amazonaws.services.s3.model.GetBucketAclRequest; import com.amazonaws.services.s3.model.GetBucketLocationRequest; import com.amazonaws.services.s3.model.GetBucketPolicyRequest; import com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.GetObjectMetadataRequest; import com.amazonaws.services.s3.model.GetObjectRequest; import com.amazonaws.services.s3.model.GetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.Grant; import com.amazonaws.services.s3.model.Grantee; import com.amazonaws.services.s3.model.GroupGrantee; import com.amazonaws.services.s3.model.HeadBucketRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadRequest; import com.amazonaws.services.s3.model.InitiateMultipartUploadResult; import com.amazonaws.services.s3.model.ListBucketsRequest; import com.amazonaws.services.s3.model.ListMultipartUploadsRequest; import com.amazonaws.services.s3.model.ListObjectsRequest; import com.amazonaws.services.s3.model.ListPartsRequest; import com.amazonaws.services.s3.model.ListVersionsRequest; import com.amazonaws.services.s3.model.MultiFactorAuthentication; import com.amazonaws.services.s3.model.MultiObjectDeleteException; import com.amazonaws.services.s3.model.MultipartUploadListing; import com.amazonaws.services.s3.model.ObjectListing; import com.amazonaws.services.s3.model.ObjectMetadata; import com.amazonaws.services.s3.model.Owner; import com.amazonaws.services.s3.model.PartListing; import com.amazonaws.services.s3.model.Permission; import com.amazonaws.services.s3.model.PutObjectRequest; import com.amazonaws.services.s3.model.PutObjectResult; import com.amazonaws.services.s3.model.Region; import com.amazonaws.services.s3.model.RequestPaymentConfiguration; import com.amazonaws.services.s3.model.RequestPaymentConfiguration.Payer; import com.amazonaws.services.s3.model.ResponseHeaderOverrides; import com.amazonaws.services.s3.model.RestoreObjectRequest; import com.amazonaws.services.s3.model.S3Object; import com.amazonaws.services.s3.model.S3ObjectInputStream; import com.amazonaws.services.s3.model.SSECustomerKey; import com.amazonaws.services.s3.model.SetBucketAclRequest; import com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketLoggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketPolicyRequest; import com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest; import com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest; import com.amazonaws.services.s3.model.SetRequestPaymentConfigurationRequest; import com.amazonaws.services.s3.model.StorageClass; import com.amazonaws.services.s3.model.UploadPartRequest; import com.amazonaws.services.s3.model.UploadPartResult; import com.amazonaws.services.s3.model.VersionListing; import com.amazonaws.services.s3.model.transform.AclXmlFactory; import com.amazonaws.services.s3.model.transform.BucketConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.MultiObjectDeleteXmlFactory; import com.amazonaws.services.s3.model.transform.RequestPaymentConfigurationXmlFactory; import com.amazonaws.services.s3.model.transform.RequestXmlFactory; import com.amazonaws.services.s3.model.transform.Unmarshallers; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CompleteMultipartUploadHandler; import com.amazonaws.services.s3.model.transform.XmlResponsesSaxParser.CopyObjectResultHandler; import com.amazonaws.transform.Unmarshaller; import com.amazonaws.util.AWSRequestMetrics; import com.amazonaws.util.AWSRequestMetrics.Field; import com.amazonaws.util.Base64; import com.amazonaws.util.BinaryUtils; import com.amazonaws.util.DateUtils; import com.amazonaws.util.HttpUtils; import com.amazonaws.util.LengthCheckInputStream; import com.amazonaws.util.Md5Utils; import com.amazonaws.util.ServiceClientHolderInputStream;  /**  * <p>  * Provides the client for accessing the Amazon S3 web service.  * </p>  * <p>  * Amazon S3 provides storage for the Internet,  * and is designed to make web-scale computing easier for developers.  * </p>  * <p>  * The Amazon S3 Java Client provides a simple interface that can be  * used to store and retrieve any amount of data, at any time,  * from anywhere on the web. It gives any developer access to the same  * highly scalable, reliable, secure, fast, inexpensive infrastructure  * that Amazon uses to run its own global network of web sites.  * The service aims to maximize benefits of scale and to pass those  * benefits on to developers.  * </p>  * <p>  * For more information about Amazon S3, please see  * <a href="http://aws.amazon.com/s3">  * http://aws.amazon.com/s3</a>  * </p>  */ public class AmazonS3Client extends AmazonWebServiceClient implements AmazonS3 {      public static final String S3_SERVICE_NAME = "s3";      private static final String S3_SIGNER = "S3SignerType";     private static final String S3_V4_SIGNER = "AWSS3V4SignerType";      /** Shared logger for client events */     private static Log log = LogFactory.getLog(AmazonS3Client.class);      static {         // Enable S3 specific predefined request metrics.         AwsSdkMetrics.addAll(Arrays.asList(S3ServiceMetric.values()));          // Register S3-specific signers.         SignerFactory.registerSigner(S3_SIGNER, S3Signer.class);         SignerFactory.registerSigner(S3_V4_SIGNER, AWSS3V4Signer.class);     }      /** Responsible for handling error responses from all S3 service calls. */     private S3ErrorResponseHandler errorResponseHandler = new S3ErrorResponseHandler();      /** Shared response handler for operations with no response.  */     private S3XmlResponseHandler<Void> voidResponseHandler = new S3XmlResponseHandler<Void>(null);      /** Shared factory for converting configuration objects to XML */     private static final BucketConfigurationXmlFactory bucketConfigurationXmlFactory = new BucketConfigurationXmlFactory();      /** Shared factory for converting request payment configuration objects to XML */     private static final RequestPaymentConfigurationXmlFactory requestPaymentConfigurationXmlFactory = new RequestPaymentConfigurationXmlFactory();      /** S3 specific client configuration options */     private S3ClientOptions clientOptions = new S3ClientOptions();      /** Provider for AWS credentials. */     private AWSCredentialsProvider awsCredentialsProvider;      /** Whether or not this client has an explicit region configured. */     private boolean hasExplicitRegion;      /**      * Constructs a new client to invoke service methods on Amazon S3. A      * credentials provider chain will be used that searches for credentials in      * this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Credential profiles file at the default location (~/.aws/credentials) shared by all AWS SDKs and the AWS CLI</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i> requests,      * but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the credentials      * provider chain, by passing in <code>null</code> for the credentials.      * </p>      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client() {         this(new AWSCredentialsProviderChain(                 new EnvironmentVariableCredentialsProvider(),                 new SystemPropertiesCredentialsProvider(),                 new ProfileCredentialsProvider(),                 new InstanceProfileCredentialsProvider()) {              public AWSCredentials getCredentials() {                 try {                     return super.getCredentials();                 } catch (AmazonClientException ace) {}                  log.debug("No credentials available; falling back to anonymous access");                 return null;             }         });     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials to      * access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(AWSCredentials awsCredentials) {         this(awsCredentials, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param awsCredentials      *            The AWS credentials to use when making requests to Amazon S3      *            with this client.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client()      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      */     public AmazonS3Client(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {         super(clientConfiguration);         this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);         init();     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials      * provider to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider) {         this(credentialsProvider, new ClientConfiguration());     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials and      * client configuration to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration) {         this(credentialsProvider, clientConfiguration, null);     }      /**      * Constructs a new Amazon S3 client using the specified AWS credentials,      * client configuration and request metric collector to access Amazon S3.      *      * @param credentialsProvider      *            The AWS credentials provider which will provide credentials      *            to authenticate requests with AWS services.      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      * @param requestMetricCollector request metric collector      */     public AmazonS3Client(AWSCredentialsProvider credentialsProvider,             ClientConfiguration clientConfiguration,             RequestMetricCollector requestMetricCollector) {         super(clientConfiguration, requestMetricCollector);         this.awsCredentialsProvider = credentialsProvider;         init();     }      /**      * Constructs a new client using the specified client configuration to      * access Amazon S3. A credentials provider chain will be used that searches      * for credentials in this order:      * <ul>      * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>      * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>      * <li>Instance Profile Credentials - delivered through the Amazon EC2      * metadata service</li>      * </ul>      *      * <p>      * If no credentials are found in the chain, this client will attempt to      * work in an anonymous mode where requests aren't signed. Only a subset of      * the Amazon S3 API will work with anonymous <i>(i.e. unsigned)</i>      * requests, but this can prove useful in some situations. For example:      * <ul>      * <li>If an Amazon S3 bucket has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #listObjects(String)} to see what objects are stored in a bucket.</li>      * <li>If an object has {@link Permission#Read} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can call      * {@link #getObject(String, String)} and      * {@link #getObjectMetadata(String, String)} to pull object content and      * metadata.</li>      * <li>If a bucket has {@link Permission#Write} permission for the      * {@link GroupGrantee#AllUsers} group, anonymous clients can upload objects      * to the bucket.</li>      * </ul>      * </p>      * <p>      * You can force the client to operate in an anonymous mode, and skip the      * credentials provider chain, by passing in <code>null</code> for the      * credentials.      * </p>      *      * @param clientConfiguration      *            The client configuration options controlling how this client      *            connects to Amazon S3 (e.g. proxy settings, retry counts, etc).      *      * @see AmazonS3Client#AmazonS3Client(AWSCredentials)      * @see AmazonS3Client#AmazonS3Client(AWSCredentials, ClientConfiguration)      */     public AmazonS3Client(ClientConfiguration clientConfiguration) {         this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);     }      private void init() {         // Because of S3's virtual host style addressing, we need to change the         // default, strict hostname verification to be more lenient.         client.disableStrictHostnameVerification();          // calling this.setEndpoint(...) will also modify the signer accordingly         setEndpoint(Constants.S3_HOSTNAME);          HandlerChainFactory chainFactory = new HandlerChainFactory();         requestHandler2s.addAll(chainFactory.newRequestHandlerChain(                 "/com/amazonaws/services/s3/request.handlers"));         requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(                 "/com/amazonaws/services/s3/request.handler2s"));     }      @Override     public void setEndpoint(String endpoint) {         /*          * When signing requests using a pre-Signature-Version-4 signer, it's          * possible to use the endpoint "s3.amazonaws.com" to access buckets in          * any region - we send the request to &lt;bucket&gt;.s3.amazonaws.com,          * which resolves to an S3 endpoint in the appropriate region.          *          * However, when the user opts in to using Signature Version 4, we need          * to include the region of the bucket in the signature, and cannot          * take advantage of this handy feature of S3.          *          * If you want to use Signature Version 4 to access a bucket in the          * US Classic region (which does not have a region-specific endpoint),          * you'll need to call setRegion(Region.getRegion(Regions.US_EAST_1))          * to explicitly tell us which region to include in the signature.          */          hasExplicitRegion = !(Constants.S3_HOSTNAME.equals(endpoint));         super.setEndpoint(endpoint);     }      @Override     public void setRegion(com.amazonaws.regions.Region region) {         hasExplicitRegion = true;         super.setRegion(region);     }       /**      * <p>      * Override the default S3 client options for this client.      * </p>      * @param clientOptions      *            The S3 client options to use.      */     public void setS3ClientOptions(S3ClientOptions clientOptions) {         this.clientOptions = new S3ClientOptions(clientOptions);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfVersions(com.amazonaws.services.s3.model.S3VersionListing)      */     public VersionListing listNextBatchOfVersions(VersionListing previousVersionListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousVersionListing,             "The previous version listing parameter must be specified when listing the next batch of versions in a bucket");          if (!previousVersionListing.isTruncated()) {             VersionListing emptyListing = new VersionListing();             emptyListing.setBucketName(previousVersionListing.getBucketName());             emptyListing.setDelimiter(previousVersionListing.getDelimiter());             emptyListing.setKeyMarker(previousVersionListing.getNextKeyMarker());             emptyListing.setVersionIdMarker(previousVersionListing.getNextVersionIdMarker());             emptyListing.setMaxKeys(previousVersionListing.getMaxKeys());             emptyListing.setPrefix(previousVersionListing.getPrefix());             emptyListing.setEncodingType(previousVersionListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listVersions(                 new ListVersionsRequest(                         previousVersionListing.getBucketName(),                         previousVersionListing.getPrefix(),                         previousVersionListing.getNextKeyMarker(),                         previousVersionListing.getNextVersionIdMarker(),                         previousVersionListing.getDelimiter(),                         new Integer( previousVersionListing.getMaxKeys() ))                     .withEncodingType(previousVersionListing.getEncodingType())                );     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String)      */     public VersionListing listVersions(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listVersions(new ListVersionsRequest(bucketName, prefix, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Integer)      */     public VersionListing listVersions(String bucketName, String prefix, String keyMarker, String versionIdMarker, String delimiter, Integer maxKeys)             throws AmazonClientException, AmazonServiceException {          ListVersionsRequest request = new ListVersionsRequest()             .withBucketName(bucketName)             .withPrefix(prefix)             .withDelimiter(delimiter)             .withKeyMarker(keyMarker)             .withVersionIdMarker(versionIdMarker)             .withMaxResults(maxKeys);         return listVersions(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listVersions(com.amazonaws.services.s3.model.ListVersionsRequest)      */     public VersionListing listVersions(ListVersionsRequest listVersionsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listVersionsRequest.getBucketName(), "The bucket name parameter must be specified when listing versions in a bucket");          Request<ListVersionsRequest> request = createRequest(listVersionsRequest.getBucketName(), null, listVersionsRequest, HttpMethodName.GET);         request.addParameter("versions", null);          if (listVersionsRequest.getPrefix() != null) request.addParameter("prefix", listVersionsRequest.getPrefix());         if (listVersionsRequest.getKeyMarker() != null) request.addParameter("key-marker", listVersionsRequest.getKeyMarker());         if (listVersionsRequest.getVersionIdMarker() != null) request.addParameter("version-id-marker", listVersionsRequest.getVersionIdMarker());         if (listVersionsRequest.getDelimiter() != null) request.addParameter("delimiter", listVersionsRequest.getDelimiter());         if (listVersionsRequest.getMaxResults() != null && listVersionsRequest.getMaxResults().intValue() >= 0) request.addParameter("max-keys", listVersionsRequest.getMaxResults().toString());         if (listVersionsRequest.getEncodingType() != null) request.addParameter("encoding-type", listVersionsRequest.getEncodingType());          return invoke(request, new Unmarshallers.VersionListUnmarshaller(), listVersionsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String)      */     public ObjectListing listObjects(String bucketName)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, null, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(java.lang.String, java.lang.String)      */     public ObjectListing listObjects(String bucketName, String prefix)             throws AmazonClientException, AmazonServiceException {         return listObjects(new ListObjectsRequest(bucketName, prefix, null, null, null));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listObjects(com.amazonaws.services.s3.model.ListObjectsRequest)      */     public ObjectListing listObjects(ListObjectsRequest listObjectsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listObjectsRequest.getBucketName(), "The bucket name parameter must be specified when listing objects in a bucket");          Request<ListObjectsRequest> request = createRequest(listObjectsRequest.getBucketName(), null, listObjectsRequest, HttpMethodName.GET);         if (listObjectsRequest.getPrefix() != null) request.addParameter("prefix", listObjectsRequest.getPrefix());         if (listObjectsRequest.getMarker() != null) request.addParameter("marker", listObjectsRequest.getMarker());         if (listObjectsRequest.getDelimiter() != null) request.addParameter("delimiter", listObjectsRequest.getDelimiter());         if (listObjectsRequest.getMaxKeys() != null && listObjectsRequest.getMaxKeys().intValue() >= 0) request.addParameter("max-keys", listObjectsRequest.getMaxKeys().toString());         if (listObjectsRequest.getEncodingType() != null) request.addParameter("encoding-type", listObjectsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListObjectsUnmarshaller(), listObjectsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listNextBatchOfObjects(com.amazonaws.services.s3.model.S3ObjectListing)      */     public ObjectListing listNextBatchOfObjects(ObjectListing previousObjectListing)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(previousObjectListing,                 "The previous object listing parameter must be specified when listing the next batch of objects in a bucket");          if (!previousObjectListing.isTruncated()) {             ObjectListing emptyListing = new ObjectListing();             emptyListing.setBucketName(previousObjectListing.getBucketName());             emptyListing.setDelimiter(previousObjectListing.getDelimiter());             emptyListing.setMarker(previousObjectListing.getNextMarker());             emptyListing.setMaxKeys(previousObjectListing.getMaxKeys());             emptyListing.setPrefix(previousObjectListing.getPrefix());             emptyListing.setEncodingType(previousObjectListing.getEncodingType());             emptyListing.setTruncated(false);              return emptyListing;         }          return listObjects(                 new ListObjectsRequest(                         previousObjectListing.getBucketName(),                         previousObjectListing.getPrefix(),                         previousObjectListing.getNextMarker(),                         previousObjectListing.getDelimiter(),                         new Integer( previousObjectListing.getMaxKeys() ))                     .withEncodingType(previousObjectListing.getEncodingType())                );     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getS3AccountOwner()      */     public Owner getS3AccountOwner()             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, new ListBucketsRequest(), HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsOwnerUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets(ListBucketsRequest listBucketsRequest)             throws AmazonClientException, AmazonServiceException {         Request<ListBucketsRequest> request = createRequest(null, null, listBucketsRequest, HttpMethodName.GET);         return invoke(request, new Unmarshallers.ListBucketsUnmarshaller(), null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listBuckets()      */     public List<Bucket> listBuckets()             throws AmazonClientException, AmazonServiceException {         return listBuckets(new ListBucketsRequest());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(com.amazonaws.services.s3.AmazonS3Client.GetBucketLocationRequest)      */     public String getBucketLocation(GetBucketLocationRequest getBucketLocationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketLocationRequest, "The request parameter must be specified when requesting a bucket's location");         String bucketName = getBucketLocationRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's location");          Request<GetBucketLocationRequest> request = createRequest(bucketName, null, getBucketLocationRequest, HttpMethodName.GET);         request.addParameter("location", null);          return invoke(request, new Unmarshallers.BucketLocationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLocation(java.lang.String)      */     public String getBucketLocation(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketLocation(new GetBucketLocationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucketjava.lang.String)      */     public Bucket createBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, com.amazonaws.services.s3.model.Region)      */     public Bucket createBucket(String bucketName, Region region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(java.lang.String, java.lang.String)      */     public Bucket createBucket(String bucketName, String region)             throws AmazonClientException, AmazonServiceException {         return createBucket(new CreateBucketRequest(bucketName, region));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#createBucket(com.amazonaws.services.s3.model.CreateBucketRequest)      */     public Bucket createBucket(CreateBucketRequest createBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(createBucketRequest,                 "The CreateBucketRequest parameter must be specified when creating a bucket");          String bucketName = createBucketRequest.getBucketName();         String region = createBucketRequest.getRegion();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when creating a bucket");          if (bucketName != null) bucketName = bucketName.trim();         BucketNameUtils.validateBucketName(bucketName);          Request<CreateBucketRequest> request = createRequest(bucketName, null, createBucketRequest, HttpMethodName.PUT);          if ( createBucketRequest.getAccessControlList() != null ) {             addAclHeaders(request, createBucketRequest.getAccessControlList());         } else if ( createBucketRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, createBucketRequest.getCannedAcl().toString());         }          /*          * If we're talking to a region-specific endpoint other than the US, we          * *must* specify a location constraint. Try to derive the region from          * the endpoint.          */         if (!(this.endpoint.getHost().equals(Constants.S3_HOSTNAME))                 && (region == null || region.isEmpty())) {              try {                 region = RegionUtils                     .getRegionByEndpoint(this.endpoint.getHost())                     .getName();             } catch (IllegalArgumentException exception) {                 // Endpoint does not correspond to a known region; send the                 // request with no location constraint and hope for the best.             }          }          /*          * We can only send the CreateBucketConfiguration if we're *not*          * creating a bucket in the US region.          */         if (region != null && !region.toUpperCase().equals(Region.US_Standard.toString())) {             XmlWriter xml = new XmlWriter();             xml.start("CreateBucketConfiguration", "xmlns", Constants.XML_NAMESPACE);             xml.start("LocationConstraint").value(region).end();             xml.end();              request.setContent(new ByteArrayInputStream(xml.getBytes()));         }          invoke(request, voidResponseHandler, bucketName, null);          return new Bucket(bucketName);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectAcl(bucketName, key, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectAcl(java.lang.String, java.lang.String, java.lang.String)      */     public AccessControlList getObjectAcl(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's ACL");          return getAcl(bucketName, key, versionId, null);     }      @Override     public void setObjectAcl(String bucketName, String key, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl(bucketName, key, null, acl);     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             AccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setObjectAcl(String bucketName, String key, String versionId, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setObjectAcl0(bucketName, key, versionId, acl, null);     }      /**      * Same as {@link #setObjectAcl(String, String, String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setObjectAcl(String bucketName, String key, String versionId,             CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setObjectAcl0(bucketName, key, versionId, acl, requestMetricCollector);     }      private void setObjectAcl0(String bucketName, String key, String versionId,             CannedAccessControlList acl, RequestMetricCollector requestMetricCollector)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting an object's ACL");         assertParameterNotNull(key, "The key parameter must be specified when setting an object's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting an object's ACL");          setAcl(bucketName, key, versionId, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(java.lang.String)      */     public AccessControlList getBucketAcl(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketAcl(com.amazonaws.services.s3.GetBucketAclRequest)      */     public AccessControlList getBucketAcl(GetBucketAclRequest getBucketAclRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketAclRequest.getBucketName();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting a bucket's ACL");          return getAcl(bucketName, null, null, getBucketAclRequest);     }      @Override     public void setBucketAcl(String bucketName, AccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, AccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, AccessControlList acl,             RequestMetricCollector requestMetricCollector) {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(requestMetricCollector));     }      @Override     public void setBucketAcl(SetBucketAclRequest setBucketAclRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketAclRequest.getBucketName();         AccessControlList acl = setBucketAclRequest.getAcl();         CannedAccessControlList cannedAcl = setBucketAclRequest.getCannedAcl();         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");          if (acl != null) {             setAcl(bucketName, null, null, acl, setBucketAclRequest);         } else if (cannedAcl != null) {             setAcl(bucketName, null, null, cannedAcl, setBucketAclRequest);         } else {             assertParameterNotNull(null, "The ACL parameter must be specified when setting a bucket's ACL");         }     }      @Override     public void setBucketAcl(String bucketName, CannedAccessControlList acl)             throws AmazonClientException, AmazonServiceException {         setBucketAcl0(bucketName, acl, null);     }      /**      * Same as {@link #setBucketAcl(String, CannedAccessControlList)}      * but allows specifying a request metric collector.      */     public void setBucketAcl(String bucketName, CannedAccessControlList acl,             RequestMetricCollector requestMetricCollector) throws AmazonClientException,             AmazonServiceException {         setBucketAcl0(bucketName, acl, requestMetricCollector);     }      private void setBucketAcl0(String bucketName, CannedAccessControlList acl,             RequestMetricCollector col) throws AmazonClientException,             AmazonServiceException {         assertParameterNotNull(bucketName, "The bucket name parameter must be specified when setting a bucket's ACL");         assertParameterNotNull(acl, "The ACL parameter must be specified when setting a bucket's ACL");          setAcl(bucketName, null, null, acl,             new GenericBucketRequest(bucketName)                 .withRequestMetricCollector(col));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(java.lang.String, java.lang.String)      */     public ObjectMetadata getObjectMetadata(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObjectMetadata(new GetObjectMetadataRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObjectMetadata(com.amazonaws.services.s3.model.GetObjectMetadataRequest)      */     public ObjectMetadata getObjectMetadata(GetObjectMetadataRequest getObjectMetadataRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectMetadataRequest, "The GetObjectMetadataRequest parameter must be specified when requesting an object's metadata");          String bucketName = getObjectMetadataRequest.getBucketName();         String key = getObjectMetadataRequest.getKey();         String versionId = getObjectMetadataRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when requesting an object's metadata");         assertParameterNotNull(key, "The key parameter must be specified when requesting an object's metadata");          Request<GetObjectMetadataRequest> request = createRequest(bucketName, key, getObjectMetadataRequest, HttpMethodName.HEAD);         if (versionId != null) request.addParameter("versionId", versionId);          populateSseCpkRequestParameters(request, getObjectMetadataRequest.getSSECustomerKey());          return invoke(request, new S3MetadataResponseHandler(), bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(java.lang.String, java.lang.String)      */     public S3Object getObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         return getObject(new GetObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#doesBucketExist(java.lang.String)      */     public boolean doesBucketExist(String bucketName)             throws AmazonClientException, AmazonServiceException {          try {             headBucket(new HeadBucketRequest(bucketName));             return true;         } catch (AmazonServiceException ase) {             // A redirect error or a forbidden error means the bucket exists. So             // returning true.             if ((ase.getStatusCode() == Constants.BUCKET_REDIRECT_STATUS_CODE)                     || (ase.getStatusCode() == Constants.BUCKET_ACCESS_FORBIDDEN_STATUS_CODE)) {                 return true;             }             if (ase.getStatusCode() == Constants.NO_SUCH_BUCKET_STATUS_CODE) {                 return false;             }             throw ase;          }     }       /**      * Performs a head bucket operation on the requested bucket name. This is      * done to check if the bucket exists and the user has permissions to access      * it.      *      * @param headBucketRequest The request containing the bucket name.      * @throws AmazonClientException      * @throws AmazonServiceException      */     private void headBucket(HeadBucketRequest headBucketRequest)             throws AmazonClientException, AmazonServiceException {          String bucketName = headBucketRequest.getBucketName();          assertParameterNotNull(bucketName,                 "The bucketName parameter must be specified.");          Request<HeadBucketRequest> request = createRequest(bucketName, null,                 headBucketRequest, HttpMethodName.HEAD);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#changeStorageClass(java.lang.String, java.lang.String, java.lang.String)      */     public void changeObjectStorageClass(String bucketName, String key, StorageClass newStorageClass)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newStorageClass,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withStorageClass(newStorageClass.toString()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setObjectRedirectLocation(java.lang.String, java.lang.String, java.lang.String)      */     public void setObjectRedirectLocation(String bucketName, String key, String newRedirectLocation)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucketName parameter must be specified when changing an object's storage class");         assertParameterNotNull(key,             "The key parameter must be specified when changing an object's storage class");         assertParameterNotNull(newRedirectLocation,             "The newStorageClass parameter must be specified when changing an object's storage class");          copyObject(new CopyObjectRequest(bucketName, key, bucketName, key)             .withRedirectLocation(newRedirectLocation));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest)      */     public S3Object getObject(GetObjectRequest getObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getObjectRequest,                 "The GetObjectRequest parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getBucketName(),                 "The bucket name parameter must be specified when requesting an object");         assertParameterNotNull(getObjectRequest.getKey(),                 "The key parameter must be specified when requesting an object");          Request<GetObjectRequest> request = createRequest(getObjectRequest.getBucketName(), getObjectRequest.getKey(), getObjectRequest, HttpMethodName.GET);          if (getObjectRequest.getVersionId() != null) {             request.addParameter("versionId", getObjectRequest.getVersionId());         }          // Range         long[] range = getObjectRequest.getRange();         if (range != null) {             request.addHeader(Headers.RANGE, "bytes=" + Long.toString(range[0]) + "-" + Long.toString(range[1]));         }          if (getObjectRequest.isRequesterPays()) {             request.addHeader(Headers.REQUESTER_PAYS_HEADER,                     Constants.REQUESTER_PAYS);         }          addResponseHeaderParameters(request, getObjectRequest.getResponseHeaders());          addDateHeader(request, Headers.GET_OBJECT_IF_MODIFIED_SINCE,                 getObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.GET_OBJECT_IF_UNMODIFIED_SINCE,                 getObjectRequest.getUnmodifiedSinceConstraint());         addStringListHeader(request, Headers.GET_OBJECT_IF_MATCH,                 getObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.GET_OBJECT_IF_NONE_MATCH,                 getObjectRequest.getNonmatchingETagConstraints());          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, getObjectRequest.getSSECustomerKey());          /*          * This is compatible with progress listener set by either the legacy          * method GetObjectRequest#setProgressListener or the new method          * GetObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = getObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          try {             S3Object s3Object = invoke(request, new S3ObjectResponseHandler(), getObjectRequest.getBucketName(), getObjectRequest.getKey());              /*              * TODO: For now, it's easiest to set there here in the client, but              *       we could push this back into the response handler with a              *       little more work.              */             s3Object.setBucketName(getObjectRequest.getBucketName());             s3Object.setKey(getObjectRequest.getKey());              InputStream input = s3Object.getObjectContent();             HttpRequestBase httpRequest = s3Object.getObjectContent().getHttpRequest();              // Hold a reference to this client while the InputStream is still             // around - otherwise a finalizer in the HttpClient may reset the             // underlying TCP connection out from under us.             input = new ServiceClientHolderInputStream(input, this);              // If someone is interested in progress updates, wrap the input             // stream in a filter that will trigger progress reports.             if (progressListenerCallbackExecutor != null) {                 @SuppressWarnings("resource")                 ProgressReportingInputStream progressReportingInputStream = new ProgressReportingInputStream(                         input, progressListenerCallbackExecutor);                 progressReportingInputStream.setFireCompletedEvent(true);                 input = progressReportingInputStream;                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);             }              // The Etag header contains a server-side MD5 of the object. If             // we're downloading the whole object, by default we wrap the             // stream in a validator that calculates an MD5 of the downloaded             // bytes and complains if what we received doesn't match the Etag.             if ( !skipContentMd5IntegrityCheck(getObjectRequest) ) {                 byte[] serverSideHash = null;                 String etag = s3Object.getObjectMetadata().getETag();                 if (etag != null && ServiceUtils.isMultipartUploadETag(etag) == false) {                     serverSideHash = BinaryUtils.fromHex(s3Object.getObjectMetadata().getETag());                     try {                         // No content length check is performed when the                         // MD5 check is enabled, since a correct MD5 check would                         // imply a correct content length.                         MessageDigest digest = MessageDigest.getInstance("MD5");                         input = new DigestValidationInputStream(input, digest, serverSideHash);                     } catch (NoSuchAlgorithmException e) {                         log.warn("No MD5 digest algorithm available.  Unable to calculate "                                     + "checksum and verify data integrity.", e);                     }                 }             } else {                 // Ensures the data received from S3 has the same length as the                 // expected content-length                 input = new LengthCheckInputStream(input,                     s3Object.getObjectMetadata().getContentLength(), // expected length                     INCLUDE_SKIPPED_BYTES); // bytes received from S3 are all included even if skipped             }              // Re-wrap within an S3ObjectInputStream. Explicitly do not collect             // metrics here because we know we're ultimately wrapping another             // S3ObjectInputStream which will take care of that.             s3Object.setObjectContent(new S3ObjectInputStream(input, httpRequest, false));              return s3Object;         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == 412 || ase.getStatusCode() == 304) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.CANCELED_EVENT_CODE);                 return null;             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);              throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getObject(com.amazonaws.services.s3.model.GetObjectRequest, java.io.File)      */     public ObjectMetadata getObject(final GetObjectRequest getObjectRequest, File destinationFile)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(destinationFile,                 "The destination file parameter must be specified when downloading an object directly to a file");          S3Object s3Object = ServiceUtils.retryableDownloadS3ObjectToFile(destinationFile, new ServiceUtils.RetryableS3DownloadTask() {              @Override             public S3Object getS3ObjectStream() {                 return getObject(getObjectRequest);             }              @Override             public boolean needIntegrityCheck() {                 return !skipContentMd5IntegrityCheck(getObjectRequest);             }          });         // getObject can return null if constraints were specified but not met         if (s3Object == null) return null;          return s3Object.getObjectMetadata();     }      /**      * Returns whether the specified request should skip MD5 check on the      * requested object content.      */     private static boolean skipContentMd5IntegrityCheck(AmazonWebServiceRequest request) {         if (System.getProperty("com.amazonaws.services.s3.disableGetObjectMD5Validation") != null)             return true;          if (request instanceof GetObjectRequest) {             GetObjectRequest getObjectRequest = (GetObjectRequest)request;             // Skip MD5 check for range get             if (getObjectRequest.getRange() != null)                 return true;              if (getObjectRequest.getSSECustomerKey() != null)                 return true;         } else if (request instanceof PutObjectRequest) {             PutObjectRequest putObjectRequest = (PutObjectRequest)request;             return putObjectRequest.getSSECustomerKey() != null;         } else if (request instanceof UploadPartRequest) {             UploadPartRequest uploadPartRequest = (UploadPartRequest)request;             return uploadPartRequest.getSSECustomerKey() != null;         }          return false;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(java.lang.String)      */     public void deleteBucket(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucket(new DeleteBucketRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucket(com.amazonaws.services.s3.model.DeleteBucketRequest)      */     public void deleteBucket(DeleteBucketRequest deleteBucketRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketRequest,                 "The DeleteBucketRequest parameter must be specified when deleting a bucket");          String bucketName = deleteBucketRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting a bucket");          Request<DeleteBucketRequest> request = createRequest(bucketName, null, deleteBucketRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.File)      */     public PutObjectResult putObject(String bucketName, String key, File file)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, file)             .withMetadata(new ObjectMetadata()));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(java.lang.String, java.lang.String, java.io.InputStream, com.amazonaws.services.s3.model.S3ObjectMetadata)      */     public PutObjectResult putObject(String bucketName, String key, InputStream input, ObjectMetadata metadata)             throws AmazonClientException, AmazonServiceException {         return putObject(new PutObjectRequest(bucketName, key, input, metadata));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#putObject(com.amazonaws.services.s3.model.PutObjectRequest)      */     public PutObjectResult putObject(PutObjectRequest putObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(putObjectRequest, "The PutObjectRequest parameter must be specified when uploading an object");          String bucketName = putObjectRequest.getBucketName();         String key = putObjectRequest.getKey();         ObjectMetadata metadata = putObjectRequest.getMetadata();         InputStream input = putObjectRequest.getInputStream();          /*          * This is compatible with progress listener set by either the legacy          * method PutObjectRequest#setProgressListener or the new method          * PutObjectRequest#setGeneralProgressListener.          */         ProgressListener progressListener = putObjectRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (metadata == null) metadata = new ObjectMetadata();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when uploading an object");         assertParameterNotNull(key, "The key parameter must be specified when uploading an object");          final boolean skipContentMd5Check = skipContentMd5IntegrityCheck(putObjectRequest);          // If a file is specified for upload, we need to pull some additional         // information from it to auto-configure a few options         if (putObjectRequest.getFile() != null) {             File file = putObjectRequest.getFile();             // Always set the content length, even if it's already set             metadata.setContentLength(file.length());              // Only set the content type if it hasn't already been set             if (metadata.getContentType() == null) {                 metadata.setContentType(Mimetypes.getInstance().getMimetype(file));             }              if (metadata.getContentMD5() == null && !skipContentMd5Check) {                 try {                     String contentMd5_b64 = Md5Utils.md5AsBase64(file);                     metadata.setContentMD5(contentMd5_b64);                 } catch (Exception e) {                     throw new AmazonClientException(                             "Unable to calculate MD5 hash: " + e.getMessage(), e);                 }             }              try {                 input = new RepeatableFileInputStream(file);             } catch (FileNotFoundException fnfe) {                 throw new AmazonClientException("Unable to find file to upload", fnfe);             }         }          Request<PutObjectRequest> request = createRequest(bucketName, key, putObjectRequest, HttpMethodName.PUT);          if ( putObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, putObjectRequest.getAccessControlList());         } else if ( putObjectRequest.getCannedAcl() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, putObjectRequest.getCannedAcl().toString());         }          if (putObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, putObjectRequest.getStorageClass());         }          if (putObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, putObjectRequest.getRedirectLocation());             if (input == null) {                 input = new ByteArrayInputStream(new byte[0]);             }         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, putObjectRequest.getSSECustomerKey());          // Use internal interface to differentiate 0 from unset.         final Long contentLength = (Long)metadata.getRawMetadataValue(Headers.CONTENT_LENGTH);         if (contentLength == null) {             /*              * There's nothing we can do except for let the HTTP client buffer              * the input stream contents if the caller doesn't tell us how much              * data to expect in a stream since we have to explicitly tell              * Amazon S3 how much we're sending before we start sending any of              * it.              */             log.warn("No content length specified for stream data.  " +                      "Stream contents will be buffered in memory and could result in " +                      "out of memory errors.");         } else {             final long expectedLength = contentLength.longValue();             if (expectedLength >= 0) {                 // Performs length check on the underlying data stream.                 // For S3 encryption client, the underlying data stream here                 // refers to the cipher-text data stream (ie not the underlying                 // plain-text data stream which in turn may have been wrapped                 // with it's own length check input stream.)                 @SuppressWarnings("resource")                 LengthCheckInputStream lcis = new LengthCheckInputStream(                     input,                     expectedLength, // expected data length to be uploaded                     EXCLUDE_SKIPPED_BYTES);                 input = lcis;             }         }          if (progressListenerCallbackExecutor != null) {             input = new ProgressReportingInputStream(input, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.STARTED_EVENT_CODE);         }          if (!input.markSupported()) {             int streamBufferSize = Constants.DEFAULT_STREAM_BUFFER_SIZE;             String bufferSizeOverride = System.getProperty("com.amazonaws.sdk.s3.defaultStreamBufferSize");             if (bufferSizeOverride != null) {                 try {                     streamBufferSize = Integer.parseInt(bufferSizeOverride);                 } catch (Exception e) {                     log.warn("Unable to parse buffer size override from value: " + bufferSizeOverride);                 }             }              input = new RepeatableInputStream(input, streamBufferSize);         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if (metadata.getContentMD5() == null                 && !skipContentMd5Check ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             input = md5DigestStream = new MD5DigestCalculatingInputStream(input);         }          if (metadata.getContentType() == null) {             /*              * Default to the "application/octet-stream" if the user hasn't              * specified a content type.              */             metadata.setContentType(Mimetypes.MIMETYPE_OCTET_STREAM);         }          populateRequestMetadata(request, metadata);         request.setContent(input);          ObjectMetadata returnedMetadata = null;         try {             returnedMetadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);             throw ace;         } finally {             try {                 input.close();             } catch (AbortedException ignore) {             } catch (Exception e) {                 log.debug("Unable to cleanly close input stream: " + e.getMessage(), e);             }         }          String contentMd5 = metadata.getContentMD5();         if (md5DigestStream != null) {             contentMd5 = BinaryUtils.toBase64(md5DigestStream.getMd5Digest());         }          if (returnedMetadata != null && contentMd5 != null && !skipContentMd5Check) {             byte[] clientSideHash = BinaryUtils.fromBase64(contentMd5);             byte[] serverSideHash = BinaryUtils.fromHex(returnedMetadata.getETag());              if (!Arrays.equals(clientSideHash, serverSideHash)) {                 fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.FAILED_EVENT_CODE);                  throw new AmazonClientException("Unable to verify integrity of data upload.  " +                         "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                         "You may need to delete the data stored in Amazon S3.");             }         }          fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.COMPLETED_EVENT_CODE);          PutObjectResult result = new PutObjectResult();         result.setETag(returnedMetadata.getETag());         result.setVersionId(returnedMetadata.getVersionId());         result.setSSEAlgorithm(returnedMetadata.getSSEAlgorithm());         result.setSSECustomerAlgorithm(returnedMetadata.getSSECustomerAlgorithm());         result.setSSECustomerKeyMd5(returnedMetadata.getSSECustomerKeyMd5());         result.setExpirationTime(returnedMetadata.getExpirationTime());         result.setExpirationTimeRuleId(returnedMetadata.getExpirationTimeRuleId());         result.setContentMd5(contentMd5);          return result;     }      /**      * Sets the acccess control headers for the request given.      */     private static void addAclHeaders(Request<? extends AmazonWebServiceRequest> request, AccessControlList acl) {         Set<Grant> grants = acl.getGrants();         Map<Permission, Collection<Grantee>> grantsByPermission = new HashMap<Permission, Collection<Grantee>>();         for ( Grant grant : grants ) {             if ( !grantsByPermission.containsKey(grant.getPermission()) ) {                 grantsByPermission.put(grant.getPermission(), new LinkedList<Grantee>());             }             grantsByPermission.get(grant.getPermission()).add(grant.getGrantee());         }         for ( Permission permission : Permission.values() ) {             if ( grantsByPermission.containsKey(permission) ) {                 Collection<Grantee> grantees = grantsByPermission.get(permission);                 boolean seenOne = false;                 StringBuilder granteeString = new StringBuilder();                 for ( Grantee grantee : grantees ) {                     if ( !seenOne )                         seenOne = true;                     else                         granteeString.append(", ");                     granteeString.append(grantee.getTypeIdentifier()).append("=").append("\"")                             .append(grantee.getIdentifier()).append("\"");                 }                 request.addHeader(permission.getHeaderName(), granteeString.toString());             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(java.lang.String, java.lang.String, java.lang.String, java.lang.String)      */     public CopyObjectResult copyObject(String sourceBucketName, String sourceKey,                                        String destinationBucketName, String destinationKey)             throws AmazonClientException, AmazonServiceException {         return copyObject(new CopyObjectRequest(sourceBucketName, sourceKey,                                                 destinationBucketName, destinationKey));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyObject(com.amazonaws.services.s3.model.CopyObjectRequest)      */     public CopyObjectResult copyObject(CopyObjectRequest copyObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(copyObjectRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getSourceKey(),                 "The source object key must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying an object");         assertParameterNotNull(copyObjectRequest.getDestinationKey(),                 "The destination object key must be specified when copying an object");          String destinationKey = copyObjectRequest.getDestinationKey();         String destinationBucketName = copyObjectRequest.getDestinationBucketName();          Request<CopyObjectRequest> request = createRequest(destinationBucketName, destinationKey, copyObjectRequest, HttpMethodName.PUT);          populateRequestWithCopyObjectParameters(request, copyObjectRequest);         /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler(),                     new ObjectExpirationHeaderHandler<CopyObjectResultHandler>());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch (AmazonS3Exception ase) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if (ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE) {                return null;             }              throw ase;         }          /*          * CopyObject has two failure modes:          *  1 - An HTTP error code is returned and the error is processed like any          *      other error response.          *  2 - An HTTP 200 OK code is returned, but the response content contains          *      an XML error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response.  We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this          * one special case.          */         if (copyObjectResultHandler.getErrorCode() != null) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          // TODO: Might be nice to create this in our custom S3VersionHeaderHandler         CopyObjectResult copyObjectResult = new CopyObjectResult();         copyObjectResult.setETag(copyObjectResultHandler.getETag());         copyObjectResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyObjectResult.setVersionId(copyObjectResultHandler.getVersionId());         copyObjectResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyObjectResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyObjectResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());         copyObjectResult.setExpirationTime(copyObjectResultHandler.getExpirationTime());         copyObjectResult.setExpirationTimeRuleId(copyObjectResultHandler.getExpirationTimeRuleId());          return copyObjectResult;     }      /**      * Copies a source object to a part of a multipart upload.      *      * To copy an object, the caller's account must have read access to the source object and      * write access to the destination bucket.      * </p>      * <p>      * If constraints are specified in the <code>CopyPartRequest</code>      * (e.g.      * {@link CopyPartRequest#setMatchingETagConstraints(List)})      * and are not satisfied when Amazon S3 receives the      * request, this method returns <code>null</code>.      * This method returns a non-null result under all other      * circumstances.      * </p>      *      * @param copyPartRequest      *            The request object containing all the options for copying an      *            Amazon S3 object.      *      * @return A {@link CopyPartResult} object containing the information      *         returned by Amazon S3 about the newly created object, or <code>null</code> if      *         constraints were specified that weren't met when Amazon S3 attempted      *         to copy the object.      *      * @throws AmazonClientException      *             If any errors are encountered in the client while making the      *             request or handling the response.      * @throws AmazonServiceException      *             If any errors occurred in Amazon S3 while processing the      *             request.      *      * @see AmazonS3#copyObject(CopyObjectRequest)      * @see AmazonS3#initiateMultipartUpload(InitiateMultipartUploadRequest)      */     public CopyPartResult copyPart(CopyPartRequest copyPartRequest) {         assertParameterNotNull(copyPartRequest.getSourceBucketName(),                 "The source bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getSourceKey(),                 "The source object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationBucketName(),                 "The destination bucket name must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getUploadId(),                 "The upload id must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getDestinationKey(),                 "The destination object key must be specified when copying a part");         assertParameterNotNull(copyPartRequest.getPartNumber(),                 "The part number must be specified when copying a part");          String destinationKey = copyPartRequest.getDestinationKey();         String destinationBucketName = copyPartRequest.getDestinationBucketName();          Request<CopyPartRequest> request = createRequest(destinationBucketName, destinationKey, copyPartRequest,                 HttpMethodName.PUT);          populateRequestWithCopyPartParameters(request, copyPartRequest);          request.addParameter("uploadId", copyPartRequest.getUploadId());         request.addParameter("partNumber", Integer.toString(copyPartRequest.getPartNumber()));          /*          * We can't send a non-zero length Content-Length header if the user          * specified it, otherwise it messes up the HTTP connection when the          * remote server thinks there's more data to pull.          */         setZeroContentLength(request);         CopyObjectResultHandler copyObjectResultHandler = null;         try {             @SuppressWarnings("unchecked")             ResponseHeaderHandlerChain<CopyObjectResultHandler> handler = new ResponseHeaderHandlerChain<CopyObjectResultHandler>(                     // xml payload unmarshaller                     new Unmarshallers.CopyObjectUnmarshaller(),                     // header handlers                     new ServerSideEncryptionHeaderHandler<CopyObjectResultHandler>(),                     new S3VersionHeaderHandler());             copyObjectResultHandler = invoke(request, handler, destinationBucketName, destinationKey);         } catch ( AmazonS3Exception ase ) {             /*              * If the request failed because one of the specified constraints              * was not met (ex: matching ETag, modified since date, etc.), then              * return null, so that users don't have to wrap their code in              * try/catch blocks and check for this status code if they want to              * use constraints.              */             if ( ase.getStatusCode() == Constants.FAILED_PRECONDITION_STATUS_CODE ) {                 return null;             }              throw ase;         }          /*          * CopyPart has two failure modes: 1 - An HTTP error code is returned          * and the error is processed like any other error response. 2 - An HTTP          * 200 OK code is returned, but the response content contains an XML          * error response.          *          * This makes it very difficult for the client runtime to cleanly detect          * this case and handle it like any other error response. We could          * extend the runtime to have a more flexible/customizable definition of          * success/error (per request), but it's probably overkill for this one          * special case.          */         if ( copyObjectResultHandler.getErrorCode() != null ) {             String errorCode = copyObjectResultHandler.getErrorCode();             String errorMessage = copyObjectResultHandler.getErrorMessage();             String requestId = copyObjectResultHandler.getErrorRequestId();             String hostId = copyObjectResultHandler.getErrorHostId();              AmazonS3Exception ase = new AmazonS3Exception(errorMessage);             ase.setErrorCode(errorCode);             ase.setErrorType(ErrorType.Service);             ase.setRequestId(requestId);             ase.setExtendedRequestId(hostId);             ase.setServiceName(request.getServiceName());             ase.setStatusCode(200);              throw ase;         }          CopyPartResult copyPartResult = new CopyPartResult();         copyPartResult.setETag(copyObjectResultHandler.getETag());         copyPartResult.setPartNumber(copyPartRequest.getPartNumber());         copyPartResult.setLastModifiedDate(copyObjectResultHandler.getLastModified());         copyPartResult.setVersionId(copyObjectResultHandler.getVersionId());         copyPartResult.setSSEAlgorithm(copyObjectResultHandler.getSSEAlgorithm());         copyPartResult.setSSECustomerAlgorithm(copyObjectResultHandler.getSSECustomerAlgorithm());         copyPartResult.setSSECustomerKeyMd5(copyObjectResultHandler.getSSECustomerKeyMd5());          return copyPartResult;     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(java.lang.String, java.lang.String)      */     public void deleteObject(String bucketName, String key)             throws AmazonClientException, AmazonServiceException {         deleteObject(new DeleteObjectRequest(bucketName, key));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObject(com.amazonaws.services.s3.DeleteObjectRequest)      */     public void deleteObject(DeleteObjectRequest deleteObjectRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteObjectRequest,             "The delete object request must be specified when deleting an object");          assertParameterNotNull(deleteObjectRequest.getBucketName(), "The bucket name must be specified when deleting an object");         assertParameterNotNull(deleteObjectRequest.getKey(), "The key must be specified when deleting an object");          Request<DeleteObjectRequest> request = createRequest(deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey(), deleteObjectRequest, HttpMethodName.DELETE);         invoke(request, voidResponseHandler, deleteObjectRequest.getBucketName(), deleteObjectRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjects(com.amazonaws.services.s3.model.DeleteObjectsRequest)      */     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {         Request<DeleteObjectsRequest> request = createRequest(deleteObjectsRequest.getBucketName(), null, deleteObjectsRequest, HttpMethodName.POST);         request.addParameter("delete", null);          if ( deleteObjectsRequest.getMfa() != null ) {             populateRequestWithMfaDetails(request, deleteObjectsRequest.getMfa());         }          byte[] content = new MultiObjectDeleteXmlFactory().convertToXmlByteArray(deleteObjectsRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          DeleteObjectsResponse response = invoke(request, new Unmarshallers.DeleteObjectsResultUnmarshaller(), deleteObjectsRequest.getBucketName(), null);          /*          * If the result was only partially successful, throw an exception          */         if ( !response.getErrors().isEmpty() ) {             throw new MultiObjectDeleteException(response.getErrors(), response.getDeletedObjects());         }          return new DeleteObjectsResult(response.getDeletedObjects());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteObjectVersion(java.lang.String, java.lang.String, java.lang.String)      */     public void deleteVersion(String bucketName, String key, String versionId)             throws AmazonClientException, AmazonServiceException {         deleteVersion(new DeleteVersionRequest(bucketName, key, versionId));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteVersion(com.amazonaws.services.s3.model.DeleteVersionRequest)      */     public void deleteVersion(DeleteVersionRequest deleteVersionRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteVersionRequest,             "The delete version request object must be specified when deleting a version");          String bucketName = deleteVersionRequest.getBucketName();         String key = deleteVersionRequest.getKey();         String versionId = deleteVersionRequest.getVersionId();          assertParameterNotNull(bucketName, "The bucket name must be specified when deleting a version");         assertParameterNotNull(key, "The key must be specified when deleting a version");         assertParameterNotNull(versionId, "The version ID must be specified when deleting a version");          Request<DeleteVersionRequest> request = createRequest(bucketName, key, deleteVersionRequest, HttpMethodName.DELETE);         if (versionId != null) request.addParameter("versionId", versionId);          if (deleteVersionRequest.getMfa() != null) {             populateRequestWithMfaDetails(request, deleteVersionRequest.getMfa());         }          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketVersioningConfiguration(com.amazonaws.services.s3.model.SetBucketVersioningConfigurationRequest)      */     public void setBucketVersioningConfiguration(SetBucketVersioningConfigurationRequest setBucketVersioningConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketVersioningConfigurationRequest,             "The SetBucketVersioningConfigurationRequest object must be specified when setting versioning configuration");          String bucketName = setBucketVersioningConfigurationRequest.getBucketName();         BucketVersioningConfiguration versioningConfiguration = setBucketVersioningConfigurationRequest.getVersioningConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when setting versioning configuration");         assertParameterNotNull(versioningConfiguration,             "The bucket versioning parameter must be specified when setting versioning configuration");         if (versioningConfiguration.isMfaDeleteEnabled() != null) {             assertParameterNotNull(setBucketVersioningConfigurationRequest.getMfa(),                 "The MFA parameter must be specified when changing MFA Delete status in the versioning configuration");         }          Request<SetBucketVersioningConfigurationRequest> request = createRequest(bucketName, null, setBucketVersioningConfigurationRequest, HttpMethodName.PUT);         request.addParameter("versioning", null);          if (versioningConfiguration.isMfaDeleteEnabled() != null) {             if (setBucketVersioningConfigurationRequest.getMfa() != null) {                 populateRequestWithMfaDetails(request, setBucketVersioningConfigurationRequest.getMfa());             }         }          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(versioningConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketVersioningConfiguration(java.lang.String)      */     public BucketVersioningConfiguration getBucketVersioningConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying versioning configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("versioning", null);          return invoke(request, new Unmarshallers.BucketVersioningConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(java.lang.String)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketWebsiteConfiguration(new GetBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketWebsiteConfiguration(com.amazonaws.services.s3.model.GetBucketWebsiteConfigurationRequest)      */     public BucketWebsiteConfiguration getBucketWebsiteConfiguration(GetBucketWebsiteConfigurationRequest getBucketWebsiteConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         String bucketName = getBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when requesting a bucket's website configuration");          Request<GetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, getBucketWebsiteConfigurationRequest, HttpMethodName.GET);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          try {             return invoke(request, new Unmarshallers.BucketWebsiteConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             if (ase.getStatusCode() == 404) return null;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLifecycleConfiguration(java.lang.String)      */     public BucketLifecycleConfiguration getBucketLifecycleConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("lifecycle", null);          try {             return invoke(request, new Unmarshallers.BucketLifecycleConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketLifecycleConfiguration(String bucketName, BucketLifecycleConfiguration bucketLifecycleConfiguration) {         setBucketLifecycleConfiguration(new SetBucketLifecycleConfigurationRequest(bucketName, bucketLifecycleConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLifecycleConfiguration(com.amazonaws.services.s3.model.SetBucketLifecycleConfigurationRequest)      */     public void setBucketLifecycleConfiguration(             SetBucketLifecycleConfigurationRequest setBucketLifecycleConfigurationRequest) {         assertParameterNotNull(setBucketLifecycleConfigurationRequest,                 "The set bucket lifecycle configuration request object must be specified.");          String bucketName = setBucketLifecycleConfigurationRequest.getBucketName();         BucketLifecycleConfiguration bucketLifecycleConfiguration = setBucketLifecycleConfigurationRequest.getLifecycleConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket lifecycle configuration.");         assertParameterNotNull(bucketLifecycleConfiguration,                 "The lifecycle configuration parameter must be specified when setting bucket lifecycle configuration.");          Request<SetBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, setBucketLifecycleConfigurationRequest, HttpMethodName.PUT);         request.addParameter("lifecycle", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketLifecycleConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(java.lang.String)      */     public void deleteBucketLifecycleConfiguration(String bucketName) {         deleteBucketLifecycleConfiguration(new DeleteBucketLifecycleConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketLifecycleConfiguration(com.amazonaws.services.s3.model.DeleteBucketLifecycleConfigurationRequest)      */     public void deleteBucketLifecycleConfiguration(             DeleteBucketLifecycleConfigurationRequest deleteBucketLifecycleConfigurationRequest) {         assertParameterNotNull(deleteBucketLifecycleConfigurationRequest,                 "The delete bucket lifecycle configuration request object must be specified.");          String bucketName = deleteBucketLifecycleConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket lifecycle configuration.");          Request<DeleteBucketLifecycleConfigurationRequest> request = createRequest(bucketName, null, deleteBucketLifecycleConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("lifecycle", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketCrossOriginConfiguration(java.lang.String)      */     public BucketCrossOriginConfiguration getBucketCrossOriginConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("cors", null);          try {             return invoke(request, new Unmarshallers.BucketCrossOriginConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketCrossOriginConfiguration)      */     public void setBucketCrossOriginConfiguration(String bucketName, BucketCrossOriginConfiguration bucketCrossOriginConfiguration) {         setBucketCrossOriginConfiguration(new SetBucketCrossOriginConfigurationRequest(bucketName, bucketCrossOriginConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.SetBucketCrossOriginConfigurationRequest)      */     public void setBucketCrossOriginConfiguration(             SetBucketCrossOriginConfigurationRequest setBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(setBucketCrossOriginConfigurationRequest,                 "The set bucket cross origin configuration request object must be specified.");          String bucketName = setBucketCrossOriginConfigurationRequest.getBucketName();         BucketCrossOriginConfiguration bucketCrossOriginConfiguration = setBucketCrossOriginConfigurationRequest.getCrossOriginConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket cross origin configuration.");         assertParameterNotNull(bucketCrossOriginConfiguration,                 "The cross origin configuration parameter must be specified when setting bucket cross origin configuration.");          Request<SetBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, setBucketCrossOriginConfigurationRequest, HttpMethodName.PUT);         request.addParameter("cors", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketCrossOriginConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(java.lang.String)      */     public void deleteBucketCrossOriginConfiguration(String bucketName) {         deleteBucketCrossOriginConfiguration(new DeleteBucketCrossOriginConfigurationRequest(bucketName));       }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketCrossOriginConfiguration(com.amazonaws.services.s3.model.DeleteBucketCrossOriginConfigurationRequest)      */     public void deleteBucketCrossOriginConfiguration(             DeleteBucketCrossOriginConfigurationRequest deleteBucketCrossOriginConfigurationRequest) {         assertParameterNotNull(deleteBucketCrossOriginConfigurationRequest,                 "The delete bucket cross origin configuration request object must be specified.");          String bucketName = deleteBucketCrossOriginConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket cross origin configuration.");          Request<DeleteBucketCrossOriginConfigurationRequest> request = createRequest(bucketName, null, deleteBucketCrossOriginConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("cors", null);         invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketTaggingConfiguration(java.lang.String)      */     public BucketTaggingConfiguration getBucketTaggingConfiguration(String bucketName) {         Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("tagging", null);          try {             return invoke(request, new Unmarshallers.BucketTaggingConfigurationUnmarshaller(), bucketName, null);         } catch (AmazonServiceException ase) {             switch (ase.getStatusCode()) {             case 404:                 return null;             default:                 throw ase;             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketLifecycleConfiguration)      */     public void setBucketTaggingConfiguration(String bucketName, BucketTaggingConfiguration bucketTaggingConfiguration) {         setBucketTaggingConfiguration(new SetBucketTaggingConfigurationRequest(bucketName, bucketTaggingConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketTaggingConfiguration(com.amazonaws.services.s3.model.SetBucketTaggingConfigurationRequest)      */     public void setBucketTaggingConfiguration(             SetBucketTaggingConfigurationRequest setBucketTaggingConfigurationRequest) {         assertParameterNotNull(setBucketTaggingConfigurationRequest,                 "The set bucket tagging configuration request object must be specified.");          String bucketName = setBucketTaggingConfigurationRequest.getBucketName();         BucketTaggingConfiguration bucketTaggingConfiguration = setBucketTaggingConfigurationRequest.getTaggingConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket tagging configuration.");         assertParameterNotNull(bucketTaggingConfiguration,                 "The tagging configuration parameter must be specified when setting bucket tagging configuration.");          Request<SetBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, setBucketTaggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("tagging", null);          byte[] content = new BucketConfigurationXmlFactory().convertToXmlByteArray(bucketTaggingConfiguration);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch ( Exception e ) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(java.lang.String)      */     public void deleteBucketTaggingConfiguration(String bucketName) {         deleteBucketTaggingConfiguration(new DeleteBucketTaggingConfigurationRequest(bucketName));     }       /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketTaggingConfiguration(com.amazonaws.services.s3.model.DeleteBucketTaggingConfigurationRequest)      */     public void deleteBucketTaggingConfiguration(             DeleteBucketTaggingConfigurationRequest deleteBucketTaggingConfigurationRequest) {         assertParameterNotNull(deleteBucketTaggingConfigurationRequest,                 "The delete bucket tagging configuration request object must be specified.");          String bucketName = deleteBucketTaggingConfigurationRequest.getBucketName();         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when deleting bucket tagging configuration.");          Request<DeleteBucketTaggingConfigurationRequest> request = createRequest(bucketName, null, deleteBucketTaggingConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("tagging", null);          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(java.lang.String, com.amazonaws.services.s3.model.BucketWebsiteConfiguration)      */     public void setBucketWebsiteConfiguration(String bucketName, BucketWebsiteConfiguration configuration)             throws AmazonClientException, AmazonServiceException {         setBucketWebsiteConfiguration(new SetBucketWebsiteConfigurationRequest(bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketWebsiteConfiguration(com.amazonaws.services.s3.model.SetBucketWebsiteConfigurationRequest)      */     public void setBucketWebsiteConfiguration(SetBucketWebsiteConfigurationRequest setBucketWebsiteConfigurationRequest)            throws AmazonClientException, AmazonServiceException {         String bucketName = setBucketWebsiteConfigurationRequest.getBucketName();         BucketWebsiteConfiguration configuration = setBucketWebsiteConfigurationRequest.getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting a bucket's website configuration");         assertParameterNotNull(configuration,                 "The bucket website configuration parameter must be specified when setting a bucket's website configuration");         if (configuration.getRedirectAllRequestsTo() == null) {         assertParameterNotNull(configuration.getIndexDocumentSuffix(),                 "The bucket website configuration parameter must specify the index document suffix when setting a bucket's website configuration");         }          Request<SetBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, setBucketWebsiteConfigurationRequest, HttpMethodName.PUT);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(java.lang.String)      */     public void deleteBucketWebsiteConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketWebsiteConfiguration(new DeleteBucketWebsiteConfigurationRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketWebsiteConfiguration(com.amazonaws.services.s3.model.DeleteBucketWebsiteConfigurationRequest)      */     public void deleteBucketWebsiteConfiguration(DeleteBucketWebsiteConfigurationRequest deleteBucketWebsiteConfigurationRequest)         throws AmazonClientException, AmazonServiceException {         String bucketName = deleteBucketWebsiteConfigurationRequest.getBucketName();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when deleting a bucket's website configuration");          Request<DeleteBucketWebsiteConfigurationRequest> request = createRequest(bucketName, null, deleteBucketWebsiteConfigurationRequest, HttpMethodName.DELETE);         request.addParameter("website", null);         request.addHeader("Content-Type", "application/xml");          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(java.lang.String,com.amazonaws.services.s3.model.BucketNotificationConfiguration)      */     public void setBucketNotificationConfiguration(String bucketName, BucketNotificationConfiguration bucketNotificationConfiguration)         throws AmazonClientException, AmazonServiceException {         setBucketNotificationConfiguration(new SetBucketNotificationConfigurationRequest(bucketName, bucketNotificationConfiguration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketNotificationConfiguration(com.amazonaws.services.s3.model.SetBucketNotificationConfigurationRequest)      */     public void setBucketNotificationConfiguration(             SetBucketNotificationConfigurationRequest setBucketNotificationConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketNotificationConfigurationRequest,                 "The set bucket notification configuration request object must be specified.");          String bucketName = setBucketNotificationConfigurationRequest.getBucketName();         BucketNotificationConfiguration bucketNotificationConfiguration = setBucketNotificationConfigurationRequest.getNotificationConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when setting bucket notification configuration.");         assertParameterNotNull(bucketNotificationConfiguration,                 "The notification configuration parameter must be specified when setting bucket notification configuration.");          Request<SetBucketNotificationConfigurationRequest> request = createRequest(bucketName, null, setBucketNotificationConfigurationRequest, HttpMethodName.PUT);         request.addParameter("notification", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(bucketNotificationConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketNotificationConfiguration(java.lang.String)      */     public BucketNotificationConfiguration getBucketNotificationConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when querying notification configuration");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("notification", null);          return invoke(request, new Unmarshallers.BucketNotificationConfigurationUnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketLoggingConfiguration(java.lang.String)      */     public BucketLoggingConfiguration getBucketLoggingConfiguration(String bucketName)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified when requesting a bucket's logging status");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.GET);         request.addParameter("logging", null);          return invoke(request, new Unmarshallers.BucketLoggingConfigurationnmarshaller(), bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketLoggingConfiguration(com.amazonaws.services.s3.SetBucketLoggingConfigurationRequest)      */     public void setBucketLoggingConfiguration(SetBucketLoggingConfigurationRequest setBucketLoggingConfigurationRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketLoggingConfigurationRequest,             "The set bucket logging configuration request object must be specified when enabling server access logging");          String bucketName = setBucketLoggingConfigurationRequest.getBucketName();         BucketLoggingConfiguration loggingConfiguration = setBucketLoggingConfigurationRequest.getLoggingConfiguration();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when enabling server access logging");         assertParameterNotNull(loggingConfiguration,             "The logging configuration parameter must be specified when enabling server access logging");          Request<SetBucketLoggingConfigurationRequest> request = createRequest(bucketName, null, setBucketLoggingConfigurationRequest, HttpMethodName.PUT);         request.addParameter("logging", null);          byte[] bytes = bucketConfigurationXmlFactory.convertToXmlByteArray(loggingConfiguration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(java.lang.String)      */     public BucketPolicy getBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         return getBucketPolicy(new GetBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(java.lang.String, java.lang.String)      */     public void setBucketPolicy(String bucketName, String policyText)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<GenericBucketRequest> request = createRequest(bucketName, null, new GenericBucketRequest(bucketName), HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(java.lang.String)      */     public void deleteBucketPolicy(String bucketName)             throws AmazonClientException, AmazonServiceException {         deleteBucketPolicy(new DeleteBucketPolicyRequest(bucketName));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getBucketPolicy(com.amazonaws.services.s3.model.GetBucketPolicyRequest)      */     public BucketPolicy getBucketPolicy(             GetBucketPolicyRequest getBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(getBucketPolicyRequest,             "The request object must be specified when getting a bucket policy");          String bucketName = getBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when getting a bucket policy");          Request<GetBucketPolicyRequest> request = createRequest(bucketName, null, getBucketPolicyRequest, HttpMethodName.GET);         request.addParameter("policy", null);          BucketPolicy result = new BucketPolicy();         try {             String policyText = invoke(request, new S3StringResponseHandler(), bucketName, null);             result.setPolicyText(policyText);             return result;         } catch (AmazonServiceException ase) {             /*              * If we receive an error response telling us that no policy has              * been set for this bucket, then instead of forcing the user to              * deal with the exception, we'll just return an empty result. Any              * other exceptions will be rethrown for the user to handle.              */             if (ase.getErrorCode().equals("NoSuchBucketPolicy")) return result;             throw ase;         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#setBucketPolicy(com.amazonaws.services.s3.model.SetBucketPolicyRequest)      */     public void setBucketPolicy(SetBucketPolicyRequest setBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(setBucketPolicyRequest,             "The request object must be specified when setting a bucket policy");          String bucketName = setBucketPolicyRequest.getBucketName();         String policyText = setBucketPolicyRequest.getPolicyText();          assertParameterNotNull(bucketName,             "The bucket name must be specified when setting a bucket policy");         assertParameterNotNull(policyText,             "The policy text must be specified when setting a bucket policy");          Request<SetBucketPolicyRequest> request = createRequest(bucketName, null, setBucketPolicyRequest, HttpMethodName.PUT);         request.addParameter("policy", null);         request.setContent(new ByteArrayInputStream(ServiceUtils.toByteArray(policyText)));          invoke(request, voidResponseHandler, bucketName, null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#deleteBucketPolicy(com.amazonaws.services.s3.model.DeleteBucketPolicyRequest)      */     public void deleteBucketPolicy(             DeleteBucketPolicyRequest deleteBucketPolicyRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(deleteBucketPolicyRequest,             "The request object must be specified when deleting a bucket policy");          String bucketName = deleteBucketPolicyRequest.getBucketName();         assertParameterNotNull(bucketName,             "The bucket name must be specified when deleting a bucket policy");          Request<DeleteBucketPolicyRequest> request = createRequest(bucketName, null, deleteBucketPolicyRequest, HttpMethodName.DELETE);         request.addParameter("policy", null);          invoke(request, voidResponseHandler, bucketName, null);     }        /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration)             throws AmazonClientException {         return generatePresignedUrl(bucketName, key, expiration, HttpMethod.GET);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date, com.amazonaws.HttpMethod)      */     public URL generatePresignedUrl(String bucketName, String key, Date expiration, HttpMethod method)             throws AmazonClientException {         GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key, method);         request.setExpiration(expiration);          return generatePresignedUrl(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#generatePresignedUrl(com.amazonaws.services.s3.model.GeneratePresignedUrlRequest)      */     public URL generatePresignedUrl(GeneratePresignedUrlRequest generatePresignedUrlRequest)             throws AmazonClientException {         assertParameterNotNull(generatePresignedUrlRequest,             "The request parameter must be specified when generating a pre-signed URL");          String bucketName = generatePresignedUrlRequest.getBucketName();         String key = generatePresignedUrlRequest.getKey();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when generating a pre-signed URL");         assertParameterNotNull(generatePresignedUrlRequest.getMethod(),             "The HTTP method request parameter must be specified when generating a pre-signed URL");          if (generatePresignedUrlRequest.getExpiration() == null) {             generatePresignedUrlRequest.setExpiration(                     new Date(System.currentTimeMillis() + 1000 * 60 * 15));         }          HttpMethodName httpMethod = HttpMethodName.valueOf(generatePresignedUrlRequest.getMethod().toString());          // If the key starts with a slash character itself, the following method         // will actually add another slash before the resource path to prevent         // the HttpClient mistakenly treating the slash as a path delimiter.         // For presigned request, we need to remember to remove this extra slash         // before generating the URL.         Request<GeneratePresignedUrlRequest> request = createRequest(bucketName, key, generatePresignedUrlRequest, httpMethod);          for (Entry<String, String> entry : generatePresignedUrlRequest.getRequestParameters().entrySet()) {             request.addParameter(entry.getKey(), entry.getValue());         }          if (generatePresignedUrlRequest.getContentType() != null) {             request.addHeader(Headers.CONTENT_TYPE, generatePresignedUrlRequest.getContentType());         }          if (generatePresignedUrlRequest.getContentMd5() != null) {             request.addHeader(Headers.CONTENT_MD5, generatePresignedUrlRequest.getContentMd5());         }          populateSseCpkRequestParameters(request, generatePresignedUrlRequest.getSSECustomerKey());          addResponseHeaderParameters(request, generatePresignedUrlRequest.getResponseHeaders());          Signer signer = createSigner(request, bucketName, key);          if (signer instanceof Presigner) {             // If we have a signer which knows how to presign requests,             // delegate directly to it.             ((Presigner) signer).presignRequest(                 request,                 awsCredentialsProvider.getCredentials(),                 generatePresignedUrlRequest.getExpiration()             );         } else {             // Otherwise use the default presigning method, which is hardcoded             // to use QueryStringSigner.             presignRequest(                 request,                 generatePresignedUrlRequest.getMethod(),                 bucketName,                 key,                 generatePresignedUrlRequest.getExpiration(),                 null             );         }          // Remove the leading slash (if any) in the resource-path         return ServiceUtils.convertRequestToUrl(request, true);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#abortMultipartUpload(com.amazonaws.services.s3.model.AbortMultipartUploadRequest)      */     public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(abortMultipartUploadRequest,             "The request parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getKey(),             "The key parameter must be specified when aborting a multipart upload");         assertParameterNotNull(abortMultipartUploadRequest.getUploadId(),             "The upload ID parameter must be specified when aborting a multipart upload");          String bucketName = abortMultipartUploadRequest.getBucketName();         String key = abortMultipartUploadRequest.getKey();          Request<AbortMultipartUploadRequest> request = createRequest(bucketName, key, abortMultipartUploadRequest, HttpMethodName.DELETE);         request.addParameter("uploadId", abortMultipartUploadRequest.getUploadId());          invoke(request, voidResponseHandler, bucketName, key);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#completeMultipartUpload(com.amazonaws.services.s3.model.CompleteMultipartUploadRequest)      */     public CompleteMultipartUploadResult completeMultipartUpload(             CompleteMultipartUploadRequest completeMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(completeMultipartUploadRequest,             "The request parameter must be specified when completing a multipart upload");          String bucketName = completeMultipartUploadRequest.getBucketName();         String key = completeMultipartUploadRequest.getKey();         String uploadId = completeMultipartUploadRequest.getUploadId();         assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when completing a multipart upload");         assertParameterNotNull(key,             "The key parameter must be specified when completing a multipart upload");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when completing a multipart upload");         assertParameterNotNull(completeMultipartUploadRequest.getPartETags(),             "The part ETags parameter must be specified when completing a multipart upload");          Request<CompleteMultipartUploadRequest> request = createRequest(bucketName, key, completeMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploadId", uploadId);          byte[] xml = RequestXmlFactory.convertToXmlByteArray(completeMultipartUploadRequest.getPartETags());         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(xml.length));          request.setContent(new ByteArrayInputStream(xml));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<CompleteMultipartUploadHandler> responseHandler = new ResponseHeaderHandlerChain<CompleteMultipartUploadHandler>(                 // xml payload unmarshaller                 new Unmarshallers.CompleteMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<CompleteMultipartUploadHandler>(),                 new ObjectExpirationHeaderHandler<CompleteMultipartUploadHandler>());         CompleteMultipartUploadHandler handler = invoke(request, responseHandler, bucketName, key);         if (handler.getCompleteMultipartUploadResult() != null) {             String versionId = responseHandler.getResponseHeaders().get(Headers.S3_VERSION_ID);             handler.getCompleteMultipartUploadResult().setVersionId(versionId);             return handler.getCompleteMultipartUploadResult();         } else {             throw handler.getAmazonS3Exception();         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#initiateMultipartUpload(com.amazonaws.services.s3.model.InitiateMultipartUploadRequest)      */     public InitiateMultipartUploadResult initiateMultipartUpload(             InitiateMultipartUploadRequest initiateMultipartUploadRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(initiateMultipartUploadRequest,             "The request parameter must be specified when initiating a multipart upload");          assertParameterNotNull(initiateMultipartUploadRequest.getBucketName(),             "The bucket name parameter must be specified when initiating a multipart upload");         assertParameterNotNull(initiateMultipartUploadRequest.getKey(),             "The key parameter must be specified when initiating a multipart upload");          Request<InitiateMultipartUploadRequest> request = createRequest(initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey(), initiateMultipartUploadRequest, HttpMethodName.POST);         request.addParameter("uploads", null);          if (initiateMultipartUploadRequest.getStorageClass() != null)             request.addHeader(Headers.STORAGE_CLASS, initiateMultipartUploadRequest.getStorageClass().toString());          if (initiateMultipartUploadRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, initiateMultipartUploadRequest.getRedirectLocation());         }          if ( initiateMultipartUploadRequest.getAccessControlList() != null ) {             addAclHeaders(request, initiateMultipartUploadRequest.getAccessControlList());         } else if ( initiateMultipartUploadRequest.getCannedACL() != null ) {             request.addHeader(Headers.S3_CANNED_ACL, initiateMultipartUploadRequest.getCannedACL().toString());         }          if (initiateMultipartUploadRequest.objectMetadata != null) {             populateRequestMetadata(request, initiateMultipartUploadRequest.objectMetadata);         }          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, initiateMultipartUploadRequest.getSSECustomerKey());          // Be careful that we don't send the object's total size as the content         // length for the InitiateMultipartUpload request.         setZeroContentLength(request);         // Set the request content to be empty (but not null) to force the runtime to pass         // any query params in the query string and not the request body, to keep S3 happy.         request.setContent(new ByteArrayInputStream(new byte[0]));          @SuppressWarnings("unchecked")         ResponseHeaderHandlerChain<InitiateMultipartUploadResult> responseHandler = new ResponseHeaderHandlerChain<InitiateMultipartUploadResult>(                 // xml payload unmarshaller                 new Unmarshallers.InitiateMultipartUploadResultUnmarshaller(),                 // header handlers                 new ServerSideEncryptionHeaderHandler<InitiateMultipartUploadResult>());         return invoke(request, responseHandler,                 initiateMultipartUploadRequest.getBucketName(), initiateMultipartUploadRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listMultipartUploads(com.amazonaws.services.s3.model.ListMultipartUploadsRequest)      */     public MultipartUploadListing listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listMultipartUploadsRequest,             "The request parameter must be specified when listing multipart uploads");          assertParameterNotNull(listMultipartUploadsRequest.getBucketName(),             "The bucket name parameter must be specified when listing multipart uploads");          Request<ListMultipartUploadsRequest> request = createRequest(listMultipartUploadsRequest.getBucketName(), null, listMultipartUploadsRequest, HttpMethodName.GET);         request.addParameter("uploads", null);          if (listMultipartUploadsRequest.getKeyMarker() != null) request.addParameter("key-marker", listMultipartUploadsRequest.getKeyMarker());         if (listMultipartUploadsRequest.getMaxUploads() != null) request.addParameter("max-uploads", listMultipartUploadsRequest.getMaxUploads().toString());         if (listMultipartUploadsRequest.getUploadIdMarker() != null) request.addParameter("upload-id-marker", listMultipartUploadsRequest.getUploadIdMarker());         if (listMultipartUploadsRequest.getDelimiter() != null) request.addParameter("delimiter", listMultipartUploadsRequest.getDelimiter());         if (listMultipartUploadsRequest.getPrefix() != null) request.addParameter("prefix", listMultipartUploadsRequest.getPrefix());         if (listMultipartUploadsRequest.getEncodingType() != null) request.addParameter("encoding-type", listMultipartUploadsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListMultipartUploadsResultUnmarshaller(), listMultipartUploadsRequest.getBucketName(), null);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#listParts(com.amazonaws.services.s3.model.ListPartsRequest)      */     public PartListing listParts(ListPartsRequest listPartsRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(listPartsRequest,             "The request parameter must be specified when listing parts");          assertParameterNotNull(listPartsRequest.getBucketName(),             "The bucket name parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getKey(),             "The key parameter must be specified when listing parts");         assertParameterNotNull(listPartsRequest.getUploadId(),             "The upload ID parameter must be specified when listing parts");          Request<ListPartsRequest> request = createRequest(listPartsRequest.getBucketName(), listPartsRequest.getKey(), listPartsRequest, HttpMethodName.GET);         request.addParameter("uploadId", listPartsRequest.getUploadId());          if (listPartsRequest.getMaxParts() != null) request.addParameter("max-parts", listPartsRequest.getMaxParts().toString());         if (listPartsRequest.getPartNumberMarker() != null) request.addParameter("part-number-marker", listPartsRequest.getPartNumberMarker().toString());         if (listPartsRequest.getEncodingType() != null) request.addParameter("encoding-type", listPartsRequest.getEncodingType());          return invoke(request, new Unmarshallers.ListPartsResultUnmarshaller(), listPartsRequest.getBucketName(), listPartsRequest.getKey());     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#uploadPart(com.amazonaws.services.s3.model.UploadPartRequest)      */     public UploadPartResult uploadPart(UploadPartRequest uploadPartRequest)             throws AmazonClientException, AmazonServiceException {         assertParameterNotNull(uploadPartRequest,             "The request parameter must be specified when uploading a part");          String bucketName = uploadPartRequest.getBucketName();         String key        = uploadPartRequest.getKey();         String uploadId   = uploadPartRequest.getUploadId();         int partNumber    = uploadPartRequest.getPartNumber();         long partSize     = uploadPartRequest.getPartSize();          assertParameterNotNull(bucketName,             "The bucket name parameter must be specified when uploading a part");         assertParameterNotNull(key,             "The key parameter must be specified when uploading a part");         assertParameterNotNull(uploadId,             "The upload ID parameter must be specified when uploading a part");         assertParameterNotNull(partNumber,             "The part number parameter must be specified when uploading a part");         assertParameterNotNull(partSize,             "The part size parameter must be specified when uploading a part");          Request<UploadPartRequest> request = createRequest(bucketName, key, uploadPartRequest, HttpMethodName.PUT);         request.addParameter("uploadId", uploadId);         request.addParameter("partNumber", Integer.toString(partNumber));          addHeaderIfNotNull(request, Headers.CONTENT_MD5, uploadPartRequest.getMd5Digest());         request.addHeader(Headers.CONTENT_LENGTH, Long.toString(partSize));          // Populate the SSE-CPK parameters to the request header         populateSseCpkRequestParameters(request, uploadPartRequest.getSSECustomerKey());          InputStream inputStream = null;         if (uploadPartRequest.getInputStream() != null) {             inputStream = uploadPartRequest.getInputStream();         } else if (uploadPartRequest.getFile() != null) {             try {                 inputStream = new InputSubstream(new RepeatableFileInputStream(uploadPartRequest.getFile()),                         uploadPartRequest.getFileOffset(), partSize, true);             } catch (FileNotFoundException e) {                 throw new IllegalArgumentException("The specified file doesn't exist", e);             }         } else {             throw new IllegalArgumentException("A File or InputStream must be specified when uploading part");         }          MD5DigestCalculatingInputStream md5DigestStream = null;         if ( uploadPartRequest.getMd5Digest() == null                 && !skipContentMd5IntegrityCheck(uploadPartRequest) ) {             /*              * If the user hasn't set the content MD5, then we don't want to              * buffer the whole stream in memory just to calculate it. Instead,              * we can calculate it on the fly and validate it with the returned              * ETag from the object upload.              */             inputStream = md5DigestStream = new MD5DigestCalculatingInputStream(inputStream);         }          /*          * This is compatible with progress listener set by either the legacy          * method UploadPartRequest#setProgressListener or the new method          * UploadPartRequest#setGeneralProgressListener.          */         ProgressListener progressListener = uploadPartRequest.getGeneralProgressListener();         ProgressListenerCallbackExecutor progressListenerCallbackExecutor = ProgressListenerCallbackExecutor                 .wrapListener(progressListener);          if (progressListenerCallbackExecutor != null) {             inputStream = new ProgressReportingInputStream(inputStream, progressListenerCallbackExecutor);             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_STARTED_EVENT_CODE);         }          try {             request.setContent(inputStream);             ObjectMetadata metadata = invoke(request, new S3MetadataResponseHandler(), bucketName, key);              if (metadata != null && md5DigestStream != null) {                 byte[] clientSideHash = md5DigestStream.getMd5Digest();                 byte[] serverSideHash = BinaryUtils.fromHex(metadata.getETag());                  if (!Arrays.equals(clientSideHash, serverSideHash)) {                     throw new AmazonClientException("Unable to verify integrity of data upload.  " +                             "Client calculated content hash didn't match hash calculated by Amazon S3.  " +                             "You may need to delete the data stored in Amazon S3.");                 }             }              fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              UploadPartResult result = new UploadPartResult();             result.setETag(metadata.getETag());             result.setPartNumber(partNumber);             result.setSSEAlgorithm(metadata.getSSEAlgorithm());             result.setSSECustomerAlgorithm(metadata.getSSECustomerAlgorithm());             result.setSSECustomerKeyMd5(metadata.getSSECustomerKeyMd5());             return result;         } catch (AmazonClientException ace) {             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_FAILED_EVENT_CODE);              // Leaving this here in case anyone is depending on it, but it's             // inconsistent with other methods which only generate one of             // COMPLETED_EVENT_CODE or FAILED_EVENT_CODE.             fireProgressEvent(progressListenerCallbackExecutor, ProgressEvent.PART_COMPLETED_EVENT_CODE);              throw ace;         } finally {             if (inputStream != null) {                 try {inputStream.close();}                 catch (Exception e) {}             }         }     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#getResponseMetadataForRequest(com.amazonaws.AmazonWebServiceRequest)      */     public S3ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {         return (S3ResponseMetadata)client.getResponseMetadataForRequest(request);     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#restoreObject(com.amazonaws.services.s3.model.RestoreObjectRequest)      */     public void restoreObject(RestoreObjectRequest restoreObjectRequest)             throws AmazonServiceException {         String bucketName = restoreObjectRequest.getBucketName();         String key = restoreObjectRequest.getKey();         String versionId = restoreObjectRequest.getVersionId();         int expirationIndays = restoreObjectRequest.getExpirationInDays();          assertParameterNotNull(bucketName, "The bucket name parameter must be specified when copying a glacier object");         assertParameterNotNull(key, "The key parameter must be specified when copying a glacier object");         if (expirationIndays == -1) {             throw new IllegalArgumentException("The expiration in days parameter must be specified when copying a glacier object");         }           Request<RestoreObjectRequest> request = createRequest(bucketName, key, restoreObjectRequest, HttpMethodName.POST);         request.addParameter("restore", null);         if (versionId != null) {             request.addParameter("versionId", versionId);         }          byte[] content = RequestXmlFactory.convertToXmlByteArray(restoreObjectRequest);         request.addHeader("Content-Length", String.valueOf(content.length));         request.addHeader("Content-Type", "application/xml");         request.setContent(new ByteArrayInputStream(content));         try {             byte[] md5 = Md5Utils.computeMD5Hash(content);             String md5Base64 = BinaryUtils.toBase64(md5);             request.addHeader("Content-MD5", md5Base64);         } catch (Exception e) {             throw new AmazonClientException("Couldn't compute md5 sum", e);         }          invoke(request, voidResponseHandler, bucketName, key);     }      /** (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#copyGlacierObject((java.lang.String, java.lang.String, int)      */     public void restoreObject(String bucketName, String key, int expirationInDays)             throws AmazonServiceException {         restoreObject(new RestoreObjectRequest(bucketName, key, expirationInDays));     }       /*      * Private Interface      */      /**      * <p>      * Asserts that the specified parameter value is not <code>null</code> and if it is,      * throws an <code>IllegalArgumentException</code> with the specified error message.      * </p>      *      * @param parameterValue      *            The parameter value being checked.      * @param errorMessage      *            The error message to include in the IllegalArgumentException      *            if the specified parameter is null.      */     private void assertParameterNotNull(Object parameterValue, String errorMessage) {         if (parameterValue == null) throw new IllegalArgumentException(errorMessage);     }       /**      * Fires a progress event with the specified event type to the specified      * listener.      *      * @param progressListenerCallbackExecutor      *            The listener callback executor.      * @param eventType      *            The type of event to fire.      */     private void fireProgressEvent(final ProgressListenerCallbackExecutor progressListenerCallbackExecutor, final int eventType) {         if (progressListenerCallbackExecutor == null) return;         ProgressEvent event = new ProgressEvent(0);         event.setEventCode(eventType);         progressListenerCallbackExecutor.progressChanged(event);     }      /**      * <p>      * Gets the Amazon S3 {@link AccessControlList} (ACL) for the specified resource.      * (bucket if only the bucketName parameter is specified, otherwise the object with the      * specified key in the bucket).      * </p>      *      * @param bucketName      *            The name of the bucket whose ACL should be returned if the key      *            parameter is not specified, otherwise the bucket containing      *            the specified key.      * @param key      *            The object key whose ACL should be retrieve. If not specified,      *            the bucket's ACL is returned.      * @param versionId      *            The version ID of the object version whose ACL is being      *            retrieved.      * @param originalRequest      *            The original, user facing request object.      *      * @return The S3 ACL for the specified resource.      */     private AccessControlList getAcl(String bucketName, String key, String versionId, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.GET);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          return invoke(request, new Unmarshallers.AccessControlListUnmarshaller(), bucketName, key);     }      /**      * Sets the Canned ACL for the specified resource in S3. If only bucketName      * is specified, the canned ACL will be applied to the bucket, otherwise if      * bucketName and key are specified, the canned ACL will be applied to the      * object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param cannedAcl      *            The canned ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, CannedAccessControlList cannedAcl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         request.addHeader(Headers.S3_CANNED_ACL, cannedAcl.toString());         if (versionId != null) request.addParameter("versionId", versionId);          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Sets the ACL for the specified resource in S3. If only bucketName is      * specified, the ACL will be applied to the bucket, otherwise if bucketName      * and key are specified, the ACL will be applied to the object.      *      * @param bucketName      *            The name of the bucket containing the specified key, or if no      *            key is listed, the bucket whose ACL will be set.      * @param key      *            The optional object key within the specified bucket whose ACL      *            will be set. If not specified, the bucket ACL will be set.      * @param versionId      *            The version ID of the object version whose ACL is being set.      * @param acl      *            The ACL to apply to the resource.      * @param originalRequest      *            The original, user facing request object.      */     private void setAcl(String bucketName, String key, String versionId, AccessControlList acl, AmazonWebServiceRequest originalRequest) {         if (originalRequest == null) originalRequest = new GenericBucketRequest(bucketName);          Request<AmazonWebServiceRequest> request = createRequest(bucketName, key, originalRequest, HttpMethodName.PUT);         request.addParameter("acl", null);         if (versionId != null) request.addParameter("versionId", versionId);          byte[] aclAsXml = new AclXmlFactory().convertToXmlByteArray(acl);         request.addHeader("Content-Type", "text/plain");         request.addHeader("Content-Length", String.valueOf(aclAsXml.length));         request.setContent(new ByteArrayInputStream(aclAsXml));          invoke(request, voidResponseHandler, bucketName, key);     }      /**      * Returns a "complete" S3 specific signer, taking into the S3 bucket, key,      * and the current S3 client configuration into account.      */     protected Signer createSigner(final Request<?> request,                                   final String bucketName,                                   final String key) {          Signer signer = getSigner();          if (upgradeToSigV4() && !(signer instanceof AWSS3V4Signer)){              AWSS3V4Signer v4Signer = new AWSS3V4Signer();              // Always set the service name; if the user has overridden it via             // setEndpoint(String, String, String), this will return the right             // value. Otherwise it will return "s3", which is an appropriate             // default.             v4Signer.setServiceName(getServiceNameIntern());              // If the user has set an authentication region override, pass it             // to the signer. Otherwise leave it null - the signer will parse             // region from the request endpoint.              String regionOverride = getSignerRegionOverride();             if (regionOverride == null) {                 if (!hasExplicitRegion) {                     throw new AmazonClientException(                         "Signature Version 4 requires knowing the region of "                         + "the bucket you're trying to access. You can "                         + "configure a region by calling AmazonS3Client."                         + "setRegion(Region) or AmazonS3Client.setEndpoint("                         + "String) with a region-specific endpoint such as "                         + "\"s3-us-west-2.amazonaws.com\".");                 }             } else {                 v4Signer.setRegionName(regionOverride);             }              return v4Signer;          }          if (signer instanceof S3Signer) {              // The old S3Signer needs a method and path passed to its             // constructor; if that's what we should use, getSigner()             // will return a dummy instance and we need to create a             // new one with the appropriate values for this request.              String resourcePath =                 "/" +                 ((bucketName != null) ? bucketName + "/" : "") +                 ((key != null) ? key : "");              return new S3Signer(request.getHttpMethod().toString(),                                 resourcePath);         }          return signer;     }      private boolean upgradeToSigV4() {          // User has said to always use SigV4 - this will fail if the user         // attempts to read from or write to a non-US-Standard bucket without         // explicitly setting the region.          if (System.getProperty(SDKGlobalConfiguration                 .ENFORCE_S3_SIGV4_SYSTEM_PROPERTY) != null) {              return true;         }          // User has said to enable SigV4 if it's safe - this will fall back         // to SigV2 if the endpoint has not been set to one of the explicit         // regional endpoints because we can't be sure it will work otherwise.          if (System.getProperty(SDKGlobalConfiguration                 .ENABLE_S3_SIGV4_SYSTEM_PROPERTY) != null             && !endpoint.getHost().endsWith(Constants.S3_HOSTNAME)) {              return true;         }          // Go with the default (SigV4 only if we know we're talking to an         // endpoint that requires SigV4).          return false;     }      /**      * Pre-signs the specified request, using a signature query-string      * parameter.      *      * @param request      *            The request to sign.      * @param methodName      *            The HTTP method (GET, PUT, DELETE, HEAD) for the specified      *            request.      * @param bucketName      *            The name of the bucket involved in the request. If the request      *            is not an operation on a bucket this parameter should be null.      * @param key      *            The object key involved in the request. If the request is not      *            an operation on an object, this parameter should be null.      * @param expiration      *            The time at which the signed request is no longer valid, and      *            will stop working.      * @param subResource      *            The optional sub-resource being requested as part of the      *            request (e.g. "location", "acl", "logging", or "torrent").      */     protected <T> void presignRequest(Request<T> request, HttpMethod methodName,             String bucketName, String key, Date expiration, String subResource) {         // Run any additional request handlers if present         beforeRequest(request);          String resourcePath = "/" +             ((bucketName != null) ? bucketName + "/" : "") +             ((key != null) ? HttpUtils.urlEncode(key, true) : "") +             ((subResource != null) ? "?" + subResource : "");          // Make sure the resource-path for signing does not contain         // any consecutive "/"s.         // Note that we should also follow the same rule to escape         // consecutive "/"s when generating the presigned URL.         // See ServiceUtils#convertRequestToUrl(...)         resourcePath = resourcePath.replaceAll("(?<=/)/", "%2F");          AWSCredentials credentials = awsCredentialsProvider.getCredentials();         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         if (originalRequest != null && originalRequest.getRequestCredentials() != null) {             credentials = originalRequest.getRequestCredentials();         }          new S3QueryStringSigner<T>(methodName.toString(), resourcePath, expiration).sign(request, credentials);          // The Amazon S3 DevPay token header is a special exception and can be safely moved         // from the request's headers into the query string to ensure that it travels along         // with the pre-signed URL when it's sent back to Amazon S3.         if (request.getHeaders().containsKey(Headers.SECURITY_TOKEN)) {             String value = request.getHeaders().get(Headers.SECURITY_TOKEN);             request.addParameter(Headers.SECURITY_TOKEN, value);             request.getHeaders().remove(Headers.SECURITY_TOKEN);         }     }      private <T> void beforeRequest(Request<T> request) {         if (requestHandler2s != null) {             for (RequestHandler2 requestHandler2 : requestHandler2s) {                 requestHandler2.beforeRequest(request);             }         }     }      /**      * Converts the current endpoint set for this client into virtual addressing      * style, by placing the name of the specified bucket before the S3 service      * endpoint.      *      * @param bucketName      *            The name of the bucket to use in the virtual addressing style      *            of the returned URI.      *      * @return A new URI, creating from the current service endpoint URI and the      *         specified bucket.      */     private URI convertToVirtualHostEndpoint(String bucketName) {         try {             return new URI(endpoint.getScheme() + "://" + bucketName + "." + endpoint.getAuthority());         } catch (URISyntaxException e) {             throw new IllegalArgumentException("Invalid bucket name: " + bucketName, e);         }     }      /**      * <p>      * Populates the specified request object with the appropriate headers from      * the {@link ObjectMetadata} object.      * </p>      *      * @param request      *            The request to populate with headers.      * @param metadata      *            The metadata containing the header information to include in      *            the request.      */     protected static void populateRequestMetadata(Request<?> request, ObjectMetadata metadata) {         Map<String, Object> rawMetadata = metadata.getRawMetadata();         if (rawMetadata != null) {             for (Entry<String, Object> entry : rawMetadata.entrySet()) {                 request.addHeader(entry.getKey(), entry.getValue().toString());             }         }          Date httpExpiresDate = metadata.getHttpExpiresDate();         if (httpExpiresDate != null) {             request.addHeader(Headers.EXPIRES, DateUtils.formatRFC822Date(httpExpiresDate));         }          Map<String, String> userMetadata = metadata.getUserMetadata();         if (userMetadata != null) {             for (Entry<String, String> entry : userMetadata.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (key != null) key = key.trim();                 if (value != null) value = value.trim();                 request.addHeader(Headers.S3_USER_METADATA_PREFIX + key, value);             }         }     }      /**      * <p>      * Populates the specified request with the specified Multi-Factor      * Authentication (MFA) details. This includes the MFA header with device serial      * number and generated token. Since all requests which include the MFA      * header must be sent over HTTPS, this operation also configures the request object to      * use HTTPS instead of HTTP.      * </p>      *      * @param request      *            The request to populate.      * @param mfa      *            The Multi-Factor Authentication information.      */     private void populateRequestWithMfaDetails(Request<?> request, MultiFactorAuthentication mfa) {         if (mfa == null) return;          String endpoint = request.getEndpoint().toString();         if (endpoint.startsWith("http://")) {             String httpsEndpoint = endpoint.replace("http://", "https://");             request.setEndpoint(URI.create(httpsEndpoint));             log.info("Overriding current endpoint to use HTTPS " +                     "as required by S3 for requests containing an MFA header");         }          request.addHeader(Headers.S3_MFA,                 mfa.getDeviceSerialNumber() + " " + mfa.getToken());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyObjectRequest</code> object.      * @param copyObjectRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyObjectParameters(Request<? extends AmazonWebServiceRequest> request, CopyObjectRequest copyObjectRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyObjectRequest.getSourceKey(), true);         if (copyObjectRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyObjectRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyObjectRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyObjectRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyObjectRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyObjectRequest.getNonmatchingETagConstraints());          if (copyObjectRequest.getAccessControlList() != null) {             addAclHeaders(request, copyObjectRequest.getAccessControlList());         } else if (copyObjectRequest.getCannedAccessControlList() != null) {             request.addHeader(Headers.S3_CANNED_ACL,                     copyObjectRequest.getCannedAccessControlList().toString());         }          if (copyObjectRequest.getStorageClass() != null) {             request.addHeader(Headers.STORAGE_CLASS, copyObjectRequest.getStorageClass());         }          if (copyObjectRequest.getRedirectLocation() != null) {             request.addHeader(Headers.REDIRECT_LOCATION, copyObjectRequest.getRedirectLocation());         }          ObjectMetadata newObjectMetadata = copyObjectRequest.getNewObjectMetadata();         if (newObjectMetadata != null) {             request.addHeader(Headers.METADATA_DIRECTIVE, "REPLACE");             populateRequestMetadata(request, newObjectMetadata);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyObjectRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyObjectRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous options available in      * <code>CopyObjectRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the <code>CopyPartRequest</code> object.      * @param copyPartRequest      *            The object containing all the options for copying an object in      *            Amazon S3.      */     private static void populateRequestWithCopyPartParameters(Request<?> request, CopyPartRequest copyPartRequest) {         String copySourceHeader =              "/" + HttpUtils.urlEncode(copyPartRequest.getSourceBucketName(), true)            + "/" + HttpUtils.urlEncode(copyPartRequest.getSourceKey(), true);         if (copyPartRequest.getSourceVersionId() != null) {             copySourceHeader += "?versionId=" + copyPartRequest.getSourceVersionId();         }         request.addHeader("x-amz-copy-source", copySourceHeader);          addDateHeader(request, Headers.COPY_SOURCE_IF_MODIFIED_SINCE,                 copyPartRequest.getModifiedSinceConstraint());         addDateHeader(request, Headers.COPY_SOURCE_IF_UNMODIFIED_SINCE,                 copyPartRequest.getUnmodifiedSinceConstraint());          addStringListHeader(request, Headers.COPY_SOURCE_IF_MATCH,                 copyPartRequest.getMatchingETagConstraints());         addStringListHeader(request, Headers.COPY_SOURCE_IF_NO_MATCH,                 copyPartRequest.getNonmatchingETagConstraints());          if ( copyPartRequest.getFirstByte() != null && copyPartRequest.getLastByte() != null ) {             String range = "bytes=" + copyPartRequest.getFirstByte() + "-" + copyPartRequest.getLastByte();             request.addHeader(Headers.COPY_PART_RANGE, range);         }          // Populate the SSE-CPK parameters for the destination object         populateSourceSseCpkRequestParameters(request, copyPartRequest.getSourceSSECustomerKey());         populateSseCpkRequestParameters(request, copyPartRequest.getDestinationSSECustomerKey());     }      /**      * <p>      * Populates the specified request with the numerous attributes available in      * <code>SSEWithCustomerKeyRequest</code>.      * </p>      *      * @param request      *            The request to populate with headers to represent all the      *            options expressed in the      *            <code>ServerSideEncryptionWithCustomerKeyRequest</code>      *            object.      * @param sseCpkRequest      *            The request object for an S3 operation that allows server-side      *            encryption using customer-provided keys.      */     private static void populateSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      private static void populateSourceSseCpkRequestParameters(Request<?> request, SSECustomerKey sseKey) {         if (sseKey == null) return;          // Populate the SSE-CPK parameters for the source object         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM,                 sseKey.getAlgorithm());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,                 sseKey.getKey());         addHeaderIfNotNull(request, Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                 sseKey.getMd5());         // Calculate the MD5 hash of the encryption key and fill it in the         // header, if the user didn't specify it in the metadata         if (sseKey.getKey() != null                 && sseKey.getMd5() == null) {             String encryptionKey_b64 = sseKey.getKey();             byte[] encryptionKey = Base64.decode(encryptionKey_b64);             request.addHeader(Headers.COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,                     Md5Utils.md5AsBase64(encryptionKey));         }     }      /**      * Adds the specified header to the specified request, if the header value      * is not null.      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addHeaderIfNotNull(Request<?> request, String header, String value) {         if (value != null) {             request.addHeader(header, value);         }     }      /**      * <p>      * Adds the specified date header in RFC 822 date format to the specified      * request.      * This method will not add a date header if the specified date value is <code>null</code>.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param value      *            The header value.      */     private static void addDateHeader(Request<?> request, String header, Date value) {         if (value != null) {             request.addHeader(header, ServiceUtils.formatRfc822Date(value));         }     }      /**      * <p>      * Adds the specified string list header, joined together separated with      * commas, to the specified request.      * This method will not add a string list header if the specified values      * are <code>null</code> or empty.      * </p>      *      * @param request      *            The request to add the header to.      * @param header      *            The header name.      * @param values      *            The list of strings to join together for the header value.      */     private static void addStringListHeader(Request<?> request, String header, List<String> values) {         if (values != null && !values.isEmpty()) {             request.addHeader(header, ServiceUtils.join(values));         }     }      /**      * <p>      * Adds response headers parameters to the request given, if non-null.      * </p>      *      * @param request      *            The request to add the response header parameters to.      * @param responseHeaders      *            The full set of response headers to add, or null for none.      */     private static void addResponseHeaderParameters(Request<?> request, ResponseHeaderOverrides responseHeaders) {         if ( responseHeaders != null ) {             if ( responseHeaders.getCacheControl() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CACHE_CONTROL, responseHeaders.getCacheControl());             }             if ( responseHeaders.getContentDisposition() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_DISPOSITION,                         responseHeaders.getContentDisposition());             }             if ( responseHeaders.getContentEncoding() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_ENCODING,                         responseHeaders.getContentEncoding());             }             if ( responseHeaders.getContentLanguage() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_LANGUAGE,                         responseHeaders.getContentLanguage());             }             if ( responseHeaders.getContentType() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_CONTENT_TYPE, responseHeaders.getContentType());             }             if ( responseHeaders.getExpires() != null ) {                 request.addParameter(ResponseHeaderOverrides.RESPONSE_HEADER_EXPIRES, responseHeaders.getExpires());             }         }     }      /**      * Returns the URL to the key in the bucket given, using the client's scheme      * and endpoint. Returns null if the given bucket and key cannot be      * converted to a URL.      */     public String getResourceUrl(String bucketName, String key) {         try {             return getUrl(bucketName, key).toString();         } catch ( Exception e ) {             return null;         }     }      /**      * Returns an URL for the object stored in the specified bucket and      * key.      * <p>      * If the object identified by the given bucket and key has public read      * permissions (ex: {@link CannedAccessControlList#PublicRead}), then this      * URL can be directly accessed to retrieve the object's data.      *      * @param bucketName      *            The name of the bucket containing the object whose URL is      *            being requested.      * @param key      *            The key under which the object whose URL is being requested is      *            stored.      *      * @return A unique URL for the object stored in the specified bucket and      *         key.      */     public URL getUrl(String bucketName, String key) {         Request<?> request = new DefaultRequest<Object>(Constants.S3_SERVICE_NAME);         configRequest(request, bucketName, key);         return ServiceUtils.convertRequestToUrl(request);     }      public Region getRegion() {         String authority = super.endpoint.getAuthority();         if (Constants.S3_HOSTNAME.equals(authority)) {             return Region.US_Standard;         }         Matcher m = Region.S3_REGIONAL_ENDPOINT_PATTERN.matcher(authority);         if (m.matches()) {             return Region.fromValue(m.group(1));         } else {             throw new IllegalStateException("S3 client with invalid S3 endpoint configured");         }     }      /**      * Creates and initializes a new request object for the specified S3      * resource. This method is responsible for determining the right way to      * address resources. For example, bucket names that are not DNS addressable      * cannot be addressed in V2, virtual host, style, and instead must use V1,      * path style. The returned request object has the service name, endpoint      * and resource path correctly populated. Callers can take the request, add      * any additional headers or parameters, then sign and execute the request.      *      * @param bucketName      *            An optional parameter indicating the name of the bucket      *            containing the resource involved in the request.      * @param key      *            An optional parameter indicating the key under which the      *            desired resource is stored in the specified bucket.      * @param originalRequest      *            The original request, as created by the user.      * @param httpMethod      *            The HTTP method to use when sending the request.      *      * @return A new request object, populated with endpoint, resource path, and      *         service name, ready for callers to populate any additional      *         headers or parameters, and execute.      */     protected <X extends AmazonWebServiceRequest> Request<X> createRequest(String bucketName, String key, X originalRequest, HttpMethodName httpMethod) {         Request<X> request = new DefaultRequest<X>(originalRequest, Constants.S3_SERVICE_NAME);         request.setHttpMethod(httpMethod);         configRequest(request, bucketName, key);         return request;     }      /**      * Configure the given request with the specified bucket name and key.      * @return the request configured      */     private void configRequest(         Request<?> request, String bucketName, String key)     {         if ( !clientOptions.isPathStyleAccess()              && BucketNameUtils.isDNSBucketName(bucketName)              && !validIP(endpoint.getHost()) ) {             request.setEndpoint(convertToVirtualHostEndpoint(bucketName));             /*              * If the key name starts with a slash character, in order to              * prevent it being treated as a path delimiter, we need to add              * another slash before the key name.              * {@see com.amazonaws.http.HttpRequestFactory#createHttpRequest}              */             if (key != null && key.startsWith("/")) {                 key = "/" + key;             }             request.setResourcePath(key);         } else {             request.setEndpoint(endpoint);              if (bucketName != null) {                 request.setResourcePath(bucketName + "/" + (key != null ? key : ""));             }         }     }      private boolean validIP(String IP) {         if (IP == null) {             return false;         }         String[] tokens = IP.split("\\.");         if (tokens.length != 4) {             return false;         }         for (String token : tokens) {             int tokenInt;             try {                 tokenInt = Integer.parseInt(token);             } catch (NumberFormatException ase) {                 return false;             }             if (tokenInt < 0 || tokenInt > 255) {                 return false;             }          }         return true;     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,                                   Unmarshaller<X, InputStream> unmarshaller,                                   String bucketName,                                   String key) {         return invoke(request, new S3XmlResponseHandler<X>(unmarshaller), bucketName, key);     }      @Override     protected final ExecutionContext createExecutionContext(AmazonWebServiceRequest req) {         boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();         return new S3ExecutionContext(requestHandler2s, isMetricsEnabled, this);     }      private <X, Y extends AmazonWebServiceRequest> X invoke(Request<Y> request,             HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,             String bucket, String key) {         AmazonWebServiceRequest originalRequest = request.getOriginalRequest();         ExecutionContext executionContext = createExecutionContext(originalRequest);         AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();         // Binds the request metrics to the current request.         request.setAWSRequestMetrics(awsRequestMetrics);         // Having the ClientExecuteTime defined here is not ideal (for the         // timing measurement should start as close to the top of the call         // stack of the service client method as possible)         // but definitely a safe compromise for S3 at least for now.         // We can incrementally make it more elaborate should the need arise         // for individual method.         awsRequestMetrics.startEvent(Field.ClientExecuteTime);         Response<X> response = null;         try {             for (Entry<String, String> entry : request.getOriginalRequest()                     .copyPrivateRequestParameters().entrySet()) {                 request.addParameter(entry.getKey(), entry.getValue());             }             request.setTimeOffset(timeOffset);             /*              * The string we sign needs to include the exact headers that we              * send with the request, but the client runtime layer adds the              * Content-Type header before the request is sent if one isn't set,              * so we have to set something here otherwise the request will fail.              */             if (!request.getHeaders().containsKey(Headers.CONTENT_TYPE)) {                 request.addHeader(Headers.CONTENT_TYPE,                     "application/x-www-form-urlencoded; charset=utf-8");             }             AWSCredentials credentials = awsCredentialsProvider.getCredentials();             if (originalRequest.getRequestCredentials() != null) {                 credentials = originalRequest.getRequestCredentials();             }             executionContext.setSigner(createSigner(request, bucket, key));             executionContext.setCredentials(credentials);             response = client.execute(request, responseHandler,                     errorResponseHandler, executionContext);             return response.getAwsResponse();         } finally {             endClientExecution(awsRequestMetrics, request, response);         }    }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#enableRequesterPays(java.lang.String)      */     @Override     public void enableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.Requester);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#disableRequesterPays(java.lang.String)      */     @Override     public void disableRequesterPays(String bucketName) {         RequestPaymentConfiguration configuration = new RequestPaymentConfiguration(                 Payer.BucketOwner);          setBucketRequestPayment(new SetRequestPaymentConfigurationRequest(                 bucketName, configuration));     }      /* (non-Javadoc)      * @see com.amazonaws.services.s3.AmazonS3#isRequesterPaysEnabled(java.lang.String)      */     @Override     public boolean isRequesterPaysEnabled(String bucketName) {         RequestPaymentConfiguration configuration = getBucketRequestPayment(new GetRequestPaymentConfigurationRequest(                 bucketName));         return (configuration.getPayer() == Payer.Requester);     }      /**      * Sets the request payment configuration for a given Amazon S3 bucket.      * This operation can be done only by the owner of the Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is set to      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private void setBucketRequestPayment(             SetRequestPaymentConfigurationRequest setRequestPaymentConfigurationRequest) {          String bucketName = setRequestPaymentConfigurationRequest                 .getBucketName();         RequestPaymentConfiguration configuration = setRequestPaymentConfigurationRequest                 .getConfiguration();          assertParameterNotNull(bucketName,                 "The bucket name parameter must be specified while setting the Requester Pays.");          assertParameterNotNull(                 configuration,                 "The request payment configuration parameter must be specified when setting the Requester Pays.");          Request<SetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, setRequestPaymentConfigurationRequest,                 HttpMethodName.PUT);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          byte[] bytes = requestPaymentConfigurationXmlFactory                 .convertToXmlByteArray(configuration);         request.setContent(new ByteArrayInputStream(bytes));          invoke(request, voidResponseHandler, bucketName, null);     }      /**      * Retrieves the request payment configuration for a given Amazon S3 bucket.      * <p>      * When the request payment configuration for a Amazon S3 bucket is      * <code>Requester</code>, the requester instead of the bucket owner pays      * the cost of the request and the data download from the bucket. The bucket      * owner always pays the cost of storing data.      */     private RequestPaymentConfiguration getBucketRequestPayment(             GetRequestPaymentConfigurationRequest getRequestPaymentConfigurationRequest) {          String bucketName = getRequestPaymentConfigurationRequest                 .getBucketName();          assertParameterNotNull(                 bucketName,                 "The bucket name parameter must be specified while getting the Request Payment Configuration.");          Request<GetRequestPaymentConfigurationRequest> request = createRequest(                 bucketName, null, getRequestPaymentConfigurationRequest,                 HttpMethodName.GET);         request.addParameter("requestPayment", null);         request.addHeader("Content-Type", "application/xml");          return invoke(request,                 new Unmarshallers.RequestPaymentConfigurationUnmarshaller(),                 bucketName, null);      }      private void setZeroContentLength(Request<?> req) {         // https://github.com/aws/aws-sdk-java/pull/215         // http://aws.amazon.com/articles/1109#14         req.addHeader(Headers.CONTENT_LENGTH, String.valueOf(0));    } } " compose:StringConcatenation merge: LineBased]
Merge scenario /home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_7ab10-257dd.revisions deleted!
false
44, [/home/local/CIN/rsmbf/rsmbf/conflicts_analyzer/downloads/aws-sdk-java/revisions/rev_7ab10_257dd/rev_7ab10-257dd/src/main/java/com/amazonaws/services/s3/AmazonS3Client.java]
Merge scenario [45] from a total of [132] merge scenarios

Merge scenario [46] from a total of [132] merge scenarios

Merge scenario [47] from a total of [132] merge scenarios

Merge scenario [48] from a total of [132] merge scenarios

Merge scenario [49] from a total of [132] merge scenarios

Merge scenario [50] from a total of [132] merge scenarios

Merge scenario [51] from a total of [132] merge scenarios

Merge scenario [52] from a total of [132] merge scenarios

Merge scenario [53] from a total of [132] merge scenarios

Merge scenario [54] from a total of [132] merge scenarios

Merge scenario [55] from a total of [132] merge scenarios

Merge scenario [56] from a total of [132] merge scenarios

Merge scenario [57] from a total of [132] merge scenarios

Merge scenario [58] from a total of [132] merge scenarios

Merge scenario [59] from a total of [132] merge scenarios

Merge scenario [60] from a total of [132] merge scenarios

Merge scenario [61] from a total of [132] merge scenarios

Merge scenario [62] from a total of [132] merge scenarios

Merge scenario [63] from a total of [132] merge scenarios

Merge scenario [64] from a total of [132] merge scenarios

Merge scenario [65] from a total of [132] merge scenarios

Merge scenario [66] from a total of [132] merge scenarios

Merge scenario [67] from a total of [132] merge scenarios

Merge scenario [68] from a total of [132] merge scenarios

Merge scenario [69] from a total of [132] merge scenarios

Merge scenario [70] from a total of [132] merge scenarios

Merge scenario [71] from a total of [132] merge scenarios

Merge scenario [72] from a total of [132] merge scenarios

Merge scenario [73] from a total of [132] merge scenarios

Merge scenario [74] from a total of [132] merge scenarios

Merge scenario [75] from a total of [132] merge scenarios

Merge scenario [76] from a total of [132] merge scenarios

Merge scenario [77] from a total of [132] merge scenarios

Merge scenario [78] from a total of [132] merge scenarios

Merge scenario [79] from a total of [132] merge scenarios

Merge scenario [80] from a total of [132] merge scenarios

Merge scenario [81] from a total of [132] merge scenarios

Merge scenario [82] from a total of [132] merge scenarios

Merge scenario [83] from a total of [132] merge scenarios

Merge scenario [84] from a total of [132] merge scenarios

Merge scenario [85] from a total of [132] merge scenarios

Merge scenario [86] from a total of [132] merge scenarios

Merge scenario [87] from a total of [132] merge scenarios

Merge scenario [88] from a total of [132] merge scenarios

Merge scenario [89] from a total of [132] merge scenarios

Merge scenario [90] from a total of [132] merge scenarios

Merge scenario [91] from a total of [132] merge scenarios

Merge scenario [92] from a total of [132] merge scenarios

Merge scenario [93] from a total of [132] merge scenarios

Merge scenario [94] from a total of [132] merge scenarios

Merge scenario [95] from a total of [132] merge scenarios

Merge scenario [96] from a total of [132] merge scenarios

Merge scenario [97] from a total of [132] merge scenarios

Merge scenario [98] from a total of [132] merge scenarios

Merge scenario [99] from a total of [132] merge scenarios

Merge scenario [100] from a total of [132] merge scenarios

Merge scenario [101] from a total of [132] merge scenarios

Merge scenario [102] from a total of [132] merge scenarios

Merge scenario [103] from a total of [132] merge scenarios

Merge scenario [104] from a total of [132] merge scenarios

Merge scenario [105] from a total of [132] merge scenarios

Merge scenario [106] from a total of [132] merge scenarios

Merge scenario [107] from a total of [132] merge scenarios

Merge scenario [108] from a total of [132] merge scenarios

Merge scenario [109] from a total of [132] merge scenarios

Merge scenario [110] from a total of [132] merge scenarios

Merge scenario [111] from a total of [132] merge scenarios

Merge scenario [112] from a total of [132] merge scenarios

Merge scenario [113] from a total of [132] merge scenarios

Merge scenario [114] from a total of [132] merge scenarios

Merge scenario [115] from a total of [132] merge scenarios

Merge scenario [116] from a total of [132] merge scenarios

Merge scenario [117] from a total of [132] merge scenarios

Merge scenario [118] from a total of [132] merge scenarios

Merge scenario [119] from a total of [132] merge scenarios

Merge scenario [120] from a total of [132] merge scenarios

Merge scenario [121] from a total of [132] merge scenarios

Merge scenario [122] from a total of [132] merge scenarios

Merge scenario [123] from a total of [132] merge scenarios

Merge scenario [124] from a total of [132] merge scenarios

Merge scenario [125] from a total of [132] merge scenarios

Merge scenario [126] from a total of [132] merge scenarios

Merge scenario [127] from a total of [132] merge scenarios

Merge scenario [128] from a total of [132] merge scenarios

Merge scenario [129] from a total of [132] merge scenarios

Merge scenario [130] from a total of [132] merge scenarios

Merge scenario [131] from a total of [132] merge scenarios

Merge scenario [132] from a total of [132] merge scenarios

[22, 44]
